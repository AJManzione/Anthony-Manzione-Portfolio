/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css/style.css */ \"./src/css/style.css\");\n/* harmony import */ var _js_three_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/three.js */ \"./src/js/three.js\");\n/* harmony import */ var _js_three_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_js_three_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _js_home_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/home.js */ \"./src/js/home.js\");\n/* harmony import */ var _js_home_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_js_home_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _src_images_anthony_portrait_jpg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/images/anthony-portrait.jpg */ \"./src/images/anthony-portrait.jpg\");\n/* harmony import */ var _src_images_gifs_port_one_gif__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/images/gifs/port-one.gif */ \"./src/images/gifs/port-one.gif\");\n/* harmony import */ var _src_images_gifs_port_two_gif__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/images/gifs/port-two.gif */ \"./src/images/gifs/port-two.gif\");\n/* harmony import */ var _src_images_gifs_port_three_gif__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/images/gifs/port-three.gif */ \"./src/images/gifs/port-three.gif\");\n/* harmony import */ var _src_images_gifs_readme_generator_gif__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/images/gifs/readme-generator.gif */ \"./src/images/gifs/readme-generator.gif\");\n/* harmony import */ var _src_images_gifs_team_profile_generator_gif__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/images/gifs/team-profile-generator.gif */ \"./src/images/gifs/team-profile-generator.gif\");\n/* harmony import */ var _src_images_blogs_blog_one_png__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/images/blogs/blog-one.png */ \"./src/images/blogs/blog-one.png\");\n/* harmony import */ var _src_images_blogs_blog_two_png__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../src/images/blogs/blog-two.png */ \"./src/images/blogs/blog-two.png\");\n/* harmony import */ var _src_images_Icons_linkedin_logo_png__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../src/images/Icons/linkedin-logo.png */ \"./src/images/Icons/linkedin-logo.png\");\n/* harmony import */ var _src_images_Icons_Github_Logos_GitHub_Mark_Light_120px_plus_png__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../src/images/Icons/Github-Logos/GitHub-Mark-Light-120px-plus.png */ \"./src/images/Icons/Github-Logos/GitHub-Mark-Light-120px-plus.png\");\n\n\n\n\ndocument.getElementById(\"author\").src = _src_images_anthony_portrait_jpg__WEBPACK_IMPORTED_MODULE_3__;\n\n\n\ndocument.getElementById(\"portOne\").src = _src_images_gifs_port_one_gif__WEBPACK_IMPORTED_MODULE_4__;\ndocument.getElementById(\"portTwo\").src = _src_images_gifs_port_two_gif__WEBPACK_IMPORTED_MODULE_5__;\ndocument.getElementById(\"portThree\").src = _src_images_gifs_port_three_gif__WEBPACK_IMPORTED_MODULE_6__;\n\n\ndocument.getElementById(\"cliOne\").src = _src_images_gifs_readme_generator_gif__WEBPACK_IMPORTED_MODULE_7__;\ndocument.getElementById(\"cliTwo\").src = _src_images_gifs_team_profile_generator_gif__WEBPACK_IMPORTED_MODULE_8__;\n\n\ndocument.getElementById(\"blogOne\").src = _src_images_blogs_blog_one_png__WEBPACK_IMPORTED_MODULE_9__;\ndocument.getElementById(\"blogTwo\").src = _src_images_blogs_blog_two_png__WEBPACK_IMPORTED_MODULE_10__;\n\n\ndocument.getElementById(\"linkedin\").src = _src_images_Icons_linkedin_logo_png__WEBPACK_IMPORTED_MODULE_11__;\ndocument.getElementById(\"github\").src = _src_images_Icons_Github_Logos_GitHub_Mark_Light_120px_plus_png__WEBPACK_IMPORTED_MODULE_12__;\n\n// Register service worker\n// Check that service workers are supported\nif ('serviceWorker' in navigator) {\n  // Use the window load event to keep the page load performant\n  window.addEventListener('load', function () {\n    navigator.serviceWorker.register('/service-worker.js');\n  });\n}\n\n//# sourceURL=webpack://17-ins_caching-images-client/./src/index.js?");

/***/ }),

/***/ "./src/js/home.js":
/*!************************!*\
  !*** ./src/js/home.js ***!
  \************************/
/***/ (() => {

eval("// reveal animation from bottom up\n\nfunction reveal() {\n  if (window.location.pathname === '/') {\n    var reveals = document.querySelectorAll(\".reveal\");\n    for (var i = 0; i < reveals.length; i++) {\n      var windowHeight = window.innerHeight;\n      var elementTop = reveals[i].getBoundingClientRect().top;\n      var elementVisible = 150;\n      if (elementTop < windowHeight - elementVisible) {\n        reveals[i].classList.add(\"active\");\n      } else {\n        reveals[i].classList.remove(\"active\");\n      }\n    }\n  }\n}\nwindow.addEventListener(\"scroll\", reveal);\n\n// reveal animation from left tp right\n\n$(document).ready(function () {\n  if (window.location.pathname === '/') {\n    //check to see if any animation containers are currently in view\n    var check_if_in_view = function check_if_in_view() {\n      //get current window information\n      var window_height = web_window.height();\n      var window_top_position = web_window.scrollTop();\n      var window_bottom_position = window_top_position + window_height;\n\n      //iterate through elements to see if its in view\n      $.each(animation_elements, function () {\n        //get the element sinformation\n        var element = $(this);\n        var element_height = $(element).outerHeight();\n        var element_top_position = $(element).offset().top;\n        var element_bottom_position = element_top_position + element_height;\n\n        //check to see if this current container is visible (its viewable if it exists between the viewable space of the viewport)\n        if (element_bottom_position >= window_top_position && element_top_position <= window_bottom_position) {\n          element.addClass('in-view');\n        } else {\n          element.removeClass('in-view');\n        }\n      });\n    }; //on or scroll, detect elements in view\n    //window and animation items\n    var animation_elements = $.find('.animation-element');\n    var web_window = $(window);\n    $(window).on('scroll resize', function () {\n      check_if_in_view();\n    });\n    //trigger our scroll event on initial load\n    $(window).trigger('scroll');\n  }\n});\n\n//# sourceURL=webpack://17-ins_caching-images-client/./src/js/home.js?");

/***/ }),

/***/ "./src/js/three.js":
/*!*************************!*\
  !*** ./src/js/three.js ***!
  \*************************/
/***/ (() => {

"use strict";
eval("// three.js - https://github.com/mrdoob/three.js\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar THREE = THREE || {\n  REVISION: \"56\"\n};\nself.console = self.console || {\n  info: function info() {},\n  log: function log() {},\n  debug: function debug() {},\n  warn: function warn() {},\n  error: function error() {}\n};\nself.Int32Array = self.Int32Array || Array;\nself.Float32Array = self.Float32Array || Array;\nString.prototype.trim = String.prototype.trim || function () {\n  return this.replace(/^\\s+|\\s+$/g, \"\");\n};\nTHREE.extend = function (a, b) {\n  if (Object.keys) for (var c = Object.keys(b), d = 0, e = c.length; d < e; d++) {\n    var f = c[d];\n    Object.defineProperty(a, f, Object.getOwnPropertyDescriptor(b, f));\n  } else for (f in c = {}.hasOwnProperty, b) c.call(b, f) && (a[f] = b[f]);\n  return a;\n};\n(function () {\n  for (var a = 0, b = [\"ms\", \"moz\", \"webkit\", \"o\"], c = 0; c < b.length && !window.requestAnimationFrame; ++c) window.requestAnimationFrame = window[b[c] + \"RequestAnimationFrame\"], window.cancelAnimationFrame = window[b[c] + \"CancelAnimationFrame\"] || window[b[c] + \"CancelRequestAnimationFrame\"];\n  void 0 === window.requestAnimationFrame && (window.requestAnimationFrame = function (b) {\n    var c = Date.now(),\n      f = Math.max(0, 16 - (c - a)),\n      g = window.setTimeout(function () {\n        b(c + f);\n      }, f);\n    a = c + f;\n    return g;\n  });\n  window.cancelAnimationFrame = window.cancelAnimationFrame || function (a) {\n    window.clearTimeout(a);\n  };\n})();\nTHREE.CullFaceNone = 0;\nTHREE.CullFaceBack = 1;\nTHREE.CullFaceFront = 2;\nTHREE.CullFaceFrontBack = 3;\nTHREE.FrontFaceDirectionCW = 0;\nTHREE.FrontFaceDirectionCCW = 1;\nTHREE.BasicShadowMap = 0;\nTHREE.PCFShadowMap = 1;\nTHREE.PCFSoftShadowMap = 2;\nTHREE.FrontSide = 0;\nTHREE.BackSide = 1;\nTHREE.DoubleSide = 2;\nTHREE.NoShading = 0;\nTHREE.FlatShading = 1;\nTHREE.SmoothShading = 2;\nTHREE.NoColors = 0;\nTHREE.FaceColors = 1;\nTHREE.VertexColors = 2;\nTHREE.NoBlending = 0;\nTHREE.NormalBlending = 1;\nTHREE.AdditiveBlending = 2;\nTHREE.SubtractiveBlending = 3;\nTHREE.MultiplyBlending = 4;\nTHREE.CustomBlending = 5;\nTHREE.AddEquation = 100;\nTHREE.SubtractEquation = 101;\nTHREE.ReverseSubtractEquation = 102;\nTHREE.ZeroFactor = 200;\nTHREE.OneFactor = 201;\nTHREE.SrcColorFactor = 202;\nTHREE.OneMinusSrcColorFactor = 203;\nTHREE.SrcAlphaFactor = 204;\nTHREE.OneMinusSrcAlphaFactor = 205;\nTHREE.DstAlphaFactor = 206;\nTHREE.OneMinusDstAlphaFactor = 207;\nTHREE.DstColorFactor = 208;\nTHREE.OneMinusDstColorFactor = 209;\nTHREE.SrcAlphaSaturateFactor = 210;\nTHREE.MultiplyOperation = 0;\nTHREE.MixOperation = 1;\nTHREE.AddOperation = 2;\nTHREE.UVMapping = function () {};\nTHREE.CubeReflectionMapping = function () {};\nTHREE.CubeRefractionMapping = function () {};\nTHREE.SphericalReflectionMapping = function () {};\nTHREE.SphericalRefractionMapping = function () {};\nTHREE.RepeatWrapping = 1E3;\nTHREE.ClampToEdgeWrapping = 1001;\nTHREE.MirroredRepeatWrapping = 1002;\nTHREE.NearestFilter = 1003;\nTHREE.NearestMipMapNearestFilter = 1004;\nTHREE.NearestMipMapLinearFilter = 1005;\nTHREE.LinearFilter = 1006;\nTHREE.LinearMipMapNearestFilter = 1007;\nTHREE.LinearMipMapLinearFilter = 1008;\nTHREE.UnsignedByteType = 1009;\nTHREE.ByteType = 1010;\nTHREE.ShortType = 1011;\nTHREE.UnsignedShortType = 1012;\nTHREE.IntType = 1013;\nTHREE.UnsignedIntType = 1014;\nTHREE.FloatType = 1015;\nTHREE.UnsignedShort4444Type = 1016;\nTHREE.UnsignedShort5551Type = 1017;\nTHREE.UnsignedShort565Type = 1018;\nTHREE.AlphaFormat = 1019;\nTHREE.RGBFormat = 1020;\nTHREE.RGBAFormat = 1021;\nTHREE.LuminanceFormat = 1022;\nTHREE.LuminanceAlphaFormat = 1023;\nTHREE.RGB_S3TC_DXT1_Format = 2001;\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\nTHREE.Color = function (a) {\n  void 0 !== a && this.set(a);\n  return this;\n};\nTHREE.extend(THREE.Color.prototype, {\n  r: 1,\n  g: 1,\n  b: 1,\n  set: function set(a) {\n    switch (_typeof(a)) {\n      case \"number\":\n        this.setHex(a);\n        break;\n      case \"string\":\n        this.setStyle(a);\n    }\n  },\n  setHex: function setHex(a) {\n    a = Math.floor(a);\n    this.r = (a >> 16 & 255) / 255;\n    this.g = (a >> 8 & 255) / 255;\n    this.b = (a & 255) / 255;\n    return this;\n  },\n  setRGB: function setRGB(a, b, c) {\n    this.r = a;\n    this.g = b;\n    this.b = c;\n    return this;\n  },\n  setHSV: function setHSV(a, b, c) {\n    console.log(\"DEPRECATED: Color's .setHSV() will be removed. Use .setHSL( h, s, l ) instead.\");\n    return this.setHSL(a, b * c / (1 > (a = (2 - b) * c) ? a : 2 - a), a / 2);\n  },\n  setHSL: function setHSL(a, b, c) {\n    if (0 === b) this.r = this.g = this.b = c;else {\n      var d = function d(a, b, c) {\n          0 > c && (c += 1);\n          1 < c && (c -= 1);\n          return c < 1 / 6 ? a + 6 * (b - a) * c : 0.5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a;\n        },\n        b = 0.5 >= c ? c * (1 + b) : c + b - c * b,\n        c = 2 * c - b;\n      this.r = d(c, b, a + 1 / 3);\n      this.g = d(c, b, a);\n      this.b = d(c, b, a - 1 / 3);\n    }\n    return this;\n  },\n  setStyle: function setStyle(a) {\n    if (/^rgb\\((\\d+),(\\d+),(\\d+)\\)$/i.test(a)) return a = /^rgb\\((\\d+),(\\d+),(\\d+)\\)$/i.exec(a), this.r = Math.min(255, parseInt(a[1], 10)) / 255, this.g = Math.min(255, parseInt(a[2], 10)) / 255, this.b = Math.min(255, parseInt(a[3], 10)) / 255, this;\n    if (/^rgb\\((\\d+)\\%,(\\d+)\\%,(\\d+)\\%\\)$/i.test(a)) return a = /^rgb\\((\\d+)\\%,(\\d+)\\%,(\\d+)\\%\\)$/i.exec(a), this.r = Math.min(100, parseInt(a[1], 10)) / 100, this.g = Math.min(100, parseInt(a[2], 10)) / 100, this.b = Math.min(100, parseInt(a[3], 10)) / 100, this;\n    if (/^\\#([0-9a-f]{6})$/i.test(a)) return a = /^\\#([0-9a-f]{6})$/i.exec(a), this.setHex(parseInt(a[1], 16)), this;\n    if (/^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a)) return a = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a), this.setHex(parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16)), this;\n    if (/^(\\w+)$/i.test(a)) return this.setHex(THREE.ColorKeywords[a]), this;\n  },\n  copy: function copy(a) {\n    this.r = a.r;\n    this.g = a.g;\n    this.b = a.b;\n    return this;\n  },\n  copyGammaToLinear: function copyGammaToLinear(a) {\n    this.r = a.r * a.r;\n    this.g = a.g * a.g;\n    this.b = a.b * a.b;\n    return this;\n  },\n  copyLinearToGamma: function copyLinearToGamma(a) {\n    this.r = Math.sqrt(a.r);\n    this.g = Math.sqrt(a.g);\n    this.b = Math.sqrt(a.b);\n    return this;\n  },\n  convertGammaToLinear: function convertGammaToLinear() {\n    var a = this.r,\n      b = this.g,\n      c = this.b;\n    this.r = a * a;\n    this.g = b * b;\n    this.b = c * c;\n    return this;\n  },\n  convertLinearToGamma: function convertLinearToGamma() {\n    this.r = Math.sqrt(this.r);\n    this.g = Math.sqrt(this.g);\n    this.b = Math.sqrt(this.b);\n    return this;\n  },\n  getHex: function getHex() {\n    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;\n  },\n  getHexString: function getHexString() {\n    return (\"000000\" + this.getHex().toString(16)).slice(-6);\n  },\n  getHSL: function () {\n    var a = {\n      h: 0,\n      s: 0,\n      l: 0\n    };\n    return function () {\n      var b = this.r,\n        c = this.g,\n        d = this.b,\n        e = Math.max(b, c, d),\n        f = Math.min(b, c, d),\n        g,\n        h = (f + e) / 2;\n      if (f === e) f = g = 0;else {\n        var i = e - f,\n          f = 0.5 >= h ? i / (e + f) : i / (2 - e - f);\n        switch (e) {\n          case b:\n            g = (c - d) / i + (c < d ? 6 : 0);\n            break;\n          case c:\n            g = (d - b) / i + 2;\n            break;\n          case d:\n            g = (b - c) / i + 4;\n        }\n        g /= 6;\n      }\n      a.h = g;\n      a.s = f;\n      a.l = h;\n      return a;\n    };\n  }(),\n  getStyle: function getStyle() {\n    return \"rgb(\" + (255 * this.r | 0) + \",\" + (255 * this.g | 0) + \",\" + (255 * this.b | 0) + \")\";\n  },\n  offsetHSL: function offsetHSL(a, b, c) {\n    var d = this.getHSL();\n    d.h += a;\n    d.s += b;\n    d.l += c;\n    this.setHSL(d.h, d.s, d.l);\n    return this;\n  },\n  add: function add(a) {\n    this.r += a.r;\n    this.g += a.g;\n    this.b += a.b;\n    return this;\n  },\n  addColors: function addColors(a, b) {\n    this.r = a.r + b.r;\n    this.g = a.g + b.g;\n    this.b = a.b + b.b;\n    return this;\n  },\n  addScalar: function addScalar(a) {\n    this.r += a;\n    this.g += a;\n    this.b += a;\n    return this;\n  },\n  multiply: function multiply(a) {\n    this.r *= a.r;\n    this.g *= a.g;\n    this.b *= a.b;\n    return this;\n  },\n  multiplyScalar: function multiplyScalar(a) {\n    this.r *= a;\n    this.g *= a;\n    this.b *= a;\n    return this;\n  },\n  lerp: function lerp(a, b) {\n    this.r += (a.r - this.r) * b;\n    this.g += (a.g - this.g) * b;\n    this.b += (a.b - this.b) * b;\n    return this;\n  },\n  clone: function clone() {\n    return new THREE.Color().setRGB(this.r, this.g, this.b);\n  }\n});\nTHREE.ColorKeywords = {\n  aliceblue: 15792383,\n  antiquewhite: 16444375,\n  aqua: 65535,\n  aquamarine: 8388564,\n  azure: 15794175,\n  beige: 16119260,\n  bisque: 16770244,\n  black: 0,\n  blanchedalmond: 16772045,\n  blue: 255,\n  blueviolet: 9055202,\n  brown: 10824234,\n  burlywood: 14596231,\n  cadetblue: 6266528,\n  chartreuse: 8388352,\n  chocolate: 13789470,\n  coral: 16744272,\n  cornflowerblue: 6591981,\n  cornsilk: 16775388,\n  crimson: 14423100,\n  cyan: 65535,\n  darkblue: 139,\n  darkcyan: 35723,\n  darkgoldenrod: 12092939,\n  darkgray: 11119017,\n  darkgreen: 25600,\n  darkgrey: 11119017,\n  darkkhaki: 12433259,\n  darkmagenta: 9109643,\n  darkolivegreen: 5597999,\n  darkorange: 16747520,\n  darkorchid: 10040012,\n  darkred: 9109504,\n  darksalmon: 15308410,\n  darkseagreen: 9419919,\n  darkslateblue: 4734347,\n  darkslategray: 3100495,\n  darkslategrey: 3100495,\n  darkturquoise: 52945,\n  darkviolet: 9699539,\n  deeppink: 16716947,\n  deepskyblue: 49151,\n  dimgray: 6908265,\n  dimgrey: 6908265,\n  dodgerblue: 2003199,\n  firebrick: 11674146,\n  floralwhite: 16775920,\n  forestgreen: 2263842,\n  fuchsia: 16711935,\n  gainsboro: 14474460,\n  ghostwhite: 16316671,\n  gold: 16766720,\n  goldenrod: 14329120,\n  gray: 8421504,\n  green: 32768,\n  greenyellow: 11403055,\n  grey: 8421504,\n  honeydew: 15794160,\n  hotpink: 16738740,\n  indianred: 13458524,\n  indigo: 4915330,\n  ivory: 16777200,\n  khaki: 15787660,\n  lavender: 15132410,\n  lavenderblush: 16773365,\n  lawngreen: 8190976,\n  lemonchiffon: 16775885,\n  lightblue: 11393254,\n  lightcoral: 15761536,\n  lightcyan: 14745599,\n  lightgoldenrodyellow: 16448210,\n  lightgray: 13882323,\n  lightgreen: 9498256,\n  lightgrey: 13882323,\n  lightpink: 16758465,\n  lightsalmon: 16752762,\n  lightseagreen: 2142890,\n  lightskyblue: 8900346,\n  lightslategray: 7833753,\n  lightslategrey: 7833753,\n  lightsteelblue: 11584734,\n  lightyellow: 16777184,\n  lime: 65280,\n  limegreen: 3329330,\n  linen: 16445670,\n  magenta: 16711935,\n  maroon: 8388608,\n  mediumaquamarine: 6737322,\n  mediumblue: 205,\n  mediumorchid: 12211667,\n  mediumpurple: 9662683,\n  mediumseagreen: 3978097,\n  mediumslateblue: 8087790,\n  mediumspringgreen: 64154,\n  mediumturquoise: 4772300,\n  mediumvioletred: 13047173,\n  midnightblue: 1644912,\n  mintcream: 16121850,\n  mistyrose: 16770273,\n  moccasin: 16770229,\n  navajowhite: 16768685,\n  navy: 128,\n  oldlace: 16643558,\n  olive: 8421376,\n  olivedrab: 7048739,\n  orange: 16753920,\n  orangered: 16729344,\n  orchid: 14315734,\n  palegoldenrod: 15657130,\n  palegreen: 10025880,\n  paleturquoise: 11529966,\n  palevioletred: 14381203,\n  papayawhip: 16773077,\n  peachpuff: 16767673,\n  peru: 13468991,\n  pink: 16761035,\n  plum: 14524637,\n  powderblue: 11591910,\n  purple: 8388736,\n  red: 16711680,\n  rosybrown: 12357519,\n  royalblue: 4286945,\n  saddlebrown: 9127187,\n  salmon: 16416882,\n  sandybrown: 16032864,\n  seagreen: 3050327,\n  seashell: 16774638,\n  sienna: 10506797,\n  silver: 12632256,\n  skyblue: 8900331,\n  slateblue: 6970061,\n  slategray: 7372944,\n  slategrey: 7372944,\n  snow: 16775930,\n  springgreen: 65407,\n  steelblue: 4620980,\n  tan: 13808780,\n  teal: 32896,\n  thistle: 14204888,\n  tomato: 16737095,\n  turquoise: 4251856,\n  violet: 15631086,\n  wheat: 16113331,\n  white: 16777215,\n  whitesmoke: 16119285,\n  yellow: 16776960,\n  yellowgreen: 10145074\n};\nTHREE.Quaternion = function (a, b, c, d) {\n  this.x = a || 0;\n  this.y = b || 0;\n  this.z = c || 0;\n  this.w = void 0 !== d ? d : 1;\n};\nTHREE.extend(THREE.Quaternion.prototype, {\n  set: function set(a, b, c, d) {\n    this.x = a;\n    this.y = b;\n    this.z = c;\n    this.w = d;\n    return this;\n  },\n  copy: function copy(a) {\n    this.x = a.x;\n    this.y = a.y;\n    this.z = a.z;\n    this.w = a.w;\n    return this;\n  },\n  setFromEuler: function setFromEuler(a, b) {\n    var c = Math.cos(a.x / 2),\n      d = Math.cos(a.y / 2),\n      e = Math.cos(a.z / 2),\n      f = Math.sin(a.x / 2),\n      g = Math.sin(a.y / 2),\n      h = Math.sin(a.z / 2);\n    void 0 === b || \"XYZ\" === b ? (this.x = f * d * e + c * g * h, this.y = c * g * e - f * d * h, this.z = c * d * h + f * g * e, this.w = c * d * e - f * g * h) : \"YXZ\" === b ? (this.x = f * d * e + c * g * h, this.y = c * g * e - f * d * h, this.z = c * d * h - f * g * e, this.w = c * d * e + f * g * h) : \"ZXY\" === b ? (this.x = f * d * e - c * g * h, this.y = c * g * e + f * d * h, this.z = c * d * h + f * g * e, this.w = c * d * e - f * g * h) : \"ZYX\" === b ? (this.x = f * d * e - c * g * h, this.y = c * g * e + f * d * h, this.z = c * d * h - f * g * e, this.w = c * d * e + f * g * h) : \"YZX\" === b ? (this.x = f * d * e + c * g * h, this.y = c * g * e + f * d * h, this.z = c * d * h - f * g * e, this.w = c * d * e - f * g * h) : \"XZY\" === b && (this.x = f * d * e - c * g * h, this.y = c * g * e - f * d * h, this.z = c * d * h + f * g * e, this.w = c * d * e + f * g * h);\n    return this;\n  },\n  setFromAxisAngle: function setFromAxisAngle(a, b) {\n    var c = b / 2,\n      d = Math.sin(c);\n    this.x = a.x * d;\n    this.y = a.y * d;\n    this.z = a.z * d;\n    this.w = Math.cos(c);\n    return this;\n  },\n  setFromRotationMatrix: function setFromRotationMatrix(a) {\n    var b = a.elements,\n      c = b[0],\n      a = b[4],\n      d = b[8],\n      e = b[1],\n      f = b[5],\n      g = b[9],\n      h = b[2],\n      i = b[6],\n      b = b[10],\n      k = c + f + b;\n    0 < k ? (c = 0.5 / Math.sqrt(k + 1), this.w = 0.25 / c, this.x = (i - g) * c, this.y = (d - h) * c, this.z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this.w = (i - g) / c, this.x = 0.25 * c, this.y = (a + e) / c, this.z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this.w = (d - h) / c, this.x = (a + e) / c, this.y = 0.25 * c, this.z = (g + i) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this.w = (e - a) / c, this.x = (d + h) / c, this.y = (g + i) / c, this.z = 0.25 * c);\n    return this;\n  },\n  inverse: function inverse() {\n    this.conjugate().normalize();\n    return this;\n  },\n  conjugate: function conjugate() {\n    this.x *= -1;\n    this.y *= -1;\n    this.z *= -1;\n    return this;\n  },\n  lengthSq: function lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  },\n  length: function length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  },\n  normalize: function normalize() {\n    var a = this.length();\n    0 === a ? (this.z = this.y = this.x = 0, this.w = 1) : (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a);\n    return this;\n  },\n  multiply: function multiply(a, b) {\n    return void 0 !== b ? (console.warn(\"DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.\"), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a);\n  },\n  multiplyQuaternions: function multiplyQuaternions(a, b) {\n    var c = a.x,\n      d = a.y,\n      e = a.z,\n      f = a.w,\n      g = b.x,\n      h = b.y,\n      i = b.z,\n      k = b.w;\n    this.x = c * k + f * g + d * i - e * h;\n    this.y = d * k + f * h + e * g - c * i;\n    this.z = e * k + f * i + c * h - d * g;\n    this.w = f * k - c * g - d * h - e * i;\n    return this;\n  },\n  multiplyVector3: function multiplyVector3(a) {\n    console.warn(\"DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.\");\n    return a.applyQuaternion(this);\n  },\n  slerp: function slerp(a, b) {\n    var c = this.x,\n      d = this.y,\n      e = this.z,\n      f = this.w,\n      g = f * a.w + c * a.x + d * a.y + e * a.z;\n    0 > g ? (this.w = -a.w, this.x = -a.x, this.y = -a.y, this.z = -a.z, g = -g) : this.copy(a);\n    if (1 <= g) return this.w = f, this.x = c, this.y = d, this.z = e, this;\n    var h = Math.acos(g),\n      i = Math.sqrt(1 - g * g);\n    if (0.001 > Math.abs(i)) return this.w = 0.5 * (f + this.w), this.x = 0.5 * (c + this.x), this.y = 0.5 * (d + this.y), this.z = 0.5 * (e + this.z), this;\n    g = Math.sin((1 - b) * h) / i;\n    h = Math.sin(b * h) / i;\n    this.w = f * g + this.w * h;\n    this.x = c * g + this.x * h;\n    this.y = d * g + this.y * h;\n    this.z = e * g + this.z * h;\n    return this;\n  },\n  equals: function equals(a) {\n    return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;\n  },\n  clone: function clone() {\n    return new THREE.Quaternion(this.x, this.y, this.z, this.w);\n  }\n});\nTHREE.Quaternion.slerp = function (a, b, c, d) {\n  return c.copy(a).slerp(b, d);\n};\nTHREE.Vector2 = function (a, b) {\n  this.x = a || 0;\n  this.y = b || 0;\n};\nTHREE.extend(THREE.Vector2.prototype, {\n  set: function set(a, b) {\n    this.x = a;\n    this.y = b;\n    return this;\n  },\n  setX: function setX(a) {\n    this.x = a;\n    return this;\n  },\n  setY: function setY(a) {\n    this.y = a;\n    return this;\n  },\n  setComponent: function setComponent(a, b) {\n    switch (a) {\n      case 0:\n        this.x = b;\n        break;\n      case 1:\n        this.y = b;\n        break;\n      default:\n        throw Error(\"index is out of range: \" + a);\n    }\n  },\n  getComponent: function getComponent(a) {\n    switch (a) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      default:\n        throw Error(\"index is out of range: \" + a);\n    }\n  },\n  copy: function copy(a) {\n    this.x = a.x;\n    this.y = a.y;\n    return this;\n  },\n  add: function add(a, b) {\n    if (void 0 !== b) return console.warn(\"DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"), this.addVectors(a, b);\n    this.x += a.x;\n    this.y += a.y;\n    return this;\n  },\n  addVectors: function addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    return this;\n  },\n  addScalar: function addScalar(a) {\n    this.x += a;\n    this.y += a;\n    return this;\n  },\n  sub: function sub(a, b) {\n    if (void 0 !== b) return console.warn(\"DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"), this.subVectors(a, b);\n    this.x -= a.x;\n    this.y -= a.y;\n    return this;\n  },\n  subVectors: function subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    return this;\n  },\n  multiplyScalar: function multiplyScalar(a) {\n    this.x *= a;\n    this.y *= a;\n    return this;\n  },\n  divideScalar: function divideScalar(a) {\n    0 !== a ? (this.x /= a, this.y /= a) : this.set(0, 0);\n    return this;\n  },\n  min: function min(a) {\n    this.x > a.x && (this.x = a.x);\n    this.y > a.y && (this.y = a.y);\n    return this;\n  },\n  max: function max(a) {\n    this.x < a.x && (this.x = a.x);\n    this.y < a.y && (this.y = a.y);\n    return this;\n  },\n  clamp: function clamp(a, b) {\n    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);\n    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);\n    return this;\n  },\n  negate: function negate() {\n    return this.multiplyScalar(-1);\n  },\n  dot: function dot(a) {\n    return this.x * a.x + this.y * a.y;\n  },\n  lengthSq: function lengthSq() {\n    return this.x * this.x + this.y * this.y;\n  },\n  length: function length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  },\n  normalize: function normalize() {\n    return this.divideScalar(this.length());\n  },\n  distanceTo: function distanceTo(a) {\n    return Math.sqrt(this.distanceToSquared(a));\n  },\n  distanceToSquared: function distanceToSquared(a) {\n    var b = this.x - a.x,\n      a = this.y - a.y;\n    return b * b + a * a;\n  },\n  setLength: function setLength(a) {\n    var b = this.length();\n    0 !== b && a !== b && this.multiplyScalar(a / b);\n    return this;\n  },\n  lerp: function lerp(a, b) {\n    this.x += (a.x - this.x) * b;\n    this.y += (a.y - this.y) * b;\n    return this;\n  },\n  equals: function equals(a) {\n    return a.x === this.x && a.y === this.y;\n  },\n  toArray: function toArray() {\n    return [this.x, this.y];\n  },\n  clone: function clone() {\n    return new THREE.Vector2(this.x, this.y);\n  }\n});\nTHREE.Vector3 = function (a, b, c) {\n  this.x = a || 0;\n  this.y = b || 0;\n  this.z = c || 0;\n};\nTHREE.extend(THREE.Vector3.prototype, {\n  set: function set(a, b, c) {\n    this.x = a;\n    this.y = b;\n    this.z = c;\n    return this;\n  },\n  setX: function setX(a) {\n    this.x = a;\n    return this;\n  },\n  setY: function setY(a) {\n    this.y = a;\n    return this;\n  },\n  setZ: function setZ(a) {\n    this.z = a;\n    return this;\n  },\n  setComponent: function setComponent(a, b) {\n    switch (a) {\n      case 0:\n        this.x = b;\n        break;\n      case 1:\n        this.y = b;\n        break;\n      case 2:\n        this.z = b;\n        break;\n      default:\n        throw Error(\"index is out of range: \" + a);\n    }\n  },\n  getComponent: function getComponent(a) {\n    switch (a) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      case 2:\n        return this.z;\n      default:\n        throw Error(\"index is out of range: \" + a);\n    }\n  },\n  copy: function copy(a) {\n    this.x = a.x;\n    this.y = a.y;\n    this.z = a.z;\n    return this;\n  },\n  add: function add(a, b) {\n    if (void 0 !== b) return console.warn(\"DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"), this.addVectors(a, b);\n    this.x += a.x;\n    this.y += a.y;\n    this.z += a.z;\n    return this;\n  },\n  addScalar: function addScalar(a) {\n    this.x += a;\n    this.y += a;\n    this.z += a;\n    return this;\n  },\n  addVectors: function addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    return this;\n  },\n  sub: function sub(a, b) {\n    if (void 0 !== b) return console.warn(\"DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"), this.subVectors(a, b);\n    this.x -= a.x;\n    this.y -= a.y;\n    this.z -= a.z;\n    return this;\n  },\n  subVectors: function subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    return this;\n  },\n  multiply: function multiply(a, b) {\n    if (void 0 !== b) return console.warn(\"DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.\"), this.multiplyVectors(a, b);\n    this.x *= a.x;\n    this.y *= a.y;\n    this.z *= a.z;\n    return this;\n  },\n  multiplyScalar: function multiplyScalar(a) {\n    this.x *= a;\n    this.y *= a;\n    this.z *= a;\n    return this;\n  },\n  multiplyVectors: function multiplyVectors(a, b) {\n    this.x = a.x * b.x;\n    this.y = a.y * b.y;\n    this.z = a.z * b.z;\n    return this;\n  },\n  applyMatrix3: function applyMatrix3(a) {\n    var b = this.x,\n      c = this.y,\n      d = this.z,\n      a = a.elements;\n    this.x = a[0] * b + a[3] * c + a[6] * d;\n    this.y = a[1] * b + a[4] * c + a[7] * d;\n    this.z = a[2] * b + a[5] * c + a[8] * d;\n    return this;\n  },\n  applyMatrix4: function applyMatrix4(a) {\n    var b = this.x,\n      c = this.y,\n      d = this.z,\n      a = a.elements;\n    this.x = a[0] * b + a[4] * c + a[8] * d + a[12];\n    this.y = a[1] * b + a[5] * c + a[9] * d + a[13];\n    this.z = a[2] * b + a[6] * c + a[10] * d + a[14];\n    return this;\n  },\n  applyProjection: function applyProjection(a) {\n    var b = this.x,\n      c = this.y,\n      d = this.z,\n      a = a.elements,\n      e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);\n    this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;\n    this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;\n    this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;\n    return this;\n  },\n  applyQuaternion: function applyQuaternion(a) {\n    var b = this.x,\n      c = this.y,\n      d = this.z,\n      e = a.x,\n      f = a.y,\n      g = a.z,\n      a = a.w,\n      h = a * b + f * d - g * c,\n      i = a * c + g * b - e * d,\n      k = a * d + e * c - f * b,\n      b = -e * b - f * c - g * d;\n    this.x = h * a + b * -e + i * -g - k * -f;\n    this.y = i * a + b * -f + k * -e - h * -g;\n    this.z = k * a + b * -g + h * -f - i * -e;\n    return this;\n  },\n  applyEuler: function () {\n    var a = new THREE.Quaternion();\n    return function (b, c) {\n      var d = a.setFromEuler(b, c);\n      this.applyQuaternion(d);\n      return this;\n    };\n  }(),\n  applyAxisAngle: function () {\n    var a = new THREE.Quaternion();\n    return function (b, c) {\n      var d = a.setFromAxisAngle(b, c);\n      this.applyQuaternion(d);\n      return this;\n    };\n  }(),\n  transformDirection: function transformDirection(a) {\n    var b = this.x,\n      c = this.y,\n      d = this.z,\n      a = a.elements;\n    this.x = a[0] * b + a[4] * c + a[8] * d;\n    this.y = a[1] * b + a[5] * c + a[9] * d;\n    this.z = a[2] * b + a[6] * c + a[10] * d;\n    this.normalize();\n    return this;\n  },\n  divide: function divide(a) {\n    this.x /= a.x;\n    this.y /= a.y;\n    this.z /= a.z;\n    return this;\n  },\n  divideScalar: function divideScalar(a) {\n    0 !== a ? (this.x /= a, this.y /= a, this.z /= a) : this.z = this.y = this.x = 0;\n    return this;\n  },\n  min: function min(a) {\n    this.x > a.x && (this.x = a.x);\n    this.y > a.y && (this.y = a.y);\n    this.z > a.z && (this.z = a.z);\n    return this;\n  },\n  max: function max(a) {\n    this.x < a.x && (this.x = a.x);\n    this.y < a.y && (this.y = a.y);\n    this.z < a.z && (this.z = a.z);\n    return this;\n  },\n  clamp: function clamp(a, b) {\n    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);\n    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);\n    this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);\n    return this;\n  },\n  negate: function negate() {\n    return this.multiplyScalar(-1);\n  },\n  dot: function dot(a) {\n    return this.x * a.x + this.y * a.y + this.z * a.z;\n  },\n  lengthSq: function lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  },\n  length: function length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  },\n  lengthManhattan: function lengthManhattan() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n  },\n  normalize: function normalize() {\n    return this.divideScalar(this.length());\n  },\n  setLength: function setLength(a) {\n    var b = this.length();\n    0 !== b && a !== b && this.multiplyScalar(a / b);\n    return this;\n  },\n  lerp: function lerp(a, b) {\n    this.x += (a.x - this.x) * b;\n    this.y += (a.y - this.y) * b;\n    this.z += (a.z - this.z) * b;\n    return this;\n  },\n  cross: function cross(a, b) {\n    if (void 0 !== b) return console.warn(\"DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.\"), this.crossVectors(a, b);\n    var c = this.x,\n      d = this.y,\n      e = this.z;\n    this.x = d * a.z - e * a.y;\n    this.y = e * a.x - c * a.z;\n    this.z = c * a.y - d * a.x;\n    return this;\n  },\n  crossVectors: function crossVectors(a, b) {\n    this.x = a.y * b.z - a.z * b.y;\n    this.y = a.z * b.x - a.x * b.z;\n    this.z = a.x * b.y - a.y * b.x;\n    return this;\n  },\n  projectOnVector: function () {\n    var a = new THREE.Vector3();\n    return function (b) {\n      a.copy(b).normalize();\n      b = this.dot(a);\n      return this.copy(a).multiplyScalar(b);\n    };\n  }(),\n  projectOnPlane: function () {\n    var a = new THREE.Vector3();\n    return function (b) {\n      a.copy(this).projectOnVector(b);\n      return this.sub(a);\n    };\n  }(),\n  reflect: function () {\n    var a = new THREE.Vector3();\n    return function (b) {\n      a.copy(this).projectOnVector(b).multiplyScalar(2);\n      return this.subVectors(a, this);\n    };\n  }(),\n  angleTo: function angleTo(a) {\n    a = this.dot(a) / (this.length() * a.length());\n    return Math.acos(THREE.Math.clamp(a, -1, 1));\n  },\n  distanceTo: function distanceTo(a) {\n    return Math.sqrt(this.distanceToSquared(a));\n  },\n  distanceToSquared: function distanceToSquared(a) {\n    var b = this.x - a.x,\n      c = this.y - a.y,\n      a = this.z - a.z;\n    return b * b + c * c + a * a;\n  },\n  getPositionFromMatrix: function getPositionFromMatrix(a) {\n    this.x = a.elements[12];\n    this.y = a.elements[13];\n    this.z = a.elements[14];\n    return this;\n  },\n  setEulerFromRotationMatrix: function setEulerFromRotationMatrix(a, b) {\n    function c(a) {\n      return Math.min(Math.max(a, -1), 1);\n    }\n    var d = a.elements,\n      e = d[0],\n      f = d[4],\n      g = d[8],\n      h = d[1],\n      i = d[5],\n      k = d[9],\n      l = d[2],\n      m = d[6],\n      d = d[10];\n    void 0 === b || \"XYZ\" === b ? (this.y = Math.asin(c(g)), 0.99999 > Math.abs(g) ? (this.x = Math.atan2(-k, d), this.z = Math.atan2(-f, e)) : (this.x = Math.atan2(m, i), this.z = 0)) : \"YXZ\" === b ? (this.x = Math.asin(-c(k)), 0.99999 > Math.abs(k) ? (this.y = Math.atan2(g, d), this.z = Math.atan2(h, i)) : (this.y = Math.atan2(-l, e), this.z = 0)) : \"ZXY\" === b ? (this.x = Math.asin(c(m)), 0.99999 > Math.abs(m) ? (this.y = Math.atan2(-l, d), this.z = Math.atan2(-f, i)) : (this.y = 0, this.z = Math.atan2(h, e))) : \"ZYX\" === b ? (this.y = Math.asin(-c(l)), 0.99999 > Math.abs(l) ? (this.x = Math.atan2(m, d), this.z = Math.atan2(h, e)) : (this.x = 0, this.z = Math.atan2(-f, i))) : \"YZX\" === b ? (this.z = Math.asin(c(h)), 0.99999 > Math.abs(h) ? (this.x = Math.atan2(-k, i), this.y = Math.atan2(-l, e)) : (this.x = 0, this.y = Math.atan2(g, d))) : \"XZY\" === b && (this.z = Math.asin(-c(f)), 0.99999 > Math.abs(f) ? (this.x = Math.atan2(m, i), this.y = Math.atan2(g, e)) : (this.x = Math.atan2(-k, d), this.y = 0));\n    return this;\n  },\n  setEulerFromQuaternion: function setEulerFromQuaternion(a, b) {\n    function c(a) {\n      return Math.min(Math.max(a, -1), 1);\n    }\n    var d = a.x * a.x,\n      e = a.y * a.y,\n      f = a.z * a.z,\n      g = a.w * a.w;\n    void 0 === b || \"XYZ\" === b ? (this.x = Math.atan2(2 * (a.x * a.w - a.y * a.z), g - d - e + f), this.y = Math.asin(c(2 * (a.x * a.z + a.y * a.w))), this.z = Math.atan2(2 * (a.z * a.w - a.x * a.y), g + d - e - f)) : \"YXZ\" === b ? (this.x = Math.asin(c(2 * (a.x * a.w - a.y * a.z))), this.y = Math.atan2(2 * (a.x * a.z + a.y * a.w), g - d - e + f), this.z = Math.atan2(2 * (a.x * a.y + a.z * a.w), g - d + e - f)) : \"ZXY\" === b ? (this.x = Math.asin(c(2 * (a.x * a.w + a.y * a.z))), this.y = Math.atan2(2 * (a.y * a.w - a.z * a.x), g - d - e + f), this.z = Math.atan2(2 * (a.z * a.w - a.x * a.y), g - d + e - f)) : \"ZYX\" === b ? (this.x = Math.atan2(2 * (a.x * a.w + a.z * a.y), g - d - e + f), this.y = Math.asin(c(2 * (a.y * a.w - a.x * a.z))), this.z = Math.atan2(2 * (a.x * a.y + a.z * a.w), g + d - e - f)) : \"YZX\" === b ? (this.x = Math.atan2(2 * (a.x * a.w - a.z * a.y), g - d + e - f), this.y = Math.atan2(2 * (a.y * a.w - a.x * a.z), g + d - e - f), this.z = Math.asin(c(2 * (a.x * a.y + a.z * a.w)))) : \"XZY\" === b && (this.x = Math.atan2(2 * (a.x * a.w + a.y * a.z), g - d + e - f), this.y = Math.atan2(2 * (a.x * a.z + a.y * a.w), g + d - e - f), this.z = Math.asin(c(2 * (a.z * a.w - a.x * a.y))));\n    return this;\n  },\n  getScaleFromMatrix: function getScaleFromMatrix(a) {\n    var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(),\n      c = this.set(a.elements[4], a.elements[5], a.elements[6]).length(),\n      a = this.set(a.elements[8], a.elements[9], a.elements[10]).length();\n    this.x = b;\n    this.y = c;\n    this.z = a;\n    return this;\n  },\n  equals: function equals(a) {\n    return a.x === this.x && a.y === this.y && a.z === this.z;\n  },\n  toArray: function toArray() {\n    return [this.x, this.y, this.z];\n  },\n  clone: function clone() {\n    return new THREE.Vector3(this.x, this.y, this.z);\n  }\n});\nTHREE.Vector4 = function (a, b, c, d) {\n  this.x = a || 0;\n  this.y = b || 0;\n  this.z = c || 0;\n  this.w = void 0 !== d ? d : 1;\n};\nTHREE.extend(THREE.Vector4.prototype, {\n  set: function set(a, b, c, d) {\n    this.x = a;\n    this.y = b;\n    this.z = c;\n    this.w = d;\n    return this;\n  },\n  setX: function setX(a) {\n    this.x = a;\n    return this;\n  },\n  setY: function setY(a) {\n    this.y = a;\n    return this;\n  },\n  setZ: function setZ(a) {\n    this.z = a;\n    return this;\n  },\n  setW: function setW(a) {\n    this.w = a;\n    return this;\n  },\n  setComponent: function setComponent(a, b) {\n    switch (a) {\n      case 0:\n        this.x = b;\n        break;\n      case 1:\n        this.y = b;\n        break;\n      case 2:\n        this.z = b;\n        break;\n      case 3:\n        this.w = b;\n        break;\n      default:\n        throw Error(\"index is out of range: \" + a);\n    }\n  },\n  getComponent: function getComponent(a) {\n    switch (a) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      case 2:\n        return this.z;\n      case 3:\n        return this.w;\n      default:\n        throw Error(\"index is out of range: \" + a);\n    }\n  },\n  copy: function copy(a) {\n    this.x = a.x;\n    this.y = a.y;\n    this.z = a.z;\n    this.w = void 0 !== a.w ? a.w : 1;\n    return this;\n  },\n  add: function add(a, b) {\n    if (void 0 !== b) return console.warn(\"DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"), this.addVectors(a, b);\n    this.x += a.x;\n    this.y += a.y;\n    this.z += a.z;\n    this.w += a.w;\n    return this;\n  },\n  addScalar: function addScalar(a) {\n    this.x += a;\n    this.y += a;\n    this.z += a;\n    this.w += a;\n    return this;\n  },\n  addVectors: function addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    this.w = a.w + b.w;\n    return this;\n  },\n  sub: function sub(a, b) {\n    if (void 0 !== b) return console.warn(\"DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"), this.subVectors(a, b);\n    this.x -= a.x;\n    this.y -= a.y;\n    this.z -= a.z;\n    this.w -= a.w;\n    return this;\n  },\n  subVectors: function subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    this.w = a.w - b.w;\n    return this;\n  },\n  multiplyScalar: function multiplyScalar(a) {\n    this.x *= a;\n    this.y *= a;\n    this.z *= a;\n    this.w *= a;\n    return this;\n  },\n  applyMatrix4: function applyMatrix4(a) {\n    var b = this.x,\n      c = this.y,\n      d = this.z,\n      e = this.w,\n      a = a.elements;\n    this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;\n    this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;\n    this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;\n    this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;\n    return this;\n  },\n  divideScalar: function divideScalar(a) {\n    0 !== a ? (this.x /= a, this.y /= a, this.z /= a, this.w /= a) : (this.z = this.y = this.x = 0, this.w = 1);\n    return this;\n  },\n  setAxisAngleFromQuaternion: function setAxisAngleFromQuaternion(a) {\n    this.w = 2 * Math.acos(a.w);\n    var b = Math.sqrt(1 - a.w * a.w);\n    1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);\n    return this;\n  },\n  setAxisAngleFromRotationMatrix: function setAxisAngleFromRotationMatrix(a) {\n    var b,\n      c,\n      d,\n      a = a.elements,\n      e = a[0];\n    d = a[4];\n    var f = a[8],\n      g = a[1],\n      h = a[5],\n      i = a[9];\n    c = a[2];\n    b = a[6];\n    var k = a[10];\n    if (0.01 > Math.abs(d - g) && 0.01 > Math.abs(f - c) && 0.01 > Math.abs(i - b)) {\n      if (0.1 > Math.abs(d + g) && 0.1 > Math.abs(f + c) && 0.1 > Math.abs(i + b) && 0.1 > Math.abs(e + h + k - 3)) return this.set(1, 0, 0, 0), this;\n      a = Math.PI;\n      e = (e + 1) / 2;\n      h = (h + 1) / 2;\n      k = (k + 1) / 2;\n      d = (d + g) / 4;\n      f = (f + c) / 4;\n      i = (i + b) / 4;\n      e > h && e > k ? 0.01 > e ? (b = 0, d = c = 0.707106781) : (b = Math.sqrt(e), c = d / b, d = f / b) : h > k ? 0.01 > h ? (b = 0.707106781, c = 0, d = 0.707106781) : (c = Math.sqrt(h), b = d / c, d = i / c) : 0.01 > k ? (c = b = 0.707106781, d = 0) : (d = Math.sqrt(k), b = f / d, c = i / d);\n      this.set(b, c, d, a);\n      return this;\n    }\n    a = Math.sqrt((b - i) * (b - i) + (f - c) * (f - c) + (g - d) * (g - d));\n    0.001 > Math.abs(a) && (a = 1);\n    this.x = (b - i) / a;\n    this.y = (f - c) / a;\n    this.z = (g - d) / a;\n    this.w = Math.acos((e + h + k - 1) / 2);\n    return this;\n  },\n  min: function min(a) {\n    this.x > a.x && (this.x = a.x);\n    this.y > a.y && (this.y = a.y);\n    this.z > a.z && (this.z = a.z);\n    this.w > a.w && (this.w = a.w);\n    return this;\n  },\n  max: function max(a) {\n    this.x < a.x && (this.x = a.x);\n    this.y < a.y && (this.y = a.y);\n    this.z < a.z && (this.z = a.z);\n    this.w < a.w && (this.w = a.w);\n    return this;\n  },\n  clamp: function clamp(a, b) {\n    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);\n    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);\n    this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);\n    this.w < a.w ? this.w = a.w : this.w > b.w && (this.w = b.w);\n    return this;\n  },\n  negate: function negate() {\n    return this.multiplyScalar(-1);\n  },\n  dot: function dot(a) {\n    return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;\n  },\n  lengthSq: function lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  },\n  length: function length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  },\n  lengthManhattan: function lengthManhattan() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n  },\n  normalize: function normalize() {\n    return this.divideScalar(this.length());\n  },\n  setLength: function setLength(a) {\n    var b = this.length();\n    0 !== b && a !== b && this.multiplyScalar(a / b);\n    return this;\n  },\n  lerp: function lerp(a, b) {\n    this.x += (a.x - this.x) * b;\n    this.y += (a.y - this.y) * b;\n    this.z += (a.z - this.z) * b;\n    this.w += (a.w - this.w) * b;\n    return this;\n  },\n  equals: function equals(a) {\n    return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;\n  },\n  toArray: function toArray() {\n    return [this.x, this.y, this.z, this.w];\n  },\n  clone: function clone() {\n    return new THREE.Vector4(this.x, this.y, this.z, this.w);\n  }\n});\nTHREE.Line3 = function (a, b) {\n  this.start = void 0 !== a ? a : new THREE.Vector3();\n  this.end = void 0 !== b ? b : new THREE.Vector3();\n};\nTHREE.extend(THREE.Line3.prototype, {\n  set: function set(a, b) {\n    this.start.copy(a);\n    this.end.copy(b);\n    return this;\n  },\n  copy: function copy(a) {\n    this.start.copy(a.start);\n    this.end.copy(a.end);\n    return this;\n  },\n  center: function center(a) {\n    return (a || new THREE.Vector3()).addVectors(this.start, this.end).multiplyScalar(0.5);\n  },\n  delta: function delta(a) {\n    return (a || new THREE.Vector3()).subVectors(this.end, this.start);\n  },\n  distanceSq: function distanceSq() {\n    return this.start.distanceToSquared(this.end);\n  },\n  distance: function distance() {\n    return this.start.distanceTo(this.end);\n  },\n  at: function at(a, b) {\n    var c = b || new THREE.Vector3();\n    return this.delta(c).multiplyScalar(a).add(this.start);\n  },\n  closestPointToPointParameter: function () {\n    var a = new THREE.Vector3(),\n      b = new THREE.Vector3();\n    return function (c, d) {\n      a.subVectors(c, this.start);\n      b.subVectors(this.end, this.start);\n      var e = b.dot(b),\n        e = b.dot(a) / e;\n      d && (e = THREE.Math.clamp(e, 0, 1));\n      return e;\n    };\n  }(),\n  closestPointToPoint: function closestPointToPoint(a, b, c) {\n    a = this.closestPointToPointParameter(a, b);\n    c = c || new THREE.Vector3();\n    return this.delta(c).multiplyScalar(a).add(this.start);\n  },\n  applyMatrix4: function applyMatrix4(a) {\n    this.start.applyMatrix4(a);\n    this.end.applyMatrix4(a);\n    return this;\n  },\n  equals: function equals(a) {\n    return a.start.equals(this.start) && a.end.equals(this.end);\n  },\n  clone: function clone() {\n    return new THREE.Line3().copy(this);\n  }\n});\nTHREE.Box2 = function (a, b) {\n  this.min = void 0 !== a ? a : new THREE.Vector2(Infinity, Infinity);\n  this.max = void 0 !== b ? b : new THREE.Vector2(-Infinity, -Infinity);\n};\nTHREE.extend(THREE.Box2.prototype, {\n  set: function set(a, b) {\n    this.min.copy(a);\n    this.max.copy(b);\n    return this;\n  },\n  setFromPoints: function setFromPoints(a) {\n    if (0 < a.length) {\n      var b = a[0];\n      this.min.copy(b);\n      this.max.copy(b);\n      for (var c = 1, d = a.length; c < d; c++) b = a[c], b.x < this.min.x ? this.min.x = b.x : b.x > this.max.x && (this.max.x = b.x), b.y < this.min.y ? this.min.y = b.y : b.y > this.max.y && (this.max.y = b.y);\n    } else this.makeEmpty();\n    return this;\n  },\n  setFromCenterAndSize: function () {\n    var a = new THREE.Vector2();\n    return function (b, c) {\n      var d = a.copy(c).multiplyScalar(0.5);\n      this.min.copy(b).sub(d);\n      this.max.copy(b).add(d);\n      return this;\n    };\n  }(),\n  copy: function copy(a) {\n    this.min.copy(a.min);\n    this.max.copy(a.max);\n    return this;\n  },\n  makeEmpty: function makeEmpty() {\n    this.min.x = this.min.y = Infinity;\n    this.max.x = this.max.y = -Infinity;\n    return this;\n  },\n  empty: function empty() {\n    return this.max.x < this.min.x || this.max.y < this.min.y;\n  },\n  center: function center(a) {\n    return (a || new THREE.Vector2()).addVectors(this.min, this.max).multiplyScalar(0.5);\n  },\n  size: function size(a) {\n    return (a || new THREE.Vector2()).subVectors(this.max, this.min);\n  },\n  expandByPoint: function expandByPoint(a) {\n    this.min.min(a);\n    this.max.max(a);\n    return this;\n  },\n  expandByVector: function expandByVector(a) {\n    this.min.sub(a);\n    this.max.add(a);\n    return this;\n  },\n  expandByScalar: function expandByScalar(a) {\n    this.min.addScalar(-a);\n    this.max.addScalar(a);\n    return this;\n  },\n  containsPoint: function containsPoint(a) {\n    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0;\n  },\n  containsBox: function containsBox(a) {\n    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1;\n  },\n  getParameter: function getParameter(a) {\n    return new THREE.Vector2((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y));\n  },\n  isIntersectionBox: function isIntersectionBox(a) {\n    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0;\n  },\n  clampPoint: function clampPoint(a, b) {\n    return (b || new THREE.Vector2()).copy(a).clamp(this.min, this.max);\n  },\n  distanceToPoint: function () {\n    var a = new THREE.Vector2();\n    return function (b) {\n      return a.copy(b).clamp(this.min, this.max).sub(b).length();\n    };\n  }(),\n  intersect: function intersect(a) {\n    this.min.max(a.min);\n    this.max.min(a.max);\n    return this;\n  },\n  union: function union(a) {\n    this.min.min(a.min);\n    this.max.max(a.max);\n    return this;\n  },\n  translate: function translate(a) {\n    this.min.add(a);\n    this.max.add(a);\n    return this;\n  },\n  equals: function equals(a) {\n    return a.min.equals(this.min) && a.max.equals(this.max);\n  },\n  clone: function clone() {\n    return new THREE.Box2().copy(this);\n  }\n});\nTHREE.Box3 = function (a, b) {\n  this.min = void 0 !== a ? a : new THREE.Vector3(Infinity, Infinity, Infinity);\n  this.max = void 0 !== b ? b : new THREE.Vector3(-Infinity, -Infinity, -Infinity);\n};\nTHREE.extend(THREE.Box3.prototype, {\n  set: function set(a, b) {\n    this.min.copy(a);\n    this.max.copy(b);\n    return this;\n  },\n  setFromPoints: function setFromPoints(a) {\n    if (0 < a.length) {\n      var b = a[0];\n      this.min.copy(b);\n      this.max.copy(b);\n      for (var c = 1, d = a.length; c < d; c++) b = a[c], b.x < this.min.x ? this.min.x = b.x : b.x > this.max.x && (this.max.x = b.x), b.y < this.min.y ? this.min.y = b.y : b.y > this.max.y && (this.max.y = b.y), b.z < this.min.z ? this.min.z = b.z : b.z > this.max.z && (this.max.z = b.z);\n    } else this.makeEmpty();\n    return this;\n  },\n  setFromCenterAndSize: function () {\n    var a = new THREE.Vector3();\n    return function (b, c) {\n      var d = a.copy(c).multiplyScalar(0.5);\n      this.min.copy(b).sub(d);\n      this.max.copy(b).add(d);\n      return this;\n    };\n  }(),\n  copy: function copy(a) {\n    this.min.copy(a.min);\n    this.max.copy(a.max);\n    return this;\n  },\n  makeEmpty: function makeEmpty() {\n    this.min.x = this.min.y = this.min.z = Infinity;\n    this.max.x = this.max.y = this.max.z = -Infinity;\n    return this;\n  },\n  empty: function empty() {\n    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n  },\n  center: function center(a) {\n    return (a || new THREE.Vector3()).addVectors(this.min, this.max).multiplyScalar(0.5);\n  },\n  size: function size(a) {\n    return (a || new THREE.Vector3()).subVectors(this.max, this.min);\n  },\n  expandByPoint: function expandByPoint(a) {\n    this.min.min(a);\n    this.max.max(a);\n    return this;\n  },\n  expandByVector: function expandByVector(a) {\n    this.min.sub(a);\n    this.max.add(a);\n    return this;\n  },\n  expandByScalar: function expandByScalar(a) {\n    this.min.addScalar(-a);\n    this.max.addScalar(a);\n    return this;\n  },\n  containsPoint: function containsPoint(a) {\n    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0;\n  },\n  containsBox: function containsBox(a) {\n    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1;\n  },\n  getParameter: function getParameter(a) {\n    return new THREE.Vector3((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));\n  },\n  isIntersectionBox: function isIntersectionBox(a) {\n    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0;\n  },\n  clampPoint: function clampPoint(a, b) {\n    return (b || new THREE.Vector3()).copy(a).clamp(this.min, this.max);\n  },\n  distanceToPoint: function () {\n    var a = new THREE.Vector3();\n    return function (b) {\n      return a.copy(b).clamp(this.min, this.max).sub(b).length();\n    };\n  }(),\n  getBoundingSphere: function () {\n    var a = new THREE.Vector3();\n    return function (b) {\n      b = b || new THREE.Sphere();\n      b.center = this.center();\n      b.radius = 0.5 * this.size(a).length();\n      return b;\n    };\n  }(),\n  intersect: function intersect(a) {\n    this.min.max(a.min);\n    this.max.min(a.max);\n    return this;\n  },\n  union: function union(a) {\n    this.min.min(a.min);\n    this.max.max(a.max);\n    return this;\n  },\n  applyMatrix4: function () {\n    var a = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];\n    return function (b) {\n      a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b);\n      a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);\n      a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);\n      a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);\n      a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);\n      a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);\n      a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);\n      a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);\n      this.makeEmpty();\n      this.setFromPoints(a);\n      return this;\n    };\n  }(),\n  translate: function translate(a) {\n    this.min.add(a);\n    this.max.add(a);\n    return this;\n  },\n  equals: function equals(a) {\n    return a.min.equals(this.min) && a.max.equals(this.max);\n  },\n  clone: function clone() {\n    return new THREE.Box3().copy(this);\n  }\n});\nTHREE.Matrix3 = function (a, b, c, d, e, f, g, h, i) {\n  this.elements = new Float32Array(9);\n  this.set(void 0 !== a ? a : 1, b || 0, c || 0, d || 0, void 0 !== e ? e : 1, f || 0, g || 0, h || 0, void 0 !== i ? i : 1);\n};\nTHREE.extend(THREE.Matrix3.prototype, {\n  set: function set(a, b, c, d, e, f, g, h, i) {\n    var k = this.elements;\n    k[0] = a;\n    k[3] = b;\n    k[6] = c;\n    k[1] = d;\n    k[4] = e;\n    k[7] = f;\n    k[2] = g;\n    k[5] = h;\n    k[8] = i;\n    return this;\n  },\n  identity: function identity() {\n    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    return this;\n  },\n  copy: function copy(a) {\n    a = a.elements;\n    this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);\n    return this;\n  },\n  multiplyVector3: function multiplyVector3(a) {\n    console.warn(\"DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.\");\n    return a.applyMatrix3(this);\n  },\n  multiplyVector3Array: function () {\n    var a = new THREE.Vector3();\n    return function (b) {\n      for (var c = 0, d = b.length; c < d; c += 3) a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyMatrix3(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;\n      return b;\n    };\n  }(),\n  multiplyScalar: function multiplyScalar(a) {\n    var b = this.elements;\n    b[0] *= a;\n    b[3] *= a;\n    b[6] *= a;\n    b[1] *= a;\n    b[4] *= a;\n    b[7] *= a;\n    b[2] *= a;\n    b[5] *= a;\n    b[8] *= a;\n    return this;\n  },\n  determinant: function determinant() {\n    var a = this.elements,\n      b = a[0],\n      c = a[1],\n      d = a[2],\n      e = a[3],\n      f = a[4],\n      g = a[5],\n      h = a[6],\n      i = a[7],\n      a = a[8];\n    return b * f * a - b * g * i - c * e * a + c * g * h + d * e * i - d * f * h;\n  },\n  getInverse: function getInverse(a, b) {\n    var c = a.elements,\n      d = this.elements;\n    d[0] = c[10] * c[5] - c[6] * c[9];\n    d[1] = -c[10] * c[1] + c[2] * c[9];\n    d[2] = c[6] * c[1] - c[2] * c[5];\n    d[3] = -c[10] * c[4] + c[6] * c[8];\n    d[4] = c[10] * c[0] - c[2] * c[8];\n    d[5] = -c[6] * c[0] + c[2] * c[4];\n    d[6] = c[9] * c[4] - c[5] * c[8];\n    d[7] = -c[9] * c[0] + c[1] * c[8];\n    d[8] = c[5] * c[0] - c[1] * c[4];\n    c = c[0] * d[0] + c[1] * d[3] + c[2] * d[6];\n    if (0 === c) {\n      if (b) throw Error(\"Matrix3.getInverse(): can't invert matrix, determinant is 0\");\n      console.warn(\"Matrix3.getInverse(): can't invert matrix, determinant is 0\");\n      this.identity();\n      return this;\n    }\n    this.multiplyScalar(1 / c);\n    return this;\n  },\n  transpose: function transpose() {\n    var a,\n      b = this.elements;\n    a = b[1];\n    b[1] = b[3];\n    b[3] = a;\n    a = b[2];\n    b[2] = b[6];\n    b[6] = a;\n    a = b[5];\n    b[5] = b[7];\n    b[7] = a;\n    return this;\n  },\n  getNormalMatrix: function getNormalMatrix(a) {\n    this.getInverse(a).transpose();\n    return this;\n  },\n  transposeIntoArray: function transposeIntoArray(a) {\n    var b = this.elements;\n    a[0] = b[0];\n    a[1] = b[3];\n    a[2] = b[6];\n    a[3] = b[1];\n    a[4] = b[4];\n    a[5] = b[7];\n    a[6] = b[2];\n    a[7] = b[5];\n    a[8] = b[8];\n    return this;\n  },\n  clone: function clone() {\n    var a = this.elements;\n    return new THREE.Matrix3(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);\n  }\n});\nTHREE.Matrix4 = function (a, b, c, d, e, f, g, h, i, k, l, m, n, s, r, p) {\n  var q = this.elements = new Float32Array(16);\n  q[0] = void 0 !== a ? a : 1;\n  q[4] = b || 0;\n  q[8] = c || 0;\n  q[12] = d || 0;\n  q[1] = e || 0;\n  q[5] = void 0 !== f ? f : 1;\n  q[9] = g || 0;\n  q[13] = h || 0;\n  q[2] = i || 0;\n  q[6] = k || 0;\n  q[10] = void 0 !== l ? l : 1;\n  q[14] = m || 0;\n  q[3] = n || 0;\n  q[7] = s || 0;\n  q[11] = r || 0;\n  q[15] = void 0 !== p ? p : 1;\n};\nTHREE.extend(THREE.Matrix4.prototype, {\n  set: function set(a, b, c, d, e, f, g, h, i, k, l, m, n, s, r, p) {\n    var q = this.elements;\n    q[0] = a;\n    q[4] = b;\n    q[8] = c;\n    q[12] = d;\n    q[1] = e;\n    q[5] = f;\n    q[9] = g;\n    q[13] = h;\n    q[2] = i;\n    q[6] = k;\n    q[10] = l;\n    q[14] = m;\n    q[3] = n;\n    q[7] = s;\n    q[11] = r;\n    q[15] = p;\n    return this;\n  },\n  identity: function identity() {\n    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    return this;\n  },\n  copy: function copy(a) {\n    a = a.elements;\n    this.set(a[0], a[4], a[8], a[12], a[1], a[5], a[9], a[13], a[2], a[6], a[10], a[14], a[3], a[7], a[11], a[15]);\n    return this;\n  },\n  setRotationFromEuler: function setRotationFromEuler(a, b) {\n    var c = this.elements,\n      d = a.x,\n      e = a.y,\n      f = a.z,\n      g = Math.cos(d),\n      d = Math.sin(d),\n      h = Math.cos(e),\n      e = Math.sin(e),\n      i = Math.cos(f),\n      f = Math.sin(f);\n    if (void 0 === b || \"XYZ\" === b) {\n      var k = g * i,\n        l = g * f,\n        m = d * i,\n        n = d * f;\n      c[0] = h * i;\n      c[4] = -h * f;\n      c[8] = e;\n      c[1] = l + m * e;\n      c[5] = k - n * e;\n      c[9] = -d * h;\n      c[2] = n - k * e;\n      c[6] = m + l * e;\n      c[10] = g * h;\n    } else \"YXZ\" === b ? (k = h * i, l = h * f, m = e * i, n = e * f, c[0] = k + n * d, c[4] = m * d - l, c[8] = g * e, c[1] = g * f, c[5] = g * i, c[9] = -d, c[2] = l * d - m, c[6] = n + k * d, c[10] = g * h) : \"ZXY\" === b ? (k = h * i, l = h * f, m = e * i, n = e * f, c[0] = k - n * d, c[4] = -g * f, c[8] = m + l * d, c[1] = l + m * d, c[5] = g * i, c[9] = n - k * d, c[2] = -g * e, c[6] = d, c[10] = g * h) : \"ZYX\" === b ? (k = g * i, l = g * f, m = d * i, n = d * f, c[0] = h * i, c[4] = m * e - l, c[8] = k * e + n, c[1] = h * f, c[5] = n * e + k, c[9] = l * e - m, c[2] = -e, c[6] = d * h, c[10] = g * h) : \"YZX\" === b ? (k = g * h, l = g * e, m = d * h, n = d * e, c[0] = h * i, c[4] = n - k * f, c[8] = m * f + l, c[1] = f, c[5] = g * i, c[9] = -d * i, c[2] = -e * i, c[6] = l * f + m, c[10] = k - n * f) : \"XZY\" === b && (k = g * h, l = g * e, m = d * h, n = d * e, c[0] = h * i, c[4] = -f, c[8] = e * i, c[1] = k * f + n, c[5] = g * i, c[9] = l * f - m, c[2] = m * f - l, c[6] = d * i, c[10] = n * f + k);\n    return this;\n  },\n  setRotationFromQuaternion: function setRotationFromQuaternion(a) {\n    var b = this.elements,\n      c = a.x,\n      d = a.y,\n      e = a.z,\n      f = a.w,\n      g = c + c,\n      h = d + d,\n      i = e + e,\n      a = c * g,\n      k = c * h,\n      c = c * i,\n      l = d * h,\n      d = d * i,\n      e = e * i,\n      g = f * g,\n      h = f * h,\n      f = f * i;\n    b[0] = 1 - (l + e);\n    b[4] = k - f;\n    b[8] = c + h;\n    b[1] = k + f;\n    b[5] = 1 - (a + e);\n    b[9] = d - g;\n    b[2] = c - h;\n    b[6] = d + g;\n    b[10] = 1 - (a + l);\n    return this;\n  },\n  lookAt: function () {\n    var a = new THREE.Vector3(),\n      b = new THREE.Vector3(),\n      c = new THREE.Vector3();\n    return function (d, e, f) {\n      var g = this.elements;\n      c.subVectors(d, e).normalize();\n      0 === c.length() && (c.z = 1);\n      a.crossVectors(f, c).normalize();\n      0 === a.length() && (c.x += 1E-4, a.crossVectors(f, c).normalize());\n      b.crossVectors(c, a);\n      g[0] = a.x;\n      g[4] = b.x;\n      g[8] = c.x;\n      g[1] = a.y;\n      g[5] = b.y;\n      g[9] = c.y;\n      g[2] = a.z;\n      g[6] = b.z;\n      g[10] = c.z;\n      return this;\n    };\n  }(),\n  multiply: function multiply(a, b) {\n    return void 0 !== b ? (console.warn(\"DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\"), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a);\n  },\n  multiplyMatrices: function multiplyMatrices(a, b) {\n    var c = a.elements,\n      d = b.elements,\n      e = this.elements,\n      f = c[0],\n      g = c[4],\n      h = c[8],\n      i = c[12],\n      k = c[1],\n      l = c[5],\n      m = c[9],\n      n = c[13],\n      s = c[2],\n      r = c[6],\n      p = c[10],\n      q = c[14],\n      y = c[3],\n      v = c[7],\n      z = c[11],\n      c = c[15],\n      t = d[0],\n      A = d[4],\n      I = d[8],\n      C = d[12],\n      x = d[1],\n      G = d[5],\n      J = d[9],\n      E = d[13],\n      H = d[2],\n      B = d[6],\n      W = d[10],\n      F = d[14],\n      K = d[3],\n      L = d[7],\n      U = d[11],\n      d = d[15];\n    e[0] = f * t + g * x + h * H + i * K;\n    e[4] = f * A + g * G + h * B + i * L;\n    e[8] = f * I + g * J + h * W + i * U;\n    e[12] = f * C + g * E + h * F + i * d;\n    e[1] = k * t + l * x + m * H + n * K;\n    e[5] = k * A + l * G + m * B + n * L;\n    e[9] = k * I + l * J + m * W + n * U;\n    e[13] = k * C + l * E + m * F + n * d;\n    e[2] = s * t + r * x + p * H + q * K;\n    e[6] = s * A + r * G + p * B + q * L;\n    e[10] = s * I + r * J + p * W + q * U;\n    e[14] = s * C + r * E + p * F + q * d;\n    e[3] = y * t + v * x + z * H + c * K;\n    e[7] = y * A + v * G + z * B + c * L;\n    e[11] = y * I + v * J + z * W + c * U;\n    e[15] = y * C + v * E + z * F + c * d;\n    return this;\n  },\n  multiplyToArray: function multiplyToArray(a, b, c) {\n    var d = this.elements;\n    this.multiplyMatrices(a, b);\n    c[0] = d[0];\n    c[1] = d[1];\n    c[2] = d[2];\n    c[3] = d[3];\n    c[4] = d[4];\n    c[5] = d[5];\n    c[6] = d[6];\n    c[7] = d[7];\n    c[8] = d[8];\n    c[9] = d[9];\n    c[10] = d[10];\n    c[11] = d[11];\n    c[12] = d[12];\n    c[13] = d[13];\n    c[14] = d[14];\n    c[15] = d[15];\n    return this;\n  },\n  multiplyScalar: function multiplyScalar(a) {\n    var b = this.elements;\n    b[0] *= a;\n    b[4] *= a;\n    b[8] *= a;\n    b[12] *= a;\n    b[1] *= a;\n    b[5] *= a;\n    b[9] *= a;\n    b[13] *= a;\n    b[2] *= a;\n    b[6] *= a;\n    b[10] *= a;\n    b[14] *= a;\n    b[3] *= a;\n    b[7] *= a;\n    b[11] *= a;\n    b[15] *= a;\n    return this;\n  },\n  multiplyVector3: function multiplyVector3(a) {\n    console.warn(\"DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.\");\n    return a.applyProjection(this);\n  },\n  multiplyVector4: function multiplyVector4(a) {\n    console.warn(\"DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.\");\n    return a.applyMatrix4(this);\n  },\n  multiplyVector3Array: function () {\n    var a = new THREE.Vector3();\n    return function (b) {\n      for (var c = 0, d = b.length; c < d; c += 3) a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyProjection(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;\n      return b;\n    };\n  }(),\n  rotateAxis: function rotateAxis(a) {\n    var b = this.elements,\n      c = a.x,\n      d = a.y,\n      e = a.z;\n    a.x = c * b[0] + d * b[4] + e * b[8];\n    a.y = c * b[1] + d * b[5] + e * b[9];\n    a.z = c * b[2] + d * b[6] + e * b[10];\n    a.normalize();\n    return a;\n  },\n  crossVector: function crossVector(a) {\n    var b = this.elements,\n      c = new THREE.Vector4();\n    c.x = b[0] * a.x + b[4] * a.y + b[8] * a.z + b[12] * a.w;\n    c.y = b[1] * a.x + b[5] * a.y + b[9] * a.z + b[13] * a.w;\n    c.z = b[2] * a.x + b[6] * a.y + b[10] * a.z + b[14] * a.w;\n    c.w = a.w ? b[3] * a.x + b[7] * a.y + b[11] * a.z + b[15] * a.w : 1;\n    return c;\n  },\n  determinant: function determinant() {\n    var a = this.elements,\n      b = a[0],\n      c = a[4],\n      d = a[8],\n      e = a[12],\n      f = a[1],\n      g = a[5],\n      h = a[9],\n      i = a[13],\n      k = a[2],\n      l = a[6],\n      m = a[10],\n      n = a[14];\n    return a[3] * (+e * h * l - d * i * l - e * g * m + c * i * m + d * g * n - c * h * n) + a[7] * (+b * h * n - b * i * m + e * f * m - d * f * n + d * i * k - e * h * k) + a[11] * (+b * i * l - b * g * n - e * f * l + c * f * n + e * g * k - c * i * k) + a[15] * (-d * g * k - b * h * l + b * g * m + d * f * l - c * f * m + c * h * k);\n  },\n  transpose: function transpose() {\n    var a = this.elements,\n      b;\n    b = a[1];\n    a[1] = a[4];\n    a[4] = b;\n    b = a[2];\n    a[2] = a[8];\n    a[8] = b;\n    b = a[6];\n    a[6] = a[9];\n    a[9] = b;\n    b = a[3];\n    a[3] = a[12];\n    a[12] = b;\n    b = a[7];\n    a[7] = a[13];\n    a[13] = b;\n    b = a[11];\n    a[11] = a[14];\n    a[14] = b;\n    return this;\n  },\n  flattenToArray: function flattenToArray(a) {\n    var b = this.elements;\n    a[0] = b[0];\n    a[1] = b[1];\n    a[2] = b[2];\n    a[3] = b[3];\n    a[4] = b[4];\n    a[5] = b[5];\n    a[6] = b[6];\n    a[7] = b[7];\n    a[8] = b[8];\n    a[9] = b[9];\n    a[10] = b[10];\n    a[11] = b[11];\n    a[12] = b[12];\n    a[13] = b[13];\n    a[14] = b[14];\n    a[15] = b[15];\n    return a;\n  },\n  flattenToArrayOffset: function flattenToArrayOffset(a, b) {\n    var c = this.elements;\n    a[b] = c[0];\n    a[b + 1] = c[1];\n    a[b + 2] = c[2];\n    a[b + 3] = c[3];\n    a[b + 4] = c[4];\n    a[b + 5] = c[5];\n    a[b + 6] = c[6];\n    a[b + 7] = c[7];\n    a[b + 8] = c[8];\n    a[b + 9] = c[9];\n    a[b + 10] = c[10];\n    a[b + 11] = c[11];\n    a[b + 12] = c[12];\n    a[b + 13] = c[13];\n    a[b + 14] = c[14];\n    a[b + 15] = c[15];\n    return a;\n  },\n  getPosition: function () {\n    var a = new THREE.Vector3();\n    return function () {\n      console.warn(\"DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.\");\n      var b = this.elements;\n      return a.set(b[12], b[13], b[14]);\n    };\n  }(),\n  setPosition: function setPosition(a) {\n    var b = this.elements;\n    b[12] = a.x;\n    b[13] = a.y;\n    b[14] = a.z;\n    return this;\n  },\n  getInverse: function getInverse(a, b) {\n    var c = this.elements,\n      d = a.elements,\n      e = d[0],\n      f = d[4],\n      g = d[8],\n      h = d[12],\n      i = d[1],\n      k = d[5],\n      l = d[9],\n      m = d[13],\n      n = d[2],\n      s = d[6],\n      r = d[10],\n      p = d[14],\n      q = d[3],\n      y = d[7],\n      v = d[11],\n      z = d[15];\n    c[0] = l * p * y - m * r * y + m * s * v - k * p * v - l * s * z + k * r * z;\n    c[4] = h * r * y - g * p * y - h * s * v + f * p * v + g * s * z - f * r * z;\n    c[8] = g * m * y - h * l * y + h * k * v - f * m * v - g * k * z + f * l * z;\n    c[12] = h * l * s - g * m * s - h * k * r + f * m * r + g * k * p - f * l * p;\n    c[1] = m * r * q - l * p * q - m * n * v + i * p * v + l * n * z - i * r * z;\n    c[5] = g * p * q - h * r * q + h * n * v - e * p * v - g * n * z + e * r * z;\n    c[9] = h * l * q - g * m * q - h * i * v + e * m * v + g * i * z - e * l * z;\n    c[13] = g * m * n - h * l * n + h * i * r - e * m * r - g * i * p + e * l * p;\n    c[2] = k * p * q - m * s * q + m * n * y - i * p * y - k * n * z + i * s * z;\n    c[6] = h * s * q - f * p * q - h * n * y + e * p * y + f * n * z - e * s * z;\n    c[10] = f * m * q - h * k * q + h * i * y - e * m * y - f * i * z + e * k * z;\n    c[14] = h * k * n - f * m * n - h * i * s + e * m * s + f * i * p - e * k * p;\n    c[3] = l * s * q - k * r * q - l * n * y + i * r * y + k * n * v - i * s * v;\n    c[7] = f * r * q - g * s * q + g * n * y - e * r * y - f * n * v + e * s * v;\n    c[11] = g * k * q - f * l * q - g * i * y + e * l * y + f * i * v - e * k * v;\n    c[15] = f * l * n - g * k * n + g * i * s - e * l * s - f * i * r + e * k * r;\n    c = d[0] * c[0] + d[1] * c[4] + d[2] * c[8] + d[3] * c[12];\n    if (0 == c) {\n      if (b) throw Error(\"Matrix4.getInverse(): can't invert matrix, determinant is 0\");\n      console.warn(\"Matrix4.getInverse(): can't invert matrix, determinant is 0\");\n      this.identity();\n      return this;\n    }\n    this.multiplyScalar(1 / c);\n    return this;\n  },\n  compose: function () {\n    var a = new THREE.Matrix4(),\n      b = new THREE.Matrix4();\n    return function (c, d, e) {\n      var f = this.elements;\n      a.identity();\n      a.setRotationFromQuaternion(d);\n      b.makeScale(e.x, e.y, e.z);\n      this.multiplyMatrices(a, b);\n      f[12] = c.x;\n      f[13] = c.y;\n      f[14] = c.z;\n      return this;\n    };\n  }(),\n  decompose: function () {\n    var a = new THREE.Vector3(),\n      b = new THREE.Vector3(),\n      c = new THREE.Vector3(),\n      d = new THREE.Matrix4();\n    return function (e, f, g) {\n      var h = this.elements;\n      a.set(h[0], h[1], h[2]);\n      b.set(h[4], h[5], h[6]);\n      c.set(h[8], h[9], h[10]);\n      e = e instanceof THREE.Vector3 ? e : new THREE.Vector3();\n      f = f instanceof THREE.Quaternion ? f : new THREE.Quaternion();\n      g = g instanceof THREE.Vector3 ? g : new THREE.Vector3();\n      g.x = a.length();\n      g.y = b.length();\n      g.z = c.length();\n      e.x = h[12];\n      e.y = h[13];\n      e.z = h[14];\n      d.copy(this);\n      d.elements[0] /= g.x;\n      d.elements[1] /= g.x;\n      d.elements[2] /= g.x;\n      d.elements[4] /= g.y;\n      d.elements[5] /= g.y;\n      d.elements[6] /= g.y;\n      d.elements[8] /= g.z;\n      d.elements[9] /= g.z;\n      d.elements[10] /= g.z;\n      f.setFromRotationMatrix(d);\n      return [e, f, g];\n    };\n  }(),\n  extractPosition: function extractPosition(a) {\n    var b = this.elements,\n      a = a.elements;\n    b[12] = a[12];\n    b[13] = a[13];\n    b[14] = a[14];\n    return this;\n  },\n  extractRotation: function () {\n    var a = new THREE.Vector3();\n    return function (b) {\n      var c = this.elements,\n        b = b.elements,\n        d = 1 / a.set(b[0], b[1], b[2]).length(),\n        e = 1 / a.set(b[4], b[5], b[6]).length(),\n        f = 1 / a.set(b[8], b[9], b[10]).length();\n      c[0] = b[0] * d;\n      c[1] = b[1] * d;\n      c[2] = b[2] * d;\n      c[4] = b[4] * e;\n      c[5] = b[5] * e;\n      c[6] = b[6] * e;\n      c[8] = b[8] * f;\n      c[9] = b[9] * f;\n      c[10] = b[10] * f;\n      return this;\n    };\n  }(),\n  translate: function translate(a) {\n    var b = this.elements,\n      c = a.x,\n      d = a.y,\n      a = a.z;\n    b[12] = b[0] * c + b[4] * d + b[8] * a + b[12];\n    b[13] = b[1] * c + b[5] * d + b[9] * a + b[13];\n    b[14] = b[2] * c + b[6] * d + b[10] * a + b[14];\n    b[15] = b[3] * c + b[7] * d + b[11] * a + b[15];\n    return this;\n  },\n  rotateX: function rotateX(a) {\n    var b = this.elements,\n      c = b[4],\n      d = b[5],\n      e = b[6],\n      f = b[7],\n      g = b[8],\n      h = b[9],\n      i = b[10],\n      k = b[11],\n      l = Math.cos(a),\n      a = Math.sin(a);\n    b[4] = l * c + a * g;\n    b[5] = l * d + a * h;\n    b[6] = l * e + a * i;\n    b[7] = l * f + a * k;\n    b[8] = l * g - a * c;\n    b[9] = l * h - a * d;\n    b[10] = l * i - a * e;\n    b[11] = l * k - a * f;\n    return this;\n  },\n  rotateY: function rotateY(a) {\n    var b = this.elements,\n      c = b[0],\n      d = b[1],\n      e = b[2],\n      f = b[3],\n      g = b[8],\n      h = b[9],\n      i = b[10],\n      k = b[11],\n      l = Math.cos(a),\n      a = Math.sin(a);\n    b[0] = l * c - a * g;\n    b[1] = l * d - a * h;\n    b[2] = l * e - a * i;\n    b[3] = l * f - a * k;\n    b[8] = l * g + a * c;\n    b[9] = l * h + a * d;\n    b[10] = l * i + a * e;\n    b[11] = l * k + a * f;\n    return this;\n  },\n  rotateZ: function rotateZ(a) {\n    var b = this.elements,\n      c = b[0],\n      d = b[1],\n      e = b[2],\n      f = b[3],\n      g = b[4],\n      h = b[5],\n      i = b[6],\n      k = b[7],\n      l = Math.cos(a),\n      a = Math.sin(a);\n    b[0] = l * c + a * g;\n    b[1] = l * d + a * h;\n    b[2] = l * e + a * i;\n    b[3] = l * f + a * k;\n    b[4] = l * g - a * c;\n    b[5] = l * h - a * d;\n    b[6] = l * i - a * e;\n    b[7] = l * k - a * f;\n    return this;\n  },\n  rotateByAxis: function rotateByAxis(a, b) {\n    var c = this.elements;\n    if (1 === a.x && 0 === a.y && 0 === a.z) return this.rotateX(b);\n    if (0 === a.x && 1 === a.y && 0 === a.z) return this.rotateY(b);\n    if (0 === a.x && 0 === a.y && 1 === a.z) return this.rotateZ(b);\n    var d = a.x,\n      e = a.y,\n      f = a.z,\n      g = Math.sqrt(d * d + e * e + f * f),\n      d = d / g,\n      e = e / g,\n      f = f / g,\n      g = d * d,\n      h = e * e,\n      i = f * f,\n      k = Math.cos(b),\n      l = Math.sin(b),\n      m = 1 - k,\n      n = d * e * m,\n      s = d * f * m,\n      m = e * f * m,\n      d = d * l,\n      r = e * l,\n      l = f * l,\n      f = g + (1 - g) * k,\n      g = n + l,\n      e = s - r,\n      n = n - l,\n      h = h + (1 - h) * k,\n      l = m + d,\n      s = s + r,\n      m = m - d,\n      i = i + (1 - i) * k,\n      k = c[0],\n      d = c[1],\n      r = c[2],\n      p = c[3],\n      q = c[4],\n      y = c[5],\n      v = c[6],\n      z = c[7],\n      t = c[8],\n      A = c[9],\n      I = c[10],\n      C = c[11];\n    c[0] = f * k + g * q + e * t;\n    c[1] = f * d + g * y + e * A;\n    c[2] = f * r + g * v + e * I;\n    c[3] = f * p + g * z + e * C;\n    c[4] = n * k + h * q + l * t;\n    c[5] = n * d + h * y + l * A;\n    c[6] = n * r + h * v + l * I;\n    c[7] = n * p + h * z + l * C;\n    c[8] = s * k + m * q + i * t;\n    c[9] = s * d + m * y + i * A;\n    c[10] = s * r + m * v + i * I;\n    c[11] = s * p + m * z + i * C;\n    return this;\n  },\n  scale: function scale(a) {\n    var b = this.elements,\n      c = a.x,\n      d = a.y,\n      a = a.z;\n    b[0] *= c;\n    b[4] *= d;\n    b[8] *= a;\n    b[1] *= c;\n    b[5] *= d;\n    b[9] *= a;\n    b[2] *= c;\n    b[6] *= d;\n    b[10] *= a;\n    b[3] *= c;\n    b[7] *= d;\n    b[11] *= a;\n    return this;\n  },\n  getMaxScaleOnAxis: function getMaxScaleOnAxis() {\n    var a = this.elements;\n    return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], Math.max(a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])));\n  },\n  makeTranslation: function makeTranslation(a, b, c) {\n    this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);\n    return this;\n  },\n  makeRotationX: function makeRotationX(a) {\n    var b = Math.cos(a),\n      a = Math.sin(a);\n    this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);\n    return this;\n  },\n  makeRotationY: function makeRotationY(a) {\n    var b = Math.cos(a),\n      a = Math.sin(a);\n    this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);\n    return this;\n  },\n  makeRotationZ: function makeRotationZ(a) {\n    var b = Math.cos(a),\n      a = Math.sin(a);\n    this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    return this;\n  },\n  makeRotationAxis: function makeRotationAxis(a, b) {\n    var c = Math.cos(b),\n      d = Math.sin(b),\n      e = 1 - c,\n      f = a.x,\n      g = a.y,\n      h = a.z,\n      i = e * f,\n      k = e * g;\n    this.set(i * f + c, i * g - d * h, i * h + d * g, 0, i * g + d * h, k * g + c, k * h - d * f, 0, i * h - d * g, k * h + d * f, e * h * h + c, 0, 0, 0, 0, 1);\n    return this;\n  },\n  makeScale: function makeScale(a, b, c) {\n    this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);\n    return this;\n  },\n  makeFrustum: function makeFrustum(a, b, c, d, e, f) {\n    var g = this.elements;\n    g[0] = 2 * e / (b - a);\n    g[4] = 0;\n    g[8] = (b + a) / (b - a);\n    g[12] = 0;\n    g[1] = 0;\n    g[5] = 2 * e / (d - c);\n    g[9] = (d + c) / (d - c);\n    g[13] = 0;\n    g[2] = 0;\n    g[6] = 0;\n    g[10] = -(f + e) / (f - e);\n    g[14] = -2 * f * e / (f - e);\n    g[3] = 0;\n    g[7] = 0;\n    g[11] = -1;\n    g[15] = 0;\n    return this;\n  },\n  makePerspective: function makePerspective(a, b, c, d) {\n    var a = c * Math.tan(THREE.Math.degToRad(0.5 * a)),\n      e = -a;\n    return this.makeFrustum(e * b, a * b, e, a, c, d);\n  },\n  makeOrthographic: function makeOrthographic(a, b, c, d, e, f) {\n    var g = this.elements,\n      h = b - a,\n      i = c - d,\n      k = f - e;\n    g[0] = 2 / h;\n    g[4] = 0;\n    g[8] = 0;\n    g[12] = -((b + a) / h);\n    g[1] = 0;\n    g[5] = 2 / i;\n    g[9] = 0;\n    g[13] = -((c + d) / i);\n    g[2] = 0;\n    g[6] = 0;\n    g[10] = -2 / k;\n    g[14] = -((f + e) / k);\n    g[3] = 0;\n    g[7] = 0;\n    g[11] = 0;\n    g[15] = 1;\n    return this;\n  },\n  clone: function clone() {\n    var a = this.elements;\n    return new THREE.Matrix4(a[0], a[4], a[8], a[12], a[1], a[5], a[9], a[13], a[2], a[6], a[10], a[14], a[3], a[7], a[11], a[15]);\n  }\n});\nTHREE.Ray = function (a, b) {\n  this.origin = void 0 !== a ? a : new THREE.Vector3();\n  this.direction = void 0 !== b ? b : new THREE.Vector3();\n};\nTHREE.extend(THREE.Ray.prototype, {\n  set: function set(a, b) {\n    this.origin.copy(a);\n    this.direction.copy(b);\n    return this;\n  },\n  copy: function copy(a) {\n    this.origin.copy(a.origin);\n    this.direction.copy(a.direction);\n    return this;\n  },\n  at: function at(a, b) {\n    return (b || new THREE.Vector3()).copy(this.direction).multiplyScalar(a).add(this.origin);\n  },\n  recast: function () {\n    var a = new THREE.Vector3();\n    return function (b) {\n      this.origin.copy(this.at(b, a));\n      return this;\n    };\n  }(),\n  closestPointToPoint: function closestPointToPoint(a, b) {\n    var c = b || new THREE.Vector3();\n    c.subVectors(a, this.origin);\n    var d = c.dot(this.direction);\n    return c.copy(this.direction).multiplyScalar(d).add(this.origin);\n  },\n  distanceToPoint: function () {\n    var a = new THREE.Vector3();\n    return function (b) {\n      var c = a.subVectors(b, this.origin).dot(this.direction);\n      a.copy(this.direction).multiplyScalar(c).add(this.origin);\n      return a.distanceTo(b);\n    };\n  }(),\n  isIntersectionSphere: function isIntersectionSphere(a) {\n    return this.distanceToPoint(a.center) <= a.radius;\n  },\n  isIntersectionPlane: function isIntersectionPlane(a) {\n    return 0 != a.normal.dot(this.direction) || 0 == a.distanceToPoint(this.origin) ? !0 : !1;\n  },\n  distanceToPlane: function distanceToPlane(a) {\n    var b = a.normal.dot(this.direction);\n    if (0 == b) {\n      if (0 == a.distanceToPoint(this.origin)) return 0;\n    } else return -(this.origin.dot(a.normal) + a.constant) / b;\n  },\n  intersectPlane: function intersectPlane(a, b) {\n    var c = this.distanceToPlane(a);\n    return void 0 === c ? void 0 : this.at(c, b);\n  },\n  applyMatrix4: function applyMatrix4(a) {\n    this.direction.add(this.origin).applyMatrix4(a);\n    this.origin.applyMatrix4(a);\n    this.direction.sub(this.origin);\n    return this;\n  },\n  equals: function equals(a) {\n    return a.origin.equals(this.origin) && a.direction.equals(this.direction);\n  },\n  clone: function clone() {\n    return new THREE.Ray().copy(this);\n  }\n});\nTHREE.Sphere = function (a, b) {\n  this.center = void 0 !== a ? a : new THREE.Vector3();\n  this.radius = void 0 !== b ? b : 0;\n};\nTHREE.extend(THREE.Sphere.prototype, {\n  set: function set(a, b) {\n    this.center.copy(a);\n    this.radius = b;\n    return this;\n  },\n  setFromCenterAndPoints: function setFromCenterAndPoints(a, b) {\n    for (var c = 0, d = 0, e = b.length; d < e; d++) var f = a.distanceToSquared(b[d]), c = Math.max(c, f);\n    this.center = a;\n    this.radius = Math.sqrt(c);\n    return this;\n  },\n  copy: function copy(a) {\n    this.center.copy(a.center);\n    this.radius = a.radius;\n    return this;\n  },\n  empty: function empty() {\n    return 0 >= this.radius;\n  },\n  containsPoint: function containsPoint(a) {\n    return a.distanceToSquared(this.center) <= this.radius * this.radius;\n  },\n  distanceToPoint: function distanceToPoint(a) {\n    return a.distanceTo(this.center) - this.radius;\n  },\n  intersectsSphere: function intersectsSphere(a) {\n    var b = this.radius + a.radius;\n    return a.center.distanceToSquared(this.center) <= b * b;\n  },\n  clampPoint: function clampPoint(a, b) {\n    var c = this.center.distanceToSquared(a),\n      d = b || new THREE.Vector3();\n    d.copy(a);\n    c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center));\n    return d;\n  },\n  getBoundingBox: function getBoundingBox(a) {\n    a = a || new THREE.Box3();\n    a.set(this.center, this.center);\n    a.expandByScalar(this.radius);\n    return a;\n  },\n  applyMatrix4: function applyMatrix4(a) {\n    this.center.applyMatrix4(a);\n    this.radius *= a.getMaxScaleOnAxis();\n    return this;\n  },\n  translate: function translate(a) {\n    this.center.add(a);\n    return this;\n  },\n  equals: function equals(a) {\n    return a.center.equals(this.center) && a.radius === this.radius;\n  },\n  clone: function clone() {\n    return new THREE.Sphere().copy(this);\n  }\n});\nTHREE.Frustum = function (a, b, c, d, e, f) {\n  this.planes = [void 0 !== a ? a : new THREE.Plane(), void 0 !== b ? b : new THREE.Plane(), void 0 !== c ? c : new THREE.Plane(), void 0 !== d ? d : new THREE.Plane(), void 0 !== e ? e : new THREE.Plane(), void 0 !== f ? f : new THREE.Plane()];\n};\nTHREE.extend(THREE.Frustum.prototype, {\n  set: function set(a, b, c, d, e, f) {\n    var g = this.planes;\n    g[0].copy(a);\n    g[1].copy(b);\n    g[2].copy(c);\n    g[3].copy(d);\n    g[4].copy(e);\n    g[5].copy(f);\n    return this;\n  },\n  copy: function copy(a) {\n    for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);\n    return this;\n  },\n  setFromMatrix: function setFromMatrix(a) {\n    var b = this.planes,\n      c = a.elements,\n      a = c[0],\n      d = c[1],\n      e = c[2],\n      f = c[3],\n      g = c[4],\n      h = c[5],\n      i = c[6],\n      k = c[7],\n      l = c[8],\n      m = c[9],\n      n = c[10],\n      s = c[11],\n      r = c[12],\n      p = c[13],\n      q = c[14],\n      c = c[15];\n    b[0].setComponents(f - a, k - g, s - l, c - r).normalize();\n    b[1].setComponents(f + a, k + g, s + l, c + r).normalize();\n    b[2].setComponents(f + d, k + h, s + m, c + p).normalize();\n    b[3].setComponents(f - d, k - h, s - m, c - p).normalize();\n    b[4].setComponents(f - e, k - i, s - n, c - q).normalize();\n    b[5].setComponents(f + e, k + i, s + n, c + q).normalize();\n    return this;\n  },\n  intersectsObject: function () {\n    var a = new THREE.Vector3();\n    return function (b) {\n      var c = b.matrixWorld,\n        d = this.planes,\n        b = -b.geometry.boundingSphere.radius * c.getMaxScaleOnAxis();\n      a.getPositionFromMatrix(c);\n      for (c = 0; 6 > c; c++) if (d[c].distanceToPoint(a) < b) return !1;\n      return !0;\n    };\n  }(),\n  intersectsSphere: function intersectsSphere(a) {\n    for (var b = this.planes, c = a.center, a = -a.radius, d = 0; 6 > d; d++) if (b[d].distanceToPoint(c) < a) return !1;\n    return !0;\n  },\n  containsPoint: function containsPoint(a) {\n    for (var b = this.planes, c = 0; 6 > c; c++) if (0 > b[c].distanceToPoint(a)) return !1;\n    return !0;\n  },\n  clone: function clone() {\n    return new THREE.Frustum().copy(this);\n  }\n});\nTHREE.Plane = function (a, b) {\n  this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0);\n  this.constant = void 0 !== b ? b : 0;\n};\nTHREE.extend(THREE.Plane.prototype, {\n  set: function set(a, b) {\n    this.normal.copy(a);\n    this.constant = b;\n    return this;\n  },\n  setComponents: function setComponents(a, b, c, d) {\n    this.normal.set(a, b, c);\n    this.constant = d;\n    return this;\n  },\n  setFromNormalAndCoplanarPoint: function setFromNormalAndCoplanarPoint(a, b) {\n    this.normal.copy(a);\n    this.constant = -b.dot(this.normal);\n    return this;\n  },\n  setFromCoplanarPoints: function () {\n    var a = new THREE.Vector3(),\n      b = new THREE.Vector3();\n    return function (c, d, e) {\n      d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();\n      this.setFromNormalAndCoplanarPoint(d, c);\n      return this;\n    };\n  }(),\n  copy: function copy(a) {\n    this.normal.copy(a.normal);\n    this.constant = a.constant;\n    return this;\n  },\n  normalize: function normalize() {\n    var a = 1 / this.normal.length();\n    this.normal.multiplyScalar(a);\n    this.constant *= a;\n    return this;\n  },\n  negate: function negate() {\n    this.constant *= -1;\n    this.normal.negate();\n    return this;\n  },\n  distanceToPoint: function distanceToPoint(a) {\n    return this.normal.dot(a) + this.constant;\n  },\n  distanceToSphere: function distanceToSphere(a) {\n    return this.distanceToPoint(a.center) - a.radius;\n  },\n  projectPoint: function projectPoint(a, b) {\n    return this.orthoPoint(a, b).sub(a).negate();\n  },\n  orthoPoint: function orthoPoint(a, b) {\n    var c = this.distanceToPoint(a);\n    return (b || new THREE.Vector3()).copy(this.normal).multiplyScalar(c);\n  },\n  isIntersectionLine: function isIntersectionLine(a) {\n    var b = this.distanceToPoint(a.start),\n      a = this.distanceToPoint(a.end);\n    return 0 > b && 0 < a || 0 > a && 0 < b;\n  },\n  intersectLine: function () {\n    var a = new THREE.Vector3();\n    return function (b, c) {\n      var d = c || new THREE.Vector3(),\n        e = b.delta(a),\n        f = this.normal.dot(e);\n      if (0 == f) {\n        if (0 == this.distanceToPoint(b.start)) return d.copy(b.start);\n      } else return f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start);\n    };\n  }(),\n  coplanarPoint: function coplanarPoint(a) {\n    return (a || new THREE.Vector3()).copy(this.normal).multiplyScalar(-this.constant);\n  },\n  applyMatrix4: function () {\n    var a = new THREE.Vector3(),\n      b = new THREE.Vector3();\n    return function (c, d) {\n      var d = d || new THREE.Matrix3().getInverse(c).transpose(),\n        e = a.copy(this.normal).applyMatrix3(d),\n        f = this.coplanarPoint(b);\n      f.applyMatrix4(c);\n      this.setFromNormalAndCoplanarPoint(e, f);\n      return this;\n    };\n  }(),\n  translate: function translate(a) {\n    this.constant -= a.dot(this.normal);\n    return this;\n  },\n  equals: function equals(a) {\n    return a.normal.equals(this.normal) && a.constant == this.constant;\n  },\n  clone: function clone() {\n    return new THREE.Plane().copy(this);\n  }\n});\nTHREE.Math = {\n  clamp: function clamp(a, b, c) {\n    return a < b ? b : a > c ? c : a;\n  },\n  clampBottom: function clampBottom(a, b) {\n    return a < b ? b : a;\n  },\n  mapLinear: function mapLinear(a, b, c, d, e) {\n    return d + (a - b) * (e - d) / (c - b);\n  },\n  smoothstep: function smoothstep(a, b, c) {\n    if (a <= b) return 0;\n    if (a >= c) return 1;\n    a = (a - b) / (c - b);\n    return a * a * (3 - 2 * a);\n  },\n  smootherstep: function smootherstep(a, b, c) {\n    if (a <= b) return 0;\n    if (a >= c) return 1;\n    a = (a - b) / (c - b);\n    return a * a * a * (a * (6 * a - 15) + 10);\n  },\n  random16: function random16() {\n    return (65280 * Math.random() + 255 * Math.random()) / 65535;\n  },\n  randInt: function randInt(a, b) {\n    return a + Math.floor(Math.random() * (b - a + 1));\n  },\n  randFloat: function randFloat(a, b) {\n    return a + Math.random() * (b - a);\n  },\n  randFloatSpread: function randFloatSpread(a) {\n    return a * (0.5 - Math.random());\n  },\n  sign: function sign(a) {\n    return 0 > a ? -1 : 0 < a ? 1 : 0;\n  },\n  degToRad: function () {\n    var a = Math.PI / 180;\n    return function (b) {\n      return b * a;\n    };\n  }(),\n  radToDeg: function () {\n    var a = 180 / Math.PI;\n    return function (b) {\n      return b * a;\n    };\n  }()\n};\nTHREE.Spline = function (a) {\n  function b(a, b, c, d, e, f, g) {\n    a = 0.5 * (c - a);\n    d = 0.5 * (d - b);\n    return (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b;\n  }\n  this.points = a;\n  var c = [],\n    d = {\n      x: 0,\n      y: 0,\n      z: 0\n    },\n    e,\n    f,\n    g,\n    h,\n    i,\n    k,\n    l,\n    m,\n    n;\n  this.initFromArray = function (a) {\n    this.points = [];\n    for (var b = 0; b < a.length; b++) this.points[b] = {\n      x: a[b][0],\n      y: a[b][1],\n      z: a[b][2]\n    };\n  };\n  this.getPoint = function (a) {\n    e = (this.points.length - 1) * a;\n    f = Math.floor(e);\n    g = e - f;\n    c[0] = 0 === f ? f : f - 1;\n    c[1] = f;\n    c[2] = f > this.points.length - 2 ? this.points.length - 1 : f + 1;\n    c[3] = f > this.points.length - 3 ? this.points.length - 1 : f + 2;\n    k = this.points[c[0]];\n    l = this.points[c[1]];\n    m = this.points[c[2]];\n    n = this.points[c[3]];\n    h = g * g;\n    i = g * h;\n    d.x = b(k.x, l.x, m.x, n.x, g, h, i);\n    d.y = b(k.y, l.y, m.y, n.y, g, h, i);\n    d.z = b(k.z, l.z, m.z, n.z, g, h, i);\n    return d;\n  };\n  this.getControlPointsArray = function () {\n    var a,\n      b,\n      c = this.points.length,\n      d = [];\n    for (a = 0; a < c; a++) b = this.points[a], d[a] = [b.x, b.y, b.z];\n    return d;\n  };\n  this.getLength = function (a) {\n    var b,\n      c,\n      d,\n      e = b = b = 0,\n      f = new THREE.Vector3(),\n      g = new THREE.Vector3(),\n      h = [],\n      i = 0;\n    h[0] = 0;\n    a || (a = 100);\n    c = this.points.length * a;\n    f.copy(this.points[0]);\n    for (a = 1; a < c; a++) b = a / c, d = this.getPoint(b), g.copy(d), i += g.distanceTo(f), f.copy(d), b *= this.points.length - 1, b = Math.floor(b), b != e && (h[b] = i, e = b);\n    h[h.length] = i;\n    return {\n      chunks: h,\n      total: i\n    };\n  };\n  this.reparametrizeByArcLength = function (a) {\n    var b,\n      c,\n      d,\n      e,\n      f,\n      g,\n      h = [],\n      i = new THREE.Vector3(),\n      k = this.getLength();\n    h.push(i.copy(this.points[0]).clone());\n    for (b = 1; b < this.points.length; b++) {\n      c = k.chunks[b] - k.chunks[b - 1];\n      g = Math.ceil(a * c / k.total);\n      e = (b - 1) / (this.points.length - 1);\n      f = b / (this.points.length - 1);\n      for (c = 1; c < g - 1; c++) d = e + c * (1 / g) * (f - e), d = this.getPoint(d), h.push(i.copy(d).clone());\n      h.push(i.copy(this.points[b]).clone());\n    }\n    this.points = h;\n  };\n};\nTHREE.Triangle = function (a, b, c) {\n  this.a = void 0 !== a ? a : new THREE.Vector3();\n  this.b = void 0 !== b ? b : new THREE.Vector3();\n  this.c = void 0 !== c ? c : new THREE.Vector3();\n};\nTHREE.Triangle.normal = function () {\n  var a = new THREE.Vector3();\n  return function (b, c, d, e) {\n    e = e || new THREE.Vector3();\n    e.subVectors(d, c);\n    a.subVectors(b, c);\n    e.cross(a);\n    b = e.lengthSq();\n    return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0);\n  };\n}();\nTHREE.Triangle.barycoordFromPoint = function () {\n  var a = new THREE.Vector3(),\n    b = new THREE.Vector3(),\n    c = new THREE.Vector3();\n  return function (d, e, f, g, h) {\n    a.subVectors(g, e);\n    b.subVectors(f, e);\n    c.subVectors(d, e);\n    var d = a.dot(a),\n      e = a.dot(b),\n      f = a.dot(c),\n      i = b.dot(b),\n      g = b.dot(c),\n      k = d * i - e * e,\n      h = h || new THREE.Vector3();\n    if (0 == k) return h.set(-2, -1, -1);\n    k = 1 / k;\n    i = (i * f - e * g) * k;\n    d = (d * g - e * f) * k;\n    return h.set(1 - i - d, d, i);\n  };\n}();\nTHREE.Triangle.containsPoint = function () {\n  var a = new THREE.Vector3();\n  return function (b, c, d, e) {\n    b = THREE.Triangle.barycoordFromPoint(b, c, d, e, a);\n    return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y;\n  };\n}();\nTHREE.extend(THREE.Triangle.prototype, {\n  constructor: THREE.Triangle,\n  set: function set(a, b, c) {\n    this.a.copy(a);\n    this.b.copy(b);\n    this.c.copy(c);\n    return this;\n  },\n  setFromPointsAndIndices: function setFromPointsAndIndices(a, b, c, d) {\n    this.a.copy(a[b]);\n    this.b.copy(a[c]);\n    this.c.copy(a[d]);\n    return this;\n  },\n  copy: function copy(a) {\n    this.a.copy(a.a);\n    this.b.copy(a.b);\n    this.c.copy(a.c);\n    return this;\n  },\n  area: function () {\n    var a = new THREE.Vector3(),\n      b = new THREE.Vector3();\n    return function () {\n      a.subVectors(this.c, this.b);\n      b.subVectors(this.a, this.b);\n      return 0.5 * a.cross(b).length();\n    };\n  }(),\n  midpoint: function midpoint(a) {\n    return (a || new THREE.Vector3()).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n  },\n  normal: function normal(a) {\n    return THREE.Triangle.normal(this.a, this.b, this.c, a);\n  },\n  plane: function plane(a) {\n    return (a || new THREE.Plane()).setFromCoplanarPoints(this.a, this.b, this.c);\n  },\n  barycoordFromPoint: function barycoordFromPoint(a, b) {\n    return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b);\n  },\n  containsPoint: function containsPoint(a) {\n    return THREE.Triangle.containsPoint(a, this.a, this.b, this.c);\n  },\n  equals: function equals(a) {\n    return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);\n  },\n  clone: function clone() {\n    return new THREE.Triangle().copy(this);\n  }\n});\nTHREE.Vertex = function (a) {\n  console.warn(\"THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.\");\n  return a;\n};\nTHREE.UV = function (a, b) {\n  console.warn(\"THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.\");\n  return new THREE.Vector2(a, b);\n};\nTHREE.Clock = function (a) {\n  this.autoStart = void 0 !== a ? a : !0;\n  this.elapsedTime = this.oldTime = this.startTime = 0;\n  this.running = !1;\n};\nTHREE.extend(THREE.Clock.prototype, {\n  start: function start() {\n    this.oldTime = this.startTime = void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now();\n    this.running = !0;\n  },\n  stop: function stop() {\n    this.getElapsedTime();\n    this.running = !1;\n  },\n  getElapsedTime: function getElapsedTime() {\n    this.getDelta();\n    return this.elapsedTime;\n  },\n  getDelta: function getDelta() {\n    var a = 0;\n    this.autoStart && !this.running && this.start();\n    if (this.running) {\n      var b = void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(),\n        a = 0.001 * (b - this.oldTime);\n      this.oldTime = b;\n      this.elapsedTime += a;\n    }\n    return a;\n  }\n});\nTHREE.EventDispatcher = function () {\n  var a = {};\n  this.addEventListener = function (b, c) {\n    void 0 === a[b] && (a[b] = []);\n    -1 === a[b].indexOf(c) && a[b].push(c);\n  };\n  this.removeEventListener = function (b, c) {\n    var d = a[b].indexOf(c);\n    -1 !== d && a[b].splice(d, 1);\n  };\n  this.dispatchEvent = function (b) {\n    var c = a[b.type];\n    if (void 0 !== c) {\n      b.target = this;\n      for (var d = 0, e = c.length; d < e; d++) c[d].call(this, b);\n    }\n  };\n};\n(function (a) {\n  a.Raycaster = function (b, c, d, e) {\n    this.ray = new a.Ray(b, c);\n    0 < this.ray.direction.lengthSq() && this.ray.direction.normalize();\n    this.near = d || 0;\n    this.far = e || Infinity;\n  };\n  var b = new a.Sphere(),\n    c = new a.Ray(),\n    d = new a.Plane(),\n    e = new a.Vector3(),\n    f = new a.Vector3(),\n    g = new a.Matrix4(),\n    h = function h(a, b) {\n      return a.distance - b.distance;\n    },\n    i = function i(h, _i, k) {\n      if (h instanceof a.Particle) {\n        f.getPositionFromMatrix(h.matrixWorld);\n        _i = _i.ray.distanceToPoint(f);\n        if (_i > h.scale.x) return k;\n        k.push({\n          distance: _i,\n          point: h.position,\n          face: null,\n          object: h\n        });\n      } else if (h instanceof a.Mesh) {\n        f.getPositionFromMatrix(h.matrixWorld);\n        b.set(f, h.geometry.boundingSphere.radius * h.matrixWorld.getMaxScaleOnAxis());\n        if (!_i.ray.isIntersectionSphere(b)) return k;\n        var s = h.geometry,\n          r = s.vertices,\n          p = h.material instanceof a.MeshFaceMaterial,\n          q = !0 === p ? h.material.materials : null,\n          y = h.material.side,\n          v,\n          z,\n          t,\n          A = _i.precision;\n        h.matrixRotationWorld.extractRotation(h.matrixWorld);\n        g.getInverse(h.matrixWorld);\n        c.copy(_i.ray).applyMatrix4(g);\n        for (var I = 0, C = s.faces.length; I < C; I++) {\n          var x = s.faces[I],\n            y = !0 === p ? q[x.materialIndex] : h.material;\n          if (void 0 !== y) {\n            d.setFromNormalAndCoplanarPoint(x.normal, r[x.a]);\n            var G = c.distanceToPlane(d);\n            if (!(Math.abs(G) < A) && !(0 > G)) {\n              y = y.side;\n              if (y !== a.DoubleSide && (v = c.direction.dot(d.normal), !(y === a.FrontSide ? 0 > v : 0 < v))) continue;\n              if (!(G < _i.near || G > _i.far)) {\n                e = c.at(G, e);\n                if (x instanceof a.Face3) {\n                  if (y = r[x.a], v = r[x.b], z = r[x.c], !a.Triangle.containsPoint(e, y, v, z)) continue;\n                } else if (x instanceof a.Face4) {\n                  if (y = r[x.a], v = r[x.b], z = r[x.c], t = r[x.d], !a.Triangle.containsPoint(e, y, v, t) && !a.Triangle.containsPoint(e, v, z, t)) continue;\n                } else throw Error(\"face type not supported\");\n                k.push({\n                  distance: G,\n                  point: _i.ray.at(G),\n                  face: x,\n                  faceIndex: I,\n                  object: h\n                });\n              }\n            }\n          }\n        }\n      }\n    },\n    k = function k(a, b, c) {\n      for (var a = a.getDescendants(), d = 0, e = a.length; d < e; d++) i(a[d], b, c);\n    };\n  a.Raycaster.prototype.precision = 1E-4;\n  a.Raycaster.prototype.set = function (a, b) {\n    this.ray.set(a, b);\n    0 < this.ray.direction.length() && this.ray.direction.normalize();\n  };\n  a.Raycaster.prototype.intersectObject = function (a, b) {\n    var c = [];\n    !0 === b && k(a, this, c);\n    i(a, this, c);\n    c.sort(h);\n    return c;\n  };\n  a.Raycaster.prototype.intersectObjects = function (a, b) {\n    for (var c = [], d = 0, e = a.length; d < e; d++) i(a[d], this, c), !0 === b && k(a[d], this, c);\n    c.sort(h);\n    return c;\n  };\n})(THREE);\nTHREE.Object3D = function () {\n  this.id = THREE.Object3DIdCount++;\n  this.name = \"\";\n  this.properties = {};\n  this.parent = void 0;\n  this.children = [];\n  this.up = new THREE.Vector3(0, 1, 0);\n  this.position = new THREE.Vector3();\n  this.rotation = new THREE.Vector3();\n  this.eulerOrder = THREE.Object3D.defaultEulerOrder;\n  this.scale = new THREE.Vector3(1, 1, 1);\n  this.renderDepth = null;\n  this.rotationAutoUpdate = !0;\n  this.matrix = new THREE.Matrix4();\n  this.matrixWorld = new THREE.Matrix4();\n  this.matrixRotationWorld = new THREE.Matrix4();\n  this.matrixWorldNeedsUpdate = this.matrixAutoUpdate = !0;\n  this.quaternion = new THREE.Quaternion();\n  this.useQuaternion = !1;\n  this.visible = !0;\n  this.receiveShadow = this.castShadow = !1;\n  this.frustumCulled = !0;\n  this._vector = new THREE.Vector3();\n};\nTHREE.Object3D.prototype = {\n  constructor: THREE.Object3D,\n  applyMatrix: function applyMatrix(a) {\n    this.matrix.multiplyMatrices(a, this.matrix);\n    this.scale.getScaleFromMatrix(this.matrix);\n    a = new THREE.Matrix4().extractRotation(this.matrix);\n    this.rotation.setEulerFromRotationMatrix(a, this.eulerOrder);\n    this.position.getPositionFromMatrix(this.matrix);\n  },\n  translate: function translate(a, b) {\n    this.matrix.rotateAxis(b);\n    this.position.add(b.multiplyScalar(a));\n  },\n  translateX: function translateX(a) {\n    this.translate(a, this._vector.set(1, 0, 0));\n  },\n  translateY: function translateY(a) {\n    this.translate(a, this._vector.set(0, 1, 0));\n  },\n  translateZ: function translateZ(a) {\n    this.translate(a, this._vector.set(0, 0, 1));\n  },\n  localToWorld: function localToWorld(a) {\n    return a.applyMatrix4(this.matrixWorld);\n  },\n  worldToLocal: function worldToLocal(a) {\n    return a.applyMatrix4(THREE.Object3D.__m1.getInverse(this.matrixWorld));\n  },\n  lookAt: function lookAt(a) {\n    this.matrix.lookAt(a, this.position, this.up);\n    this.rotationAutoUpdate && (!1 === this.useQuaternion ? this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder) : this.quaternion.copy(this.matrix.decompose()[1]));\n  },\n  add: function add(a) {\n    if (a === this) console.warn(\"THREE.Object3D.add: An object can't be added as a child of itself.\");else if (a instanceof THREE.Object3D) {\n      void 0 !== a.parent && a.parent.remove(a);\n      a.parent = this;\n      this.children.push(a);\n      for (var b = this; void 0 !== b.parent;) b = b.parent;\n      void 0 !== b && b instanceof THREE.Scene && b.__addObject(a);\n    }\n  },\n  remove: function remove(a) {\n    var b = this.children.indexOf(a);\n    if (-1 !== b) {\n      a.parent = void 0;\n      this.children.splice(b, 1);\n      for (b = this; void 0 !== b.parent;) b = b.parent;\n      void 0 !== b && b instanceof THREE.Scene && b.__removeObject(a);\n    }\n  },\n  traverse: function traverse(a) {\n    a(this);\n    for (var b = 0, c = this.children.length; b < c; b++) this.children[b].traverse(a);\n  },\n  getChildByName: function getChildByName(a, b) {\n    for (var c = 0, d = this.children.length; c < d; c++) {\n      var e = this.children[c];\n      if (e.name === a || !0 === b && (e = e.getChildByName(a, b), void 0 !== e)) return e;\n    }\n  },\n  getDescendants: function getDescendants(a) {\n    void 0 === a && (a = []);\n    Array.prototype.push.apply(a, this.children);\n    for (var b = 0, c = this.children.length; b < c; b++) this.children[b].getDescendants(a);\n    return a;\n  },\n  updateMatrix: function updateMatrix() {\n    this.matrix.setPosition(this.position);\n    !1 === this.useQuaternion ? this.matrix.setRotationFromEuler(this.rotation, this.eulerOrder) : this.matrix.setRotationFromQuaternion(this.quaternion);\n    (1 !== this.scale.x || 1 !== this.scale.y || 1 !== this.scale.z) && this.matrix.scale(this.scale);\n    this.matrixWorldNeedsUpdate = !0;\n  },\n  updateMatrixWorld: function updateMatrixWorld(a) {\n    !0 === this.matrixAutoUpdate && this.updateMatrix();\n    if (!0 === this.matrixWorldNeedsUpdate || !0 === a) void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;\n    for (var b = 0, c = this.children.length; b < c; b++) this.children[b].updateMatrixWorld(a);\n  },\n  clone: function clone(a) {\n    void 0 === a && (a = new THREE.Object3D());\n    a.name = this.name;\n    a.up.copy(this.up);\n    a.position.copy(this.position);\n    a.rotation instanceof THREE.Vector3 && a.rotation.copy(this.rotation);\n    a.eulerOrder = this.eulerOrder;\n    a.scale.copy(this.scale);\n    a.renderDepth = this.renderDepth;\n    a.rotationAutoUpdate = this.rotationAutoUpdate;\n    a.matrix.copy(this.matrix);\n    a.matrixWorld.copy(this.matrixWorld);\n    a.matrixRotationWorld.copy(this.matrixRotationWorld);\n    a.matrixAutoUpdate = this.matrixAutoUpdate;\n    a.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\n    a.quaternion.copy(this.quaternion);\n    a.useQuaternion = this.useQuaternion;\n    a.visible = this.visible;\n    a.castShadow = this.castShadow;\n    a.receiveShadow = this.receiveShadow;\n    a.frustumCulled = this.frustumCulled;\n    for (var b = 0; b < this.children.length; b++) a.add(this.children[b].clone());\n    return a;\n  }\n};\nTHREE.Object3D.__m1 = new THREE.Matrix4();\nTHREE.Object3D.defaultEulerOrder = \"XYZ\";\nTHREE.Object3DIdCount = 0;\nTHREE.Projector = function () {\n  function a() {\n    if (f === h) {\n      var a = new THREE.RenderableObject();\n      g.push(a);\n      h++;\n      f++;\n      return a;\n    }\n    return g[f++];\n  }\n  function b() {\n    if (k === m) {\n      var a = new THREE.RenderableVertex();\n      l.push(a);\n      m++;\n      k++;\n      return a;\n    }\n    return l[k++];\n  }\n  function c(a, b) {\n    return b.z - a.z;\n  }\n  function d(a, b) {\n    var c = 0,\n      d = 1,\n      e = a.z + a.w,\n      f = b.z + b.w,\n      g = -a.z + a.w,\n      h = -b.z + b.w;\n    if (0 <= e && 0 <= f && 0 <= g && 0 <= h) return !0;\n    if (0 > e && 0 > f || 0 > g && 0 > h) return !1;\n    0 > e ? c = Math.max(c, e / (e - f)) : 0 > f && (d = Math.min(d, e / (e - f)));\n    0 > g ? c = Math.max(c, g / (g - h)) : 0 > h && (d = Math.min(d, g / (g - h)));\n    if (d < c) return !1;\n    a.lerp(b, c);\n    b.lerp(a, 1 - d);\n    return !0;\n  }\n  var e,\n    f,\n    g = [],\n    h = 0,\n    i,\n    k,\n    l = [],\n    m = 0,\n    n,\n    s,\n    r = [],\n    p = 0,\n    q,\n    y = [],\n    v = 0,\n    z,\n    t,\n    A = [],\n    I = 0,\n    C,\n    x,\n    G = [],\n    J = 0,\n    E = {\n      objects: [],\n      sprites: [],\n      lights: [],\n      elements: []\n    },\n    H = new THREE.Vector3(),\n    B = new THREE.Vector4(),\n    W = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)),\n    F = new THREE.Box3(),\n    K = Array(3),\n    L = Array(4),\n    U = new THREE.Matrix4(),\n    fa = new THREE.Matrix4(),\n    Ca,\n    $a = new THREE.Matrix4(),\n    M = new THREE.Matrix3(),\n    ca = new THREE.Matrix3(),\n    qa = new THREE.Vector3(),\n    ha = new THREE.Frustum(),\n    ra = new THREE.Vector4(),\n    N = new THREE.Vector4();\n  this.projectVector = function (a, b) {\n    b.matrixWorldInverse.getInverse(b.matrixWorld);\n    fa.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);\n    return a.applyProjection(fa);\n  };\n  this.unprojectVector = function (a, b) {\n    b.projectionMatrixInverse.getInverse(b.projectionMatrix);\n    fa.multiplyMatrices(b.matrixWorld, b.projectionMatrixInverse);\n    return a.applyProjection(fa);\n  };\n  this.pickingRay = function (a, b) {\n    a.z = -1;\n    var c = new THREE.Vector3(a.x, a.y, 1);\n    this.unprojectVector(a, b);\n    this.unprojectVector(c, b);\n    c.sub(a).normalize();\n    return new THREE.Raycaster(a, c);\n  };\n  this.projectScene = function (g, h, m, Pa) {\n    var ta = !1,\n      ka,\n      aa,\n      pa,\n      Y,\n      da,\n      la,\n      Z,\n      oa,\n      gb,\n      nb,\n      ia,\n      Wa,\n      ab;\n    x = t = q = s = 0;\n    E.elements.length = 0;\n    g.updateMatrixWorld();\n    void 0 === h.parent && h.updateMatrixWorld();\n    U.copy(h.matrixWorldInverse.getInverse(h.matrixWorld));\n    fa.multiplyMatrices(h.projectionMatrix, U);\n    ca.getInverse(U);\n    ca.transpose();\n    ha.setFromMatrix(fa);\n    f = 0;\n    E.objects.length = 0;\n    E.sprites.length = 0;\n    E.lights.length = 0;\n    var Fa = function Fa(b) {\n      for (var c = 0, d = b.children.length; c < d; c++) {\n        var f = b.children[c];\n        if (!1 !== f.visible) {\n          if (f instanceof THREE.Light) E.lights.push(f);else if (f instanceof THREE.Mesh || f instanceof THREE.Line) {\n            if (!1 === f.frustumCulled || !0 === ha.intersectsObject(f)) e = a(), e.object = f, null !== f.renderDepth ? e.z = f.renderDepth : (H.getPositionFromMatrix(f.matrixWorld), H.applyProjection(fa), e.z = H.z), E.objects.push(e);\n          } else f instanceof THREE.Sprite || f instanceof THREE.Particle ? (e = a(), e.object = f, null !== f.renderDepth ? e.z = f.renderDepth : (H.getPositionFromMatrix(f.matrixWorld), H.applyProjection(fa), e.z = H.z), E.sprites.push(e)) : (e = a(), e.object = f, null !== f.renderDepth ? e.z = f.renderDepth : (H.getPositionFromMatrix(f.matrixWorld), H.applyProjection(fa), e.z = H.z), E.objects.push(e));\n          Fa(f);\n        }\n      }\n    };\n    Fa(g);\n    !0 === m && E.objects.sort(c);\n    g = 0;\n    for (m = E.objects.length; g < m; g++) if (oa = E.objects[g].object, Ca = oa.matrixWorld, k = 0, oa instanceof THREE.Mesh) {\n      gb = oa.geometry;\n      pa = gb.vertices;\n      nb = gb.faces;\n      gb = gb.faceVertexUvs;\n      M.getInverse(Ca);\n      M.transpose();\n      Wa = oa.material instanceof THREE.MeshFaceMaterial;\n      ab = !0 === Wa ? oa.material : null;\n      ka = 0;\n      for (aa = pa.length; ka < aa; ka++) i = b(), i.positionWorld.copy(pa[ka]).applyMatrix4(Ca), i.positionScreen.copy(i.positionWorld).applyMatrix4(fa), i.positionScreen.x /= i.positionScreen.w, i.positionScreen.y /= i.positionScreen.w, i.positionScreen.z /= i.positionScreen.w, i.visible = !(-1 > i.positionScreen.x || 1 < i.positionScreen.x || -1 > i.positionScreen.y || 1 < i.positionScreen.y || -1 > i.positionScreen.z || 1 < i.positionScreen.z);\n      pa = 0;\n      for (ka = nb.length; pa < ka; pa++) {\n        aa = nb[pa];\n        var Xa = !0 === Wa ? ab.materials[aa.materialIndex] : oa.material;\n        if (void 0 !== Xa) {\n          la = Xa.side;\n          if (aa instanceof THREE.Face3) {\n            if (Y = l[aa.a], da = l[aa.b], Z = l[aa.c], K[0] = Y.positionScreen, K[1] = da.positionScreen, K[2] = Z.positionScreen, !0 === Y.visible || !0 === da.visible || !0 === Z.visible || W.isIntersectionBox(F.setFromPoints(K))) {\n              if (ta = 0 > (Z.positionScreen.x - Y.positionScreen.x) * (da.positionScreen.y - Y.positionScreen.y) - (Z.positionScreen.y - Y.positionScreen.y) * (da.positionScreen.x - Y.positionScreen.x), la === THREE.DoubleSide || ta === (la === THREE.FrontSide)) s === p ? (ia = new THREE.RenderableFace3(), r.push(ia), p++, s++, n = ia) : n = r[s++], n.v1.copy(Y), n.v2.copy(da), n.v3.copy(Z);else continue;\n            } else continue;\n          } else if (aa instanceof THREE.Face4) if (Y = l[aa.a], da = l[aa.b], Z = l[aa.c], ia = l[aa.d], L[0] = Y.positionScreen, L[1] = da.positionScreen, L[2] = Z.positionScreen, L[3] = ia.positionScreen, !0 === Y.visible || !0 === da.visible || !0 === Z.visible || !0 === ia.visible || W.isIntersectionBox(F.setFromPoints(L))) {\n            if (ta = 0 > (ia.positionScreen.x - Y.positionScreen.x) * (da.positionScreen.y - Y.positionScreen.y) - (ia.positionScreen.y - Y.positionScreen.y) * (da.positionScreen.x - Y.positionScreen.x) || 0 > (da.positionScreen.x - Z.positionScreen.x) * (ia.positionScreen.y - Z.positionScreen.y) - (da.positionScreen.y - Z.positionScreen.y) * (ia.positionScreen.x - Z.positionScreen.x), la === THREE.DoubleSide || ta === (la === THREE.FrontSide)) {\n              if (q === v) {\n                var ub = new THREE.RenderableFace4();\n                y.push(ub);\n                v++;\n                q++;\n                n = ub;\n              } else n = y[q++];\n              n.v1.copy(Y);\n              n.v2.copy(da);\n              n.v3.copy(Z);\n              n.v4.copy(ia);\n            } else continue;\n          } else continue;\n          n.normalModel.copy(aa.normal);\n          !1 === ta && (la === THREE.BackSide || la === THREE.DoubleSide) && n.normalModel.negate();\n          n.normalModel.applyMatrix3(M).normalize();\n          n.normalModelView.copy(n.normalModel).applyMatrix3(ca);\n          n.centroidModel.copy(aa.centroid).applyMatrix4(Ca);\n          Z = aa.vertexNormals;\n          Y = 0;\n          for (da = Z.length; Y < da; Y++) ia = n.vertexNormalsModel[Y], ia.copy(Z[Y]), !1 === ta && (la === THREE.BackSide || la === THREE.DoubleSide) && ia.negate(), ia.applyMatrix3(M).normalize(), n.vertexNormalsModelView[Y].copy(ia).applyMatrix3(ca);\n          n.vertexNormalsLength = Z.length;\n          Y = 0;\n          for (da = gb.length; Y < da; Y++) if (ia = gb[Y][pa], void 0 !== ia) {\n            la = 0;\n            for (Z = ia.length; la < Z; la++) n.uvs[Y][la] = ia[la];\n          }\n          n.color = aa.color;\n          n.material = Xa;\n          qa.copy(n.centroidModel).applyProjection(fa);\n          n.z = qa.z;\n          E.elements.push(n);\n        }\n      }\n    } else if (oa instanceof THREE.Line) {\n      $a.multiplyMatrices(fa, Ca);\n      pa = oa.geometry.vertices;\n      Y = b();\n      Y.positionScreen.copy(pa[0]).applyMatrix4($a);\n      nb = oa.type === THREE.LinePieces ? 2 : 1;\n      ka = 1;\n      for (aa = pa.length; ka < aa; ka++) Y = b(), Y.positionScreen.copy(pa[ka]).applyMatrix4($a), 0 < (ka + 1) % nb || (da = l[k - 2], ra.copy(Y.positionScreen), N.copy(da.positionScreen), !0 === d(ra, N) && (ra.multiplyScalar(1 / ra.w), N.multiplyScalar(1 / N.w), t === I ? (gb = new THREE.RenderableLine(), A.push(gb), I++, t++, z = gb) : z = A[t++], z.v1.positionScreen.copy(ra), z.v2.positionScreen.copy(N), z.z = Math.max(ra.z, N.z), z.material = oa.material, E.elements.push(z)));\n    }\n    g = 0;\n    for (m = E.sprites.length; g < m; g++) oa = E.sprites[g].object, Ca = oa.matrixWorld, oa instanceof THREE.Particle && (B.set(Ca.elements[12], Ca.elements[13], Ca.elements[14], 1), B.applyMatrix4(fa), B.z /= B.w, 0 < B.z && 1 > B.z && (x === J ? (ta = new THREE.RenderableParticle(), G.push(ta), J++, x++, C = ta) : C = G[x++], C.object = oa, C.x = B.x / B.w, C.y = B.y / B.w, C.z = B.z, C.rotation = oa.rotation.z, C.scale.x = oa.scale.x * Math.abs(C.x - (B.x + h.projectionMatrix.elements[0]) / (B.w + h.projectionMatrix.elements[12])), C.scale.y = oa.scale.y * Math.abs(C.y - (B.y + h.projectionMatrix.elements[5]) / (B.w + h.projectionMatrix.elements[13])), C.material = oa.material, E.elements.push(C)));\n    !0 === Pa && E.elements.sort(c);\n    return E;\n  };\n};\nTHREE.Face3 = function (a, b, c, d, e, f) {\n  this.a = a;\n  this.b = b;\n  this.c = c;\n  this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3();\n  this.vertexNormals = d instanceof Array ? d : [];\n  this.color = e instanceof THREE.Color ? e : new THREE.Color();\n  this.vertexColors = e instanceof Array ? e : [];\n  this.vertexTangents = [];\n  this.materialIndex = void 0 !== f ? f : 0;\n  this.centroid = new THREE.Vector3();\n};\nTHREE.Face3.prototype = {\n  constructor: THREE.Face3,\n  clone: function clone() {\n    var a = new THREE.Face3(this.a, this.b, this.c);\n    a.normal.copy(this.normal);\n    a.color.copy(this.color);\n    a.centroid.copy(this.centroid);\n    a.materialIndex = this.materialIndex;\n    var b, c;\n    b = 0;\n    for (c = this.vertexNormals.length; b < c; b++) a.vertexNormals[b] = this.vertexNormals[b].clone();\n    b = 0;\n    for (c = this.vertexColors.length; b < c; b++) a.vertexColors[b] = this.vertexColors[b].clone();\n    b = 0;\n    for (c = this.vertexTangents.length; b < c; b++) a.vertexTangents[b] = this.vertexTangents[b].clone();\n    return a;\n  }\n};\nTHREE.Face4 = function (a, b, c, d, e, f, g) {\n  this.a = a;\n  this.b = b;\n  this.c = c;\n  this.d = d;\n  this.normal = e instanceof THREE.Vector3 ? e : new THREE.Vector3();\n  this.vertexNormals = e instanceof Array ? e : [];\n  this.color = f instanceof THREE.Color ? f : new THREE.Color();\n  this.vertexColors = f instanceof Array ? f : [];\n  this.vertexTangents = [];\n  this.materialIndex = void 0 !== g ? g : 0;\n  this.centroid = new THREE.Vector3();\n};\nTHREE.Face4.prototype = {\n  constructor: THREE.Face4,\n  clone: function clone() {\n    var a = new THREE.Face4(this.a, this.b, this.c, this.d);\n    a.normal.copy(this.normal);\n    a.color.copy(this.color);\n    a.centroid.copy(this.centroid);\n    a.materialIndex = this.materialIndex;\n    var b, c;\n    b = 0;\n    for (c = this.vertexNormals.length; b < c; b++) a.vertexNormals[b] = this.vertexNormals[b].clone();\n    b = 0;\n    for (c = this.vertexColors.length; b < c; b++) a.vertexColors[b] = this.vertexColors[b].clone();\n    b = 0;\n    for (c = this.vertexTangents.length; b < c; b++) a.vertexTangents[b] = this.vertexTangents[b].clone();\n    return a;\n  }\n};\nTHREE.Geometry = function () {\n  THREE.EventDispatcher.call(this);\n  this.id = THREE.GeometryIdCount++;\n  this.name = \"\";\n  this.vertices = [];\n  this.colors = [];\n  this.normals = [];\n  this.faces = [];\n  this.faceUvs = [[]];\n  this.faceVertexUvs = [[]];\n  this.morphTargets = [];\n  this.morphColors = [];\n  this.morphNormals = [];\n  this.skinWeights = [];\n  this.skinIndices = [];\n  this.lineDistances = [];\n  this.boundingSphere = this.boundingBox = null;\n  this.hasTangents = !1;\n  this.dynamic = !0;\n  this.buffersNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1;\n};\nTHREE.Geometry.prototype = {\n  constructor: THREE.Geometry,\n  applyMatrix: function applyMatrix(a) {\n    for (var b = new THREE.Matrix3().getInverse(a).transpose(), c = 0, d = this.vertices.length; c < d; c++) this.vertices[c].applyMatrix4(a);\n    c = 0;\n    for (d = this.faces.length; c < d; c++) {\n      var e = this.faces[c];\n      e.normal.applyMatrix3(b).normalize();\n      for (var f = 0, g = e.vertexNormals.length; f < g; f++) e.vertexNormals[f].applyMatrix3(b).normalize();\n      e.centroid.applyMatrix4(a);\n    }\n  },\n  computeCentroids: function computeCentroids() {\n    var a, b, c;\n    a = 0;\n    for (b = this.faces.length; a < b; a++) c = this.faces[a], c.centroid.set(0, 0, 0), c instanceof THREE.Face3 ? (c.centroid.add(this.vertices[c.a]), c.centroid.add(this.vertices[c.b]), c.centroid.add(this.vertices[c.c]), c.centroid.divideScalar(3)) : c instanceof THREE.Face4 && (c.centroid.add(this.vertices[c.a]), c.centroid.add(this.vertices[c.b]), c.centroid.add(this.vertices[c.c]), c.centroid.add(this.vertices[c.d]), c.centroid.divideScalar(4));\n  },\n  computeFaceNormals: function computeFaceNormals() {\n    for (var a = new THREE.Vector3(), b = new THREE.Vector3(), c = 0, d = this.faces.length; c < d; c++) {\n      var e = this.faces[c],\n        f = this.vertices[e.a],\n        g = this.vertices[e.b];\n      a.subVectors(this.vertices[e.c], g);\n      b.subVectors(f, g);\n      a.cross(b);\n      a.normalize();\n      e.normal.copy(a);\n    }\n  },\n  computeVertexNormals: function computeVertexNormals(a) {\n    var b, c, d, e;\n    if (void 0 === this.__tmpVertices) {\n      e = this.__tmpVertices = Array(this.vertices.length);\n      b = 0;\n      for (c = this.vertices.length; b < c; b++) e[b] = new THREE.Vector3();\n      b = 0;\n      for (c = this.faces.length; b < c; b++) d = this.faces[b], d instanceof THREE.Face3 ? d.vertexNormals = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()] : d instanceof THREE.Face4 && (d.vertexNormals = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()]);\n    } else {\n      e = this.__tmpVertices;\n      b = 0;\n      for (c = this.vertices.length; b < c; b++) e[b].set(0, 0, 0);\n    }\n    if (a) {\n      var f,\n        g,\n        h,\n        i = new THREE.Vector3(),\n        k = new THREE.Vector3(),\n        l = new THREE.Vector3(),\n        m = new THREE.Vector3(),\n        n = new THREE.Vector3();\n      b = 0;\n      for (c = this.faces.length; b < c; b++) d = this.faces[b], d instanceof THREE.Face3 ? (a = this.vertices[d.a], f = this.vertices[d.b], g = this.vertices[d.c], i.subVectors(g, f), k.subVectors(a, f), i.cross(k), e[d.a].add(i), e[d.b].add(i), e[d.c].add(i)) : d instanceof THREE.Face4 && (a = this.vertices[d.a], f = this.vertices[d.b], g = this.vertices[d.c], h = this.vertices[d.d], l.subVectors(h, f), k.subVectors(a, f), l.cross(k), e[d.a].add(l), e[d.b].add(l), e[d.d].add(l), m.subVectors(h, g), n.subVectors(f, g), m.cross(n), e[d.b].add(m), e[d.c].add(m), e[d.d].add(m));\n    } else {\n      b = 0;\n      for (c = this.faces.length; b < c; b++) d = this.faces[b], d instanceof THREE.Face3 ? (e[d.a].add(d.normal), e[d.b].add(d.normal), e[d.c].add(d.normal)) : d instanceof THREE.Face4 && (e[d.a].add(d.normal), e[d.b].add(d.normal), e[d.c].add(d.normal), e[d.d].add(d.normal));\n    }\n    b = 0;\n    for (c = this.vertices.length; b < c; b++) e[b].normalize();\n    b = 0;\n    for (c = this.faces.length; b < c; b++) d = this.faces[b], d instanceof THREE.Face3 ? (d.vertexNormals[0].copy(e[d.a]), d.vertexNormals[1].copy(e[d.b]), d.vertexNormals[2].copy(e[d.c])) : d instanceof THREE.Face4 && (d.vertexNormals[0].copy(e[d.a]), d.vertexNormals[1].copy(e[d.b]), d.vertexNormals[2].copy(e[d.c]), d.vertexNormals[3].copy(e[d.d]));\n  },\n  computeMorphNormals: function computeMorphNormals() {\n    var a, b, c, d, e;\n    c = 0;\n    for (d = this.faces.length; c < d; c++) {\n      e = this.faces[c];\n      e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone();\n      e.__originalVertexNormals || (e.__originalVertexNormals = []);\n      a = 0;\n      for (b = e.vertexNormals.length; a < b; a++) e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();\n    }\n    var f = new THREE.Geometry();\n    f.faces = this.faces;\n    a = 0;\n    for (b = this.morphTargets.length; a < b; a++) {\n      if (!this.morphNormals[a]) {\n        this.morphNormals[a] = {};\n        this.morphNormals[a].faceNormals = [];\n        this.morphNormals[a].vertexNormals = [];\n        var g = this.morphNormals[a].faceNormals,\n          h = this.morphNormals[a].vertexNormals,\n          i,\n          k;\n        c = 0;\n        for (d = this.faces.length; c < d; c++) e = this.faces[c], i = new THREE.Vector3(), k = e instanceof THREE.Face3 ? {\n          a: new THREE.Vector3(),\n          b: new THREE.Vector3(),\n          c: new THREE.Vector3()\n        } : {\n          a: new THREE.Vector3(),\n          b: new THREE.Vector3(),\n          c: new THREE.Vector3(),\n          d: new THREE.Vector3()\n        }, g.push(i), h.push(k);\n      }\n      g = this.morphNormals[a];\n      f.vertices = this.morphTargets[a].vertices;\n      f.computeFaceNormals();\n      f.computeVertexNormals();\n      c = 0;\n      for (d = this.faces.length; c < d; c++) e = this.faces[c], i = g.faceNormals[c], k = g.vertexNormals[c], i.copy(e.normal), e instanceof THREE.Face3 ? (k.a.copy(e.vertexNormals[0]), k.b.copy(e.vertexNormals[1]), k.c.copy(e.vertexNormals[2])) : (k.a.copy(e.vertexNormals[0]), k.b.copy(e.vertexNormals[1]), k.c.copy(e.vertexNormals[2]), k.d.copy(e.vertexNormals[3]));\n    }\n    c = 0;\n    for (d = this.faces.length; c < d; c++) e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals;\n  },\n  computeTangents: function computeTangents() {\n    function a(a, b, c, d, e, f, x) {\n      h = a.vertices[b];\n      i = a.vertices[c];\n      k = a.vertices[d];\n      l = g[e];\n      m = g[f];\n      n = g[x];\n      s = i.x - h.x;\n      r = k.x - h.x;\n      p = i.y - h.y;\n      q = k.y - h.y;\n      y = i.z - h.z;\n      v = k.z - h.z;\n      z = m.x - l.x;\n      t = n.x - l.x;\n      A = m.y - l.y;\n      I = n.y - l.y;\n      C = 1 / (z * I - t * A);\n      E.set((I * s - A * r) * C, (I * p - A * q) * C, (I * y - A * v) * C);\n      H.set((z * r - t * s) * C, (z * q - t * p) * C, (z * v - t * y) * C);\n      G[b].add(E);\n      G[c].add(E);\n      G[d].add(E);\n      J[b].add(H);\n      J[c].add(H);\n      J[d].add(H);\n    }\n    var b,\n      c,\n      d,\n      e,\n      f,\n      g,\n      h,\n      i,\n      k,\n      l,\n      m,\n      n,\n      s,\n      r,\n      p,\n      q,\n      y,\n      v,\n      z,\n      t,\n      A,\n      I,\n      C,\n      x,\n      G = [],\n      J = [],\n      E = new THREE.Vector3(),\n      H = new THREE.Vector3(),\n      B = new THREE.Vector3(),\n      W = new THREE.Vector3(),\n      F = new THREE.Vector3();\n    b = 0;\n    for (c = this.vertices.length; b < c; b++) G[b] = new THREE.Vector3(), J[b] = new THREE.Vector3();\n    b = 0;\n    for (c = this.faces.length; b < c; b++) f = this.faces[b], g = this.faceVertexUvs[0][b], f instanceof THREE.Face3 ? a(this, f.a, f.b, f.c, 0, 1, 2) : f instanceof THREE.Face4 && (a(this, f.a, f.b, f.d, 0, 1, 3), a(this, f.b, f.c, f.d, 1, 2, 3));\n    var K = [\"a\", \"b\", \"c\", \"d\"];\n    b = 0;\n    for (c = this.faces.length; b < c; b++) {\n      f = this.faces[b];\n      for (d = 0; d < f.vertexNormals.length; d++) F.copy(f.vertexNormals[d]), e = f[K[d]], x = G[e], B.copy(x), B.sub(F.multiplyScalar(F.dot(x))).normalize(), W.crossVectors(f.vertexNormals[d], x), e = W.dot(J[e]), e = 0 > e ? -1 : 1, f.vertexTangents[d] = new THREE.Vector4(B.x, B.y, B.z, e);\n    }\n    this.hasTangents = !0;\n  },\n  computeLineDistances: function computeLineDistances() {\n    for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++) 0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a;\n  },\n  computeBoundingBox: function computeBoundingBox() {\n    null === this.boundingBox && (this.boundingBox = new THREE.Box3());\n    this.boundingBox.setFromPoints(this.vertices);\n  },\n  computeBoundingSphere: function computeBoundingSphere() {\n    null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere());\n    this.boundingSphere.setFromCenterAndPoints(this.boundingSphere.center, this.vertices);\n  },\n  mergeVertices: function mergeVertices() {\n    var a = {},\n      b = [],\n      c = [],\n      d,\n      e = Math.pow(10, 4),\n      f,\n      g,\n      h,\n      i,\n      k;\n    this.__tmpVertices = void 0;\n    f = 0;\n    for (g = this.vertices.length; f < g; f++) d = this.vertices[f], d = [Math.round(d.x * e), Math.round(d.y * e), Math.round(d.z * e)].join(\"_\"), void 0 === a[d] ? (a[d] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[d]];\n    e = [];\n    f = 0;\n    for (g = this.faces.length; f < g; f++) if (a = this.faces[f], a instanceof THREE.Face3) {\n      a.a = c[a.a];\n      a.b = c[a.b];\n      a.c = c[a.c];\n      h = [a.a, a.b, a.c];\n      d = -1;\n      for (i = 0; 3 > i; i++) if (h[i] == h[(i + 1) % 3]) {\n        e.push(f);\n        break;\n      }\n    } else if (a instanceof THREE.Face4) {\n      a.a = c[a.a];\n      a.b = c[a.b];\n      a.c = c[a.c];\n      a.d = c[a.d];\n      h = [a.a, a.b, a.c, a.d];\n      d = -1;\n      for (i = 0; 4 > i; i++) h[i] == h[(i + 1) % 4] && (0 <= d && e.push(f), d = i);\n      if (0 <= d) {\n        h.splice(d, 1);\n        var l = new THREE.Face3(h[0], h[1], h[2], a.normal, a.color, a.materialIndex);\n        h = 0;\n        for (i = this.faceVertexUvs.length; h < i; h++) (k = this.faceVertexUvs[h][f]) && k.splice(d, 1);\n        a.vertexNormals && 0 < a.vertexNormals.length && (l.vertexNormals = a.vertexNormals, l.vertexNormals.splice(d, 1));\n        a.vertexColors && 0 < a.vertexColors.length && (l.vertexColors = a.vertexColors, l.vertexColors.splice(d, 1));\n        this.faces[f] = l;\n      }\n    }\n    for (f = e.length - 1; 0 <= f; f--) {\n      this.faces.splice(f, 1);\n      h = 0;\n      for (i = this.faceVertexUvs.length; h < i; h++) this.faceVertexUvs[h].splice(f, 1);\n    }\n    c = this.vertices.length - b.length;\n    this.vertices = b;\n    return c;\n  },\n  clone: function clone() {\n    for (var a = new THREE.Geometry(), b = this.vertices, c = 0, d = b.length; c < d; c++) a.vertices.push(b[c].clone());\n    b = this.faces;\n    c = 0;\n    for (d = b.length; c < d; c++) a.faces.push(b[c].clone());\n    b = this.faceVertexUvs[0];\n    c = 0;\n    for (d = b.length; c < d; c++) {\n      for (var e = b[c], f = [], g = 0, h = e.length; g < h; g++) f.push(new THREE.Vector2(e[g].x, e[g].y));\n      a.faceVertexUvs[0].push(f);\n    }\n    return a;\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: \"dispose\"\n    });\n  }\n};\nTHREE.GeometryIdCount = 0;\nTHREE.BufferGeometry = function () {\n  THREE.EventDispatcher.call(this);\n  this.id = THREE.GeometryIdCount++;\n  this.attributes = {};\n  this.dynamic = !1;\n  this.offsets = [];\n  this.boundingSphere = this.boundingBox = null;\n  this.hasTangents = !1;\n  this.morphTargets = [];\n};\nTHREE.BufferGeometry.prototype = {\n  constructor: THREE.BufferGeometry,\n  applyMatrix: function applyMatrix(a) {\n    var b, c;\n    this.attributes.position && (b = this.attributes.position.array);\n    this.attributes.normal && (c = this.attributes.normal.array);\n    void 0 !== b && (a.multiplyVector3Array(b), this.verticesNeedUpdate = !0);\n    void 0 !== c && (b = new THREE.Matrix3(), b.getInverse(a).transpose(), b.multiplyVector3Array(c), this.normalizeNormals(), this.normalsNeedUpdate = !0);\n  },\n  computeBoundingBox: function computeBoundingBox() {\n    null === this.boundingBox && (this.boundingBox = new THREE.Box3());\n    var a = this.attributes.position.array;\n    if (a) {\n      var b = this.boundingBox,\n        c,\n        d,\n        e;\n      3 <= a.length && (b.min.x = b.max.x = a[0], b.min.y = b.max.y = a[1], b.min.z = b.max.z = a[2]);\n      for (var f = 3, g = a.length; f < g; f += 3) c = a[f], d = a[f + 1], e = a[f + 2], c < b.min.x ? b.min.x = c : c > b.max.x && (b.max.x = c), d < b.min.y ? b.min.y = d : d > b.max.y && (b.max.y = d), e < b.min.z ? b.min.z = e : e > b.max.z && (b.max.z = e);\n    }\n    if (void 0 === a || 0 === a.length) this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0);\n  },\n  computeBoundingSphere: function computeBoundingSphere() {\n    null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere());\n    var a = this.attributes.position.array;\n    if (a) {\n      for (var b, c = 0, d, e, f = 0, g = a.length; f < g; f += 3) b = a[f], d = a[f + 1], e = a[f + 2], b = b * b + d * d + e * e, b > c && (c = b);\n      this.boundingSphere.radius = Math.sqrt(c);\n    }\n  },\n  computeVertexNormals: function computeVertexNormals() {\n    if (this.attributes.position) {\n      var a, b, c, d;\n      a = this.attributes.position.array.length;\n      if (void 0 === this.attributes.normal) this.attributes.normal = {\n        itemSize: 3,\n        array: new Float32Array(a),\n        numItems: a\n      };else {\n        a = 0;\n        for (b = this.attributes.normal.array.length; a < b; a++) this.attributes.normal.array[a] = 0;\n      }\n      var e = this.attributes.position.array,\n        f = this.attributes.normal.array,\n        g,\n        h,\n        i,\n        k,\n        l,\n        m,\n        n = new THREE.Vector3(),\n        s = new THREE.Vector3(),\n        r = new THREE.Vector3(),\n        p = new THREE.Vector3(),\n        q = new THREE.Vector3();\n      if (this.attributes.index) {\n        var y = this.attributes.index.array,\n          v = this.offsets;\n        c = 0;\n        for (d = v.length; c < d; ++c) {\n          b = v[c].start;\n          g = v[c].count;\n          var z = v[c].index;\n          a = b;\n          for (b += g; a < b; a += 3) g = z + y[a], h = z + y[a + 1], i = z + y[a + 2], k = e[3 * g], l = e[3 * g + 1], m = e[3 * g + 2], n.set(k, l, m), k = e[3 * h], l = e[3 * h + 1], m = e[3 * h + 2], s.set(k, l, m), k = e[3 * i], l = e[3 * i + 1], m = e[3 * i + 2], r.set(k, l, m), p.subVectors(r, s), q.subVectors(n, s), p.cross(q), f[3 * g] += p.x, f[3 * g + 1] += p.y, f[3 * g + 2] += p.z, f[3 * h] += p.x, f[3 * h + 1] += p.y, f[3 * h + 2] += p.z, f[3 * i] += p.x, f[3 * i + 1] += p.y, f[3 * i + 2] += p.z;\n        }\n      } else {\n        a = 0;\n        for (b = e.length; a < b; a += 9) k = e[a], l = e[a + 1], m = e[a + 2], n.set(k, l, m), k = e[a + 3], l = e[a + 4], m = e[a + 5], s.set(k, l, m), k = e[a + 6], l = e[a + 7], m = e[a + 8], r.set(k, l, m), p.subVectors(r, s), q.subVectors(n, s), p.cross(q), f[a] = p.x, f[a + 1] = p.y, f[a + 2] = p.z, f[a + 3] = p.x, f[a + 4] = p.y, f[a + 5] = p.z, f[a + 6] = p.x, f[a + 7] = p.y, f[a + 8] = p.z;\n      }\n      this.normalizeNormals();\n      this.normalsNeedUpdate = !0;\n    }\n  },\n  normalizeNormals: function normalizeNormals() {\n    for (var a = this.attributes.normal.array, b, c, d, e = 0, f = a.length; e < f; e += 3) b = a[e], c = a[e + 1], d = a[e + 2], b = 1 / Math.sqrt(b * b + c * c + d * d), a[e] *= b, a[e + 1] *= b, a[e + 2] *= b;\n  },\n  computeTangents: function computeTangents() {\n    function a(a) {\n      Ca.x = d[3 * a];\n      Ca.y = d[3 * a + 1];\n      Ca.z = d[3 * a + 2];\n      $a.copy(Ca);\n      ca = i[a];\n      U.copy(ca);\n      U.sub(Ca.multiplyScalar(Ca.dot(ca))).normalize();\n      fa.crossVectors($a, ca);\n      qa = fa.dot(k[a]);\n      M = 0 > qa ? -1 : 1;\n      h[4 * a] = U.x;\n      h[4 * a + 1] = U.y;\n      h[4 * a + 2] = U.z;\n      h[4 * a + 3] = M;\n    }\n    if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv) console.warn(\"Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()\");else {\n      var b = this.attributes.index.array,\n        c = this.attributes.position.array,\n        d = this.attributes.normal.array,\n        e = this.attributes.uv.array,\n        f = c.length / 3;\n      if (void 0 === this.attributes.tangent) {\n        var g = 4 * f;\n        this.attributes.tangent = {\n          itemSize: 4,\n          array: new Float32Array(g),\n          numItems: g\n        };\n      }\n      for (var h = this.attributes.tangent.array, i = [], k = [], g = 0; g < f; g++) i[g] = new THREE.Vector3(), k[g] = new THREE.Vector3();\n      var l,\n        m,\n        n,\n        s,\n        r,\n        p,\n        q,\n        y,\n        v,\n        z,\n        t,\n        A,\n        I,\n        C,\n        x,\n        f = new THREE.Vector3(),\n        g = new THREE.Vector3(),\n        G,\n        J,\n        E,\n        H,\n        B,\n        W,\n        F,\n        K = this.offsets;\n      E = 0;\n      for (H = K.length; E < H; ++E) {\n        J = K[E].start;\n        B = K[E].count;\n        var L = K[E].index;\n        G = J;\n        for (J += B; G < J; G += 3) B = L + b[G], W = L + b[G + 1], F = L + b[G + 2], l = c[3 * B], m = c[3 * B + 1], n = c[3 * B + 2], s = c[3 * W], r = c[3 * W + 1], p = c[3 * W + 2], q = c[3 * F], y = c[3 * F + 1], v = c[3 * F + 2], z = e[2 * B], t = e[2 * B + 1], A = e[2 * W], I = e[2 * W + 1], C = e[2 * F], x = e[2 * F + 1], s -= l, l = q - l, r -= m, m = y - m, p -= n, n = v - n, A -= z, z = C - z, I -= t, t = x - t, x = 1 / (A * t - z * I), f.set((t * s - I * l) * x, (t * r - I * m) * x, (t * p - I * n) * x), g.set((A * l - z * s) * x, (A * m - z * r) * x, (A * n - z * p) * x), i[B].add(f), i[W].add(f), i[F].add(f), k[B].add(g), k[W].add(g), k[F].add(g);\n      }\n      var U = new THREE.Vector3(),\n        fa = new THREE.Vector3(),\n        Ca = new THREE.Vector3(),\n        $a = new THREE.Vector3(),\n        M,\n        ca,\n        qa;\n      E = 0;\n      for (H = K.length; E < H; ++E) {\n        J = K[E].start;\n        B = K[E].count;\n        L = K[E].index;\n        G = J;\n        for (J += B; G < J; G += 3) B = L + b[G], W = L + b[G + 1], F = L + b[G + 2], a(B), a(W), a(F);\n      }\n      this.tangentsNeedUpdate = this.hasTangents = !0;\n    }\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: \"dispose\"\n    });\n  }\n};\nTHREE.Camera = function () {\n  THREE.Object3D.call(this);\n  this.matrixWorldInverse = new THREE.Matrix4();\n  this.projectionMatrix = new THREE.Matrix4();\n  this.projectionMatrixInverse = new THREE.Matrix4();\n};\nTHREE.Camera.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Camera.prototype.lookAt = function (a) {\n  this.matrix.lookAt(this.position, a, this.up);\n  !0 === this.rotationAutoUpdate && (!1 === this.useQuaternion ? this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder) : this.quaternion.copy(this.matrix.decompose()[1]));\n};\nTHREE.OrthographicCamera = function (a, b, c, d, e, f) {\n  THREE.Camera.call(this);\n  this.left = a;\n  this.right = b;\n  this.top = c;\n  this.bottom = d;\n  this.near = void 0 !== e ? e : 0.1;\n  this.far = void 0 !== f ? f : 2E3;\n  this.updateProjectionMatrix();\n};\nTHREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\n  this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far);\n};\nTHREE.PerspectiveCamera = function (a, b, c, d) {\n  THREE.Camera.call(this);\n  this.fov = void 0 !== a ? a : 50;\n  this.aspect = void 0 !== b ? b : 1;\n  this.near = void 0 !== c ? c : 0.1;\n  this.far = void 0 !== d ? d : 2E3;\n  this.updateProjectionMatrix();\n};\nTHREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);\nTHREE.PerspectiveCamera.prototype.setLens = function (a, b) {\n  void 0 === b && (b = 24);\n  this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));\n  this.updateProjectionMatrix();\n};\nTHREE.PerspectiveCamera.prototype.setViewOffset = function (a, b, c, d, e, f) {\n  this.fullWidth = a;\n  this.fullHeight = b;\n  this.x = c;\n  this.y = d;\n  this.width = e;\n  this.height = f;\n  this.updateProjectionMatrix();\n};\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\n  if (this.fullWidth) {\n    var a = this.fullWidth / this.fullHeight,\n      b = Math.tan(THREE.Math.degToRad(0.5 * this.fov)) * this.near,\n      c = -b,\n      d = a * c,\n      a = Math.abs(a * b - d),\n      c = Math.abs(b - c);\n    this.projectionMatrix.makeFrustum(d + this.x * a / this.fullWidth, d + (this.x + this.width) * a / this.fullWidth, b - (this.y + this.height) * c / this.fullHeight, b - this.y * c / this.fullHeight, this.near, this.far);\n  } else this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far);\n};\nTHREE.Light = function (a) {\n  THREE.Object3D.call(this);\n  this.color = new THREE.Color(a);\n};\nTHREE.Light.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.AmbientLight = function (a) {\n  THREE.Light.call(this, a);\n};\nTHREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);\nTHREE.AreaLight = function (a, b) {\n  THREE.Light.call(this, a);\n  this.normal = new THREE.Vector3(0, -1, 0);\n  this.right = new THREE.Vector3(1, 0, 0);\n  this.intensity = void 0 !== b ? b : 1;\n  this.height = this.width = 1;\n  this.constantAttenuation = 1.5;\n  this.linearAttenuation = 0.5;\n  this.quadraticAttenuation = 0.1;\n};\nTHREE.AreaLight.prototype = Object.create(THREE.Light.prototype);\nTHREE.DirectionalLight = function (a, b) {\n  THREE.Light.call(this, a);\n  this.position = new THREE.Vector3(0, 1, 0);\n  this.target = new THREE.Object3D();\n  this.intensity = void 0 !== b ? b : 1;\n  this.onlyShadow = this.castShadow = !1;\n  this.shadowCameraNear = 50;\n  this.shadowCameraFar = 5E3;\n  this.shadowCameraLeft = -500;\n  this.shadowCameraTop = this.shadowCameraRight = 500;\n  this.shadowCameraBottom = -500;\n  this.shadowCameraVisible = !1;\n  this.shadowBias = 0;\n  this.shadowDarkness = 0.5;\n  this.shadowMapHeight = this.shadowMapWidth = 512;\n  this.shadowCascade = !1;\n  this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1E3);\n  this.shadowCascadeCount = 2;\n  this.shadowCascadeBias = [0, 0, 0];\n  this.shadowCascadeWidth = [512, 512, 512];\n  this.shadowCascadeHeight = [512, 512, 512];\n  this.shadowCascadeNearZ = [-1, 0.99, 0.998];\n  this.shadowCascadeFarZ = [0.99, 0.998, 1];\n  this.shadowCascadeArray = [];\n  this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;\n};\nTHREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);\nTHREE.HemisphereLight = function (a, b, c) {\n  THREE.Light.call(this, a);\n  this.groundColor = new THREE.Color(b);\n  this.position = new THREE.Vector3(0, 100, 0);\n  this.intensity = void 0 !== c ? c : 1;\n};\nTHREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);\nTHREE.PointLight = function (a, b, c) {\n  THREE.Light.call(this, a);\n  this.position = new THREE.Vector3(0, 0, 0);\n  this.intensity = void 0 !== b ? b : 1;\n  this.distance = void 0 !== c ? c : 0;\n};\nTHREE.PointLight.prototype = Object.create(THREE.Light.prototype);\nTHREE.SpotLight = function (a, b, c, d, e) {\n  THREE.Light.call(this, a);\n  this.position = new THREE.Vector3(0, 1, 0);\n  this.target = new THREE.Object3D();\n  this.intensity = void 0 !== b ? b : 1;\n  this.distance = void 0 !== c ? c : 0;\n  this.angle = void 0 !== d ? d : Math.PI / 2;\n  this.exponent = void 0 !== e ? e : 10;\n  this.onlyShadow = this.castShadow = !1;\n  this.shadowCameraNear = 50;\n  this.shadowCameraFar = 5E3;\n  this.shadowCameraFov = 50;\n  this.shadowCameraVisible = !1;\n  this.shadowBias = 0;\n  this.shadowDarkness = 0.5;\n  this.shadowMapHeight = this.shadowMapWidth = 512;\n  this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;\n};\nTHREE.SpotLight.prototype = Object.create(THREE.Light.prototype);\nTHREE.Loader = function (a) {\n  this.statusDomElement = (this.showStatus = a) ? THREE.Loader.prototype.addStatusElement() : null;\n  this.onLoadStart = function () {};\n  this.onLoadProgress = function () {};\n  this.onLoadComplete = function () {};\n};\nTHREE.Loader.prototype = {\n  constructor: THREE.Loader,\n  crossOrigin: \"anonymous\",\n  addStatusElement: function addStatusElement() {\n    var a = document.createElement(\"div\");\n    a.style.position = \"absolute\";\n    a.style.right = \"0px\";\n    a.style.top = \"0px\";\n    a.style.fontSize = \"0.8em\";\n    a.style.textAlign = \"left\";\n    a.style.background = \"rgba(0,0,0,0.25)\";\n    a.style.color = \"#fff\";\n    a.style.width = \"120px\";\n    a.style.padding = \"0.5em 0.5em 0.5em 0.5em\";\n    a.style.zIndex = 1E3;\n    a.innerHTML = \"Loading ...\";\n    return a;\n  },\n  updateProgress: function updateProgress(a) {\n    var b = \"Loaded \",\n      b = a.total ? b + ((100 * a.loaded / a.total).toFixed(0) + \"%\") : b + ((a.loaded / 1E3).toFixed(2) + \" KB\");\n    this.statusDomElement.innerHTML = b;\n  },\n  extractUrlBase: function extractUrlBase(a) {\n    a = a.split(\"/\");\n    a.pop();\n    return (1 > a.length ? \".\" : a.join(\"/\")) + \"/\";\n  },\n  initMaterials: function initMaterials(a, b) {\n    for (var c = [], d = 0; d < a.length; ++d) c[d] = THREE.Loader.prototype.createMaterial(a[d], b);\n    return c;\n  },\n  needsTangents: function needsTangents(a) {\n    for (var b = 0, c = a.length; b < c; b++) if (a[b] instanceof THREE.ShaderMaterial) return !0;\n    return !1;\n  },\n  createMaterial: function createMaterial(a, b) {\n    function c(a) {\n      a = Math.log(a) / Math.LN2;\n      return Math.floor(a) == a;\n    }\n    function d(a) {\n      a = Math.log(a) / Math.LN2;\n      return Math.pow(2, Math.round(a));\n    }\n    function e(a, e, f, h, i, k, q) {\n      var y = /\\.dds$/i.test(f),\n        v = b + \"/\" + f;\n      if (y) {\n        var z = THREE.ImageUtils.loadCompressedTexture(v);\n        a[e] = z;\n      } else z = document.createElement(\"canvas\"), a[e] = new THREE.Texture(z);\n      a[e].sourceFile = f;\n      h && (a[e].repeat.set(h[0], h[1]), 1 !== h[0] && (a[e].wrapS = THREE.RepeatWrapping), 1 !== h[1] && (a[e].wrapT = THREE.RepeatWrapping));\n      i && a[e].offset.set(i[0], i[1]);\n      k && (f = {\n        repeat: THREE.RepeatWrapping,\n        mirror: THREE.MirroredRepeatWrapping\n      }, void 0 !== f[k[0]] && (a[e].wrapS = f[k[0]]), void 0 !== f[k[1]] && (a[e].wrapT = f[k[1]]));\n      q && (a[e].anisotropy = q);\n      if (!y) {\n        var t = a[e],\n          a = new Image();\n        a.onload = function () {\n          if (!c(this.width) || !c(this.height)) {\n            var a = d(this.width),\n              b = d(this.height);\n            t.image.width = a;\n            t.image.height = b;\n            t.image.getContext(\"2d\").drawImage(this, 0, 0, a, b);\n          } else t.image = this;\n          t.needsUpdate = !0;\n        };\n        a.crossOrigin = g.crossOrigin;\n        a.src = v;\n      }\n    }\n    function f(a) {\n      return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2];\n    }\n    var g = this,\n      h = \"MeshLambertMaterial\",\n      i = {\n        color: 15658734,\n        opacity: 1,\n        map: null,\n        lightMap: null,\n        normalMap: null,\n        bumpMap: null,\n        wireframe: !1\n      };\n    if (a.shading) {\n      var k = a.shading.toLowerCase();\n      \"phong\" === k ? h = \"MeshPhongMaterial\" : \"basic\" === k && (h = \"MeshBasicMaterial\");\n    }\n    void 0 !== a.blending && void 0 !== THREE[a.blending] && (i.blending = THREE[a.blending]);\n    if (void 0 !== a.transparent || 1 > a.opacity) i.transparent = a.transparent;\n    void 0 !== a.depthTest && (i.depthTest = a.depthTest);\n    void 0 !== a.depthWrite && (i.depthWrite = a.depthWrite);\n    void 0 !== a.visible && (i.visible = a.visible);\n    void 0 !== a.flipSided && (i.side = THREE.BackSide);\n    void 0 !== a.doubleSided && (i.side = THREE.DoubleSide);\n    void 0 !== a.wireframe && (i.wireframe = a.wireframe);\n    void 0 !== a.vertexColors && (\"face\" === a.vertexColors ? i.vertexColors = THREE.FaceColors : a.vertexColors && (i.vertexColors = THREE.VertexColors));\n    a.colorDiffuse ? i.color = f(a.colorDiffuse) : a.DbgColor && (i.color = a.DbgColor);\n    a.colorSpecular && (i.specular = f(a.colorSpecular));\n    a.colorAmbient && (i.ambient = f(a.colorAmbient));\n    a.transparency && (i.opacity = a.transparency);\n    a.specularCoef && (i.shininess = a.specularCoef);\n    a.mapDiffuse && b && e(i, \"map\", a.mapDiffuse, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy);\n    a.mapLight && b && e(i, \"lightMap\", a.mapLight, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy);\n    a.mapBump && b && e(i, \"bumpMap\", a.mapBump, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy);\n    a.mapNormal && b && e(i, \"normalMap\", a.mapNormal, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy);\n    a.mapSpecular && b && e(i, \"specularMap\", a.mapSpecular, a.mapSpecularRepeat, a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy);\n    a.mapBumpScale && (i.bumpScale = a.mapBumpScale);\n    a.mapNormal ? (h = THREE.ShaderLib.normalmap, k = THREE.UniformsUtils.clone(h.uniforms), k.tNormal.value = i.normalMap, a.mapNormalFactor && k.uNormalScale.value.set(a.mapNormalFactor, a.mapNormalFactor), i.map && (k.tDiffuse.value = i.map, k.enableDiffuse.value = !0), i.specularMap && (k.tSpecular.value = i.specularMap, k.enableSpecular.value = !0), i.lightMap && (k.tAO.value = i.lightMap, k.enableAO.value = !0), k.uDiffuseColor.value.setHex(i.color), k.uSpecularColor.value.setHex(i.specular), k.uAmbientColor.value.setHex(i.ambient), k.uShininess.value = i.shininess, void 0 !== i.opacity && (k.uOpacity.value = i.opacity), h = new THREE.ShaderMaterial({\n      fragmentShader: h.fragmentShader,\n      vertexShader: h.vertexShader,\n      uniforms: k,\n      lights: !0,\n      fog: !0\n    }), i.transparent && (h.transparent = !0)) : h = new THREE[h](i);\n    void 0 !== a.DbgName && (h.name = a.DbgName);\n    return h;\n  }\n};\nTHREE.ImageLoader = function () {\n  THREE.EventDispatcher.call(this);\n  this.crossOrigin = null;\n};\nTHREE.ImageLoader.prototype = {\n  constructor: THREE.ImageLoader,\n  load: function load(a, b) {\n    var c = this;\n    void 0 === b && (b = new Image());\n    b.addEventListener(\"load\", function () {\n      c.dispatchEvent({\n        type: \"load\",\n        content: b\n      });\n    }, !1);\n    b.addEventListener(\"error\", function () {\n      c.dispatchEvent({\n        type: \"error\",\n        message: \"Couldn't load URL [\" + a + \"]\"\n      });\n    }, !1);\n    c.crossOrigin && (b.crossOrigin = c.crossOrigin);\n    b.src = a;\n  }\n};\nTHREE.JSONLoader = function (a) {\n  THREE.Loader.call(this, a);\n  this.withCredentials = !1;\n};\nTHREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);\nTHREE.JSONLoader.prototype.load = function (a, b, c) {\n  c = c && \"string\" === typeof c ? c : this.extractUrlBase(a);\n  this.onLoadStart();\n  this.loadAjaxJSON(this, a, b, c);\n};\nTHREE.JSONLoader.prototype.loadAjaxJSON = function (a, b, c, d, e) {\n  var f = new XMLHttpRequest(),\n    g = 0;\n  f.onreadystatechange = function () {\n    if (f.readyState === f.DONE) {\n      if (200 === f.status || 0 === f.status) {\n        if (f.responseText) {\n          var h = JSON.parse(f.responseText);\n          a.createModel(h, c, d);\n        } else console.warn(\"THREE.JSONLoader: [\" + b + \"] seems to be unreachable or file there is empty\");\n        a.onLoadComplete();\n      } else console.error(\"THREE.JSONLoader: Couldn't load [\" + b + \"] [\" + f.status + \"]\");\n    } else f.readyState === f.LOADING ? e && (0 === g && (g = f.getResponseHeader(\"Content-Length\")), e({\n      total: g,\n      loaded: f.responseText.length\n    })) : f.readyState === f.HEADERS_RECEIVED && (g = f.getResponseHeader(\"Content-Length\"));\n  };\n  f.open(\"GET\", b, !0);\n  f.withCredentials = this.withCredentials;\n  f.send(null);\n};\nTHREE.JSONLoader.prototype.createModel = function (a, b, c) {\n  var d = new THREE.Geometry(),\n    e = void 0 !== a.scale ? 1 / a.scale : 1,\n    f,\n    g,\n    h,\n    i,\n    k,\n    l,\n    m,\n    n,\n    s,\n    r,\n    p,\n    q,\n    y,\n    v,\n    z,\n    t = a.faces;\n  r = a.vertices;\n  var A = a.normals,\n    I = a.colors,\n    C = 0;\n  for (f = 0; f < a.uvs.length; f++) a.uvs[f].length && C++;\n  for (f = 0; f < C; f++) d.faceUvs[f] = [], d.faceVertexUvs[f] = [];\n  i = 0;\n  for (k = r.length; i < k;) l = new THREE.Vector3(), l.x = r[i++] * e, l.y = r[i++] * e, l.z = r[i++] * e, d.vertices.push(l);\n  i = 0;\n  for (k = t.length; i < k;) {\n    r = t[i++];\n    l = r & 1;\n    h = r & 2;\n    f = r & 4;\n    g = r & 8;\n    n = r & 16;\n    m = r & 32;\n    p = r & 64;\n    r &= 128;\n    l ? (q = new THREE.Face4(), q.a = t[i++], q.b = t[i++], q.c = t[i++], q.d = t[i++], l = 4) : (q = new THREE.Face3(), q.a = t[i++], q.b = t[i++], q.c = t[i++], l = 3);\n    h && (h = t[i++], q.materialIndex = h);\n    h = d.faces.length;\n    if (f) for (f = 0; f < C; f++) y = a.uvs[f], s = t[i++], z = y[2 * s], s = y[2 * s + 1], d.faceUvs[f][h] = new THREE.Vector2(z, s);\n    if (g) for (f = 0; f < C; f++) {\n      y = a.uvs[f];\n      v = [];\n      for (g = 0; g < l; g++) s = t[i++], z = y[2 * s], s = y[2 * s + 1], v[g] = new THREE.Vector2(z, s);\n      d.faceVertexUvs[f][h] = v;\n    }\n    n && (n = 3 * t[i++], g = new THREE.Vector3(), g.x = A[n++], g.y = A[n++], g.z = A[n], q.normal = g);\n    if (m) for (f = 0; f < l; f++) n = 3 * t[i++], g = new THREE.Vector3(), g.x = A[n++], g.y = A[n++], g.z = A[n], q.vertexNormals.push(g);\n    p && (m = t[i++], m = new THREE.Color(I[m]), q.color = m);\n    if (r) for (f = 0; f < l; f++) m = t[i++], m = new THREE.Color(I[m]), q.vertexColors.push(m);\n    d.faces.push(q);\n  }\n  if (a.skinWeights) {\n    i = 0;\n    for (k = a.skinWeights.length; i < k; i += 2) t = a.skinWeights[i], A = a.skinWeights[i + 1], d.skinWeights.push(new THREE.Vector4(t, A, 0, 0));\n  }\n  if (a.skinIndices) {\n    i = 0;\n    for (k = a.skinIndices.length; i < k; i += 2) t = a.skinIndices[i], A = a.skinIndices[i + 1], d.skinIndices.push(new THREE.Vector4(t, A, 0, 0));\n  }\n  d.bones = a.bones;\n  d.animation = a.animation;\n  if (void 0 !== a.morphTargets) {\n    i = 0;\n    for (k = a.morphTargets.length; i < k; i++) {\n      d.morphTargets[i] = {};\n      d.morphTargets[i].name = a.morphTargets[i].name;\n      d.morphTargets[i].vertices = [];\n      I = d.morphTargets[i].vertices;\n      C = a.morphTargets[i].vertices;\n      t = 0;\n      for (A = C.length; t < A; t += 3) r = new THREE.Vector3(), r.x = C[t] * e, r.y = C[t + 1] * e, r.z = C[t + 2] * e, I.push(r);\n    }\n  }\n  if (void 0 !== a.morphColors) {\n    i = 0;\n    for (k = a.morphColors.length; i < k; i++) {\n      d.morphColors[i] = {};\n      d.morphColors[i].name = a.morphColors[i].name;\n      d.morphColors[i].colors = [];\n      A = d.morphColors[i].colors;\n      I = a.morphColors[i].colors;\n      e = 0;\n      for (t = I.length; e < t; e += 3) C = new THREE.Color(16755200), C.setRGB(I[e], I[e + 1], I[e + 2]), A.push(C);\n    }\n  }\n  d.computeCentroids();\n  d.computeFaceNormals();\n  a = this.initMaterials(a.materials, c);\n  this.needsTangents(a) && d.computeTangents();\n  b(d, a);\n};\nTHREE.LoadingMonitor = function () {\n  THREE.EventDispatcher.call(this);\n  var a = this,\n    b = 0,\n    c = 0,\n    d = function d() {\n      b++;\n      a.dispatchEvent({\n        type: \"progress\",\n        loaded: b,\n        total: c\n      });\n      b === c && a.dispatchEvent({\n        type: \"load\"\n      });\n    };\n  this.add = function (a) {\n    c++;\n    a.addEventListener(\"load\", d, !1);\n  };\n};\nTHREE.SceneLoader = function () {\n  this.onLoadStart = function () {};\n  this.onLoadProgress = function () {};\n  this.onLoadComplete = function () {};\n  this.callbackSync = function () {};\n  this.callbackProgress = function () {};\n  this.geometryHandlerMap = {};\n  this.hierarchyHandlerMap = {};\n  this.addGeometryHandler(\"ascii\", THREE.JSONLoader);\n};\nTHREE.SceneLoader.prototype.constructor = THREE.SceneLoader;\nTHREE.SceneLoader.prototype.load = function (a, b) {\n  var c = this,\n    d = new XMLHttpRequest();\n  d.onreadystatechange = function () {\n    if (4 === d.readyState) if (200 === d.status || 0 === d.status) {\n      var e = JSON.parse(d.responseText);\n      c.parse(e, b, a);\n    } else console.error(\"THREE.SceneLoader: Couldn't load [\" + a + \"] [\" + d.status + \"]\");\n  };\n  d.open(\"GET\", a, !0);\n  d.send(null);\n};\nTHREE.SceneLoader.prototype.addGeometryHandler = function (a, b) {\n  this.geometryHandlerMap[a] = {\n    loaderClass: b\n  };\n};\nTHREE.SceneLoader.prototype.addHierarchyHandler = function (a, b) {\n  this.hierarchyHandlerMap[a] = {\n    loaderClass: b\n  };\n};\nTHREE.SceneLoader.prototype.parse = function (a, b, c) {\n  function d(a, b) {\n    return \"relativeToHTML\" == b ? a : m + \"/\" + a;\n  }\n  function e() {\n    f(x.scene, J.objects);\n  }\n  function f(a, b) {\n    var c, e, g, i, k, m, p;\n    for (p in b) if (void 0 === x.objects[p]) {\n      var q = b[p],\n        t = null;\n      if (q.type && q.type in l.hierarchyHandlerMap) {\n        if (void 0 === q.loading) {\n          e = {\n            type: 1,\n            url: 1,\n            material: 1,\n            position: 1,\n            rotation: 1,\n            scale: 1,\n            visible: 1,\n            children: 1,\n            properties: 1,\n            skin: 1,\n            morph: 1,\n            mirroredLoop: 1,\n            duration: 1\n          };\n          g = {};\n          for (var B in q) B in e || (g[B] = q[B]);\n          s = x.materials[q.material];\n          q.loading = !0;\n          e = l.hierarchyHandlerMap[q.type].loaderObject;\n          e.options ? e.load(d(q.url, J.urlBaseType), h(p, a, s, q)) : e.load(d(q.url, J.urlBaseType), h(p, a, s, q), g);\n        }\n      } else if (void 0 !== q.geometry) {\n        if (n = x.geometries[q.geometry]) {\n          t = !1;\n          s = x.materials[q.material];\n          t = s instanceof THREE.ShaderMaterial;\n          g = q.position;\n          i = q.rotation;\n          k = q.scale;\n          c = q.matrix;\n          m = q.quaternion;\n          q.material || (s = new THREE.MeshFaceMaterial(x.face_materials[q.geometry]));\n          s instanceof THREE.MeshFaceMaterial && 0 === s.materials.length && (s = new THREE.MeshFaceMaterial(x.face_materials[q.geometry]));\n          if (s instanceof THREE.MeshFaceMaterial) for (e = 0; e < s.materials.length; e++) t = t || s.materials[e] instanceof THREE.ShaderMaterial;\n          t && n.computeTangents();\n          q.skin ? t = new THREE.SkinnedMesh(n, s) : q.morph ? (t = new THREE.MorphAnimMesh(n, s), void 0 !== q.duration && (t.duration = q.duration), void 0 !== q.time && (t.time = q.time), void 0 !== q.mirroredLoop && (t.mirroredLoop = q.mirroredLoop), s.morphNormals && n.computeMorphNormals()) : t = new THREE.Mesh(n, s);\n          t.name = p;\n          c ? (t.matrixAutoUpdate = !1, t.matrix.set(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9], c[10], c[11], c[12], c[13], c[14], c[15])) : (t.position.set(g[0], g[1], g[2]), m ? (t.quaternion.set(m[0], m[1], m[2], m[3]), t.useQuaternion = !0) : t.rotation.set(i[0], i[1], i[2]), t.scale.set(k[0], k[1], k[2]));\n          t.visible = q.visible;\n          t.castShadow = q.castShadow;\n          t.receiveShadow = q.receiveShadow;\n          a.add(t);\n          x.objects[p] = t;\n        }\n      } else \"DirectionalLight\" === q.type || \"PointLight\" === q.type || \"AmbientLight\" === q.type ? (v = void 0 !== q.color ? q.color : 16777215, z = void 0 !== q.intensity ? q.intensity : 1, \"DirectionalLight\" === q.type ? (g = q.direction, y = new THREE.DirectionalLight(v, z), y.position.set(g[0], g[1], g[2]), q.target && (G.push({\n        object: y,\n        targetName: q.target\n      }), y.target = null)) : \"PointLight\" === q.type ? (g = q.position, e = q.distance, y = new THREE.PointLight(v, z, e), y.position.set(g[0], g[1], g[2])) : \"AmbientLight\" === q.type && (y = new THREE.AmbientLight(v)), a.add(y), y.name = p, x.lights[p] = y, x.objects[p] = y) : \"PerspectiveCamera\" === q.type || \"OrthographicCamera\" === q.type ? (\"PerspectiveCamera\" === q.type ? r = new THREE.PerspectiveCamera(q.fov, q.aspect, q.near, q.far) : \"OrthographicCamera\" === q.type && (r = new THREE.OrthographicCamera(q.left, q.right, q.top, q.bottom, q.near, q.far)), g = q.position, r.position.set(g[0], g[1], g[2]), a.add(r), r.name = p, x.cameras[p] = r, x.objects[p] = r) : (g = q.position, i = q.rotation, k = q.scale, m = q.quaternion, t = new THREE.Object3D(), t.name = p, t.position.set(g[0], g[1], g[2]), m ? (t.quaternion.set(m[0], m[1], m[2], m[3]), t.useQuaternion = !0) : t.rotation.set(i[0], i[1], i[2]), t.scale.set(k[0], k[1], k[2]), t.visible = void 0 !== q.visible ? q.visible : !1, a.add(t), x.objects[p] = t, x.empties[p] = t);\n      if (t) {\n        if (void 0 !== q.properties) for (var C in q.properties) t.properties[C] = q.properties[C];\n        if (void 0 !== q.groups) for (e = 0; e < q.groups.length; e++) g = q.groups[e], void 0 === x.groups[g] && (x.groups[g] = []), x.groups[g].push(p);\n        void 0 !== q.children && f(t, q.children);\n      }\n    }\n  }\n  function g(a) {\n    return function (b, c) {\n      x.geometries[a] = b;\n      x.face_materials[a] = c;\n      e();\n      t -= 1;\n      l.onLoadComplete();\n      k();\n    };\n  }\n  function h(a, b, c, d) {\n    return function (f) {\n      var f = f.content ? f.content : f.dae ? f.scene : f,\n        g = d.position,\n        h = d.rotation,\n        i = d.quaternion,\n        n = d.scale;\n      f.position.set(g[0], g[1], g[2]);\n      i ? (f.quaternion.set(i[0], i[1], i[2], i[3]), f.useQuaternion = !0) : f.rotation.set(h[0], h[1], h[2]);\n      f.scale.set(n[0], n[1], n[2]);\n      c && f.traverse(function (a) {\n        a.material = c;\n      });\n      var m = void 0 !== d.visible ? d.visible : !0;\n      f.traverse(function (a) {\n        a.visible = m;\n      });\n      b.add(f);\n      f.name = a;\n      x.objects[a] = f;\n      e();\n      t -= 1;\n      l.onLoadComplete();\n      k();\n    };\n  }\n  function i(a) {\n    return function (b, c) {\n      x.geometries[a] = b;\n      x.face_materials[a] = c;\n    };\n  }\n  function k() {\n    l.callbackProgress({\n      totalModels: I,\n      totalTextures: C,\n      loadedModels: I - t,\n      loadedTextures: C - A\n    }, x);\n    l.onLoadProgress();\n    if (0 === t && 0 === A) {\n      for (var a = 0; a < G.length; a++) {\n        var c = G[a],\n          d = x.objects[c.targetName];\n        d ? c.object.target = d : (c.object.target = new THREE.Object3D(), x.scene.add(c.object.target));\n        c.object.target.properties.targetInverse = c.object;\n      }\n      b(x);\n    }\n  }\n  var l = this,\n    m = THREE.Loader.prototype.extractUrlBase(c),\n    n,\n    s,\n    r,\n    p,\n    q,\n    y,\n    v,\n    z,\n    t,\n    A,\n    I,\n    C,\n    x,\n    G = [],\n    J = a,\n    E;\n  for (E in this.geometryHandlerMap) a = this.geometryHandlerMap[E].loaderClass, this.geometryHandlerMap[E].loaderObject = new a();\n  for (E in this.hierarchyHandlerMap) a = this.hierarchyHandlerMap[E].loaderClass, this.hierarchyHandlerMap[E].loaderObject = new a();\n  A = t = 0;\n  x = {\n    scene: new THREE.Scene(),\n    geometries: {},\n    face_materials: {},\n    materials: {},\n    textures: {},\n    objects: {},\n    cameras: {},\n    lights: {},\n    fogs: {},\n    empties: {},\n    groups: {}\n  };\n  if (J.transform && (E = J.transform.position, a = J.transform.rotation, c = J.transform.scale, E && x.scene.position.set(E[0], E[1], E[2]), a && x.scene.rotation.set(a[0], a[1], a[2]), c && x.scene.scale.set(c[0], c[1], c[2]), E || a || c)) x.scene.updateMatrix(), x.scene.updateMatrixWorld();\n  E = function E(a) {\n    return function () {\n      A -= a;\n      k();\n      l.onLoadComplete();\n    };\n  };\n  for (var H in J.fogs) a = J.fogs[H], \"linear\" === a.type ? p = new THREE.Fog(0, a.near, a.far) : \"exp2\" === a.type && (p = new THREE.FogExp2(0, a.density)), a = a.color, p.color.setRGB(a[0], a[1], a[2]), x.fogs[H] = p;\n  for (var B in J.geometries) p = J.geometries[B], p.type in this.geometryHandlerMap && (t += 1, l.onLoadStart());\n  for (var W in J.objects) p = J.objects[W], p.type && p.type in this.hierarchyHandlerMap && (t += 1, l.onLoadStart());\n  I = t;\n  for (B in J.geometries) if (p = J.geometries[B], \"cube\" === p.type) n = new THREE.CubeGeometry(p.width, p.height, p.depth, p.widthSegments, p.heightSegments, p.depthSegments), x.geometries[B] = n;else if (\"plane\" === p.type) n = new THREE.PlaneGeometry(p.width, p.height, p.widthSegments, p.heightSegments), x.geometries[B] = n;else if (\"sphere\" === p.type) n = new THREE.SphereGeometry(p.radius, p.widthSegments, p.heightSegments), x.geometries[B] = n;else if (\"cylinder\" === p.type) n = new THREE.CylinderGeometry(p.topRad, p.botRad, p.height, p.radSegs, p.heightSegs), x.geometries[B] = n;else if (\"torus\" === p.type) n = new THREE.TorusGeometry(p.radius, p.tube, p.segmentsR, p.segmentsT), x.geometries[B] = n;else if (\"icosahedron\" === p.type) n = new THREE.IcosahedronGeometry(p.radius, p.subdivisions), x.geometries[B] = n;else if (p.type in this.geometryHandlerMap) {\n    W = {};\n    for (q in p) \"type\" !== q && \"url\" !== q && (W[q] = p[q]);\n    this.geometryHandlerMap[p.type].loaderObject.load(d(p.url, J.urlBaseType), g(B), W);\n  } else \"embedded\" === p.type && (W = J.embeds[p.id], W.metadata = J.metadata, W && this.geometryHandlerMap.ascii.loaderObject.createModel(W, i(B), \"\"));\n  for (var F in J.textures) if (B = J.textures[F], B.url instanceof Array) {\n    A += B.url.length;\n    for (q = 0; q < B.url.length; q++) l.onLoadStart();\n  } else A += 1, l.onLoadStart();\n  C = A;\n  for (F in J.textures) {\n    B = J.textures[F];\n    void 0 !== B.mapping && void 0 !== THREE[B.mapping] && (B.mapping = new THREE[B.mapping]());\n    if (B.url instanceof Array) {\n      W = B.url.length;\n      p = [];\n      for (q = 0; q < W; q++) p[q] = d(B.url[q], J.urlBaseType);\n      q = (q = /\\.dds$/i.test(p[0])) ? THREE.ImageUtils.loadCompressedTextureCube(p, B.mapping, E(W)) : THREE.ImageUtils.loadTextureCube(p, B.mapping, E(W));\n    } else q = /\\.dds$/i.test(B.url), W = d(B.url, J.urlBaseType), p = E(1), q = q ? THREE.ImageUtils.loadCompressedTexture(W, B.mapping, p) : THREE.ImageUtils.loadTexture(W, B.mapping, p), void 0 !== THREE[B.minFilter] && (q.minFilter = THREE[B.minFilter]), void 0 !== THREE[B.magFilter] && (q.magFilter = THREE[B.magFilter]), B.anisotropy && (q.anisotropy = B.anisotropy), B.repeat && (q.repeat.set(B.repeat[0], B.repeat[1]), 1 !== B.repeat[0] && (q.wrapS = THREE.RepeatWrapping), 1 !== B.repeat[1] && (q.wrapT = THREE.RepeatWrapping)), B.offset && q.offset.set(B.offset[0], B.offset[1]), B.wrap && (W = {\n      repeat: THREE.RepeatWrapping,\n      mirror: THREE.MirroredRepeatWrapping\n    }, void 0 !== W[B.wrap[0]] && (q.wrapS = W[B.wrap[0]]), void 0 !== W[B.wrap[1]] && (q.wrapT = W[B.wrap[1]]));\n    x.textures[F] = q;\n  }\n  var K, L;\n  for (K in J.materials) {\n    F = J.materials[K];\n    for (L in F.parameters) \"envMap\" === L || \"map\" === L || \"lightMap\" === L || \"bumpMap\" === L ? F.parameters[L] = x.textures[F.parameters[L]] : \"shading\" === L ? F.parameters[L] = \"flat\" === F.parameters[L] ? THREE.FlatShading : THREE.SmoothShading : \"side\" === L ? F.parameters[L] = \"double\" == F.parameters[L] ? THREE.DoubleSide : \"back\" == F.parameters[L] ? THREE.BackSide : THREE.FrontSide : \"blending\" === L ? F.parameters[L] = F.parameters[L] in THREE ? THREE[F.parameters[L]] : THREE.NormalBlending : \"combine\" === L ? F.parameters[L] = F.parameters[L] in THREE ? THREE[F.parameters[L]] : THREE.MultiplyOperation : \"vertexColors\" === L ? \"face\" == F.parameters[L] ? F.parameters[L] = THREE.FaceColors : F.parameters[L] && (F.parameters[L] = THREE.VertexColors) : \"wrapRGB\" === L && (E = F.parameters[L], F.parameters[L] = new THREE.Vector3(E[0], E[1], E[2]));\n    void 0 !== F.parameters.opacity && 1 > F.parameters.opacity && (F.parameters.transparent = !0);\n    F.parameters.normalMap ? (E = THREE.ShaderLib.normalmap, B = THREE.UniformsUtils.clone(E.uniforms), q = F.parameters.color, W = F.parameters.specular, p = F.parameters.ambient, H = F.parameters.shininess, B.tNormal.value = x.textures[F.parameters.normalMap], F.parameters.normalScale && B.uNormalScale.value.set(F.parameters.normalScale[0], F.parameters.normalScale[1]), F.parameters.map && (B.tDiffuse.value = F.parameters.map, B.enableDiffuse.value = !0), F.parameters.envMap && (B.tCube.value = F.parameters.envMap, B.enableReflection.value = !0, B.uReflectivity.value = F.parameters.reflectivity), F.parameters.lightMap && (B.tAO.value = F.parameters.lightMap, B.enableAO.value = !0), F.parameters.specularMap && (B.tSpecular.value = x.textures[F.parameters.specularMap], B.enableSpecular.value = !0), F.parameters.displacementMap && (B.tDisplacement.value = x.textures[F.parameters.displacementMap], B.enableDisplacement.value = !0, B.uDisplacementBias.value = F.parameters.displacementBias, B.uDisplacementScale.value = F.parameters.displacementScale), B.uDiffuseColor.value.setHex(q), B.uSpecularColor.value.setHex(W), B.uAmbientColor.value.setHex(p), B.uShininess.value = H, F.parameters.opacity && (B.uOpacity.value = F.parameters.opacity), s = new THREE.ShaderMaterial({\n      fragmentShader: E.fragmentShader,\n      vertexShader: E.vertexShader,\n      uniforms: B,\n      lights: !0,\n      fog: !0\n    })) : s = new THREE[F.type](F.parameters);\n    x.materials[K] = s;\n  }\n  for (K in J.materials) if (F = J.materials[K], F.parameters.materials) {\n    L = [];\n    for (q = 0; q < F.parameters.materials.length; q++) L.push(x.materials[F.parameters.materials[q]]);\n    x.materials[K].materials = L;\n  }\n  e();\n  x.cameras && J.defaults.camera && (x.currentCamera = x.cameras[J.defaults.camera]);\n  x.fogs && J.defaults.fog && (x.scene.fog = x.fogs[J.defaults.fog]);\n  l.callbackSync(x);\n  k();\n};\nTHREE.TextureLoader = function () {\n  THREE.EventDispatcher.call(this);\n  this.crossOrigin = null;\n};\nTHREE.TextureLoader.prototype = {\n  constructor: THREE.TextureLoader,\n  load: function load(a) {\n    var b = this,\n      c = new Image();\n    c.addEventListener(\"load\", function () {\n      var a = new THREE.Texture(c);\n      a.needsUpdate = !0;\n      b.dispatchEvent({\n        type: \"load\",\n        content: a\n      });\n    }, !1);\n    c.addEventListener(\"error\", function () {\n      b.dispatchEvent({\n        type: \"error\",\n        message: \"Couldn't load URL [\" + a + \"]\"\n      });\n    }, !1);\n    b.crossOrigin && (c.crossOrigin = b.crossOrigin);\n    c.src = a;\n  }\n};\nTHREE.Material = function () {\n  THREE.EventDispatcher.call(this);\n  this.id = THREE.MaterialIdCount++;\n  this.name = \"\";\n  this.side = THREE.FrontSide;\n  this.opacity = 1;\n  this.transparent = !1;\n  this.blending = THREE.NormalBlending;\n  this.blendSrc = THREE.SrcAlphaFactor;\n  this.blendDst = THREE.OneMinusSrcAlphaFactor;\n  this.blendEquation = THREE.AddEquation;\n  this.depthWrite = this.depthTest = !0;\n  this.polygonOffset = !1;\n  this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;\n  this.overdraw = !1;\n  this.needsUpdate = this.visible = !0;\n};\nTHREE.Material.prototype.setValues = function (a) {\n  if (void 0 !== a) for (var b in a) {\n    var c = a[b];\n    if (void 0 === c) console.warn(\"THREE.Material: '\" + b + \"' parameter is undefined.\");else if (b in this) {\n      var d = this[b];\n      d instanceof THREE.Color && c instanceof THREE.Color ? d.copy(c) : d instanceof THREE.Color ? d.set(c) : d instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? d.copy(c) : this[b] = c;\n    }\n  }\n};\nTHREE.Material.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.Material());\n  a.name = this.name;\n  a.side = this.side;\n  a.opacity = this.opacity;\n  a.transparent = this.transparent;\n  a.blending = this.blending;\n  a.blendSrc = this.blendSrc;\n  a.blendDst = this.blendDst;\n  a.blendEquation = this.blendEquation;\n  a.depthTest = this.depthTest;\n  a.depthWrite = this.depthWrite;\n  a.polygonOffset = this.polygonOffset;\n  a.polygonOffsetFactor = this.polygonOffsetFactor;\n  a.polygonOffsetUnits = this.polygonOffsetUnits;\n  a.alphaTest = this.alphaTest;\n  a.overdraw = this.overdraw;\n  a.visible = this.visible;\n  return a;\n};\nTHREE.Material.prototype.dispose = function () {\n  this.dispatchEvent({\n    type: \"dispose\"\n  });\n};\nTHREE.MaterialIdCount = 0;\nTHREE.LineBasicMaterial = function (a) {\n  THREE.Material.call(this);\n  this.color = new THREE.Color(16777215);\n  this.linewidth = 1;\n  this.linejoin = this.linecap = \"round\";\n  this.vertexColors = !1;\n  this.fog = !0;\n  this.setValues(a);\n};\nTHREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.LineBasicMaterial.prototype.clone = function () {\n  var a = new THREE.LineBasicMaterial();\n  THREE.Material.prototype.clone.call(this, a);\n  a.color.copy(this.color);\n  a.linewidth = this.linewidth;\n  a.linecap = this.linecap;\n  a.linejoin = this.linejoin;\n  a.vertexColors = this.vertexColors;\n  a.fog = this.fog;\n  return a;\n};\nTHREE.LineDashedMaterial = function (a) {\n  THREE.Material.call(this);\n  this.color = new THREE.Color(16777215);\n  this.scale = this.linewidth = 1;\n  this.dashSize = 3;\n  this.gapSize = 1;\n  this.vertexColors = !1;\n  this.fog = !0;\n  this.setValues(a);\n};\nTHREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.LineDashedMaterial.prototype.clone = function () {\n  var a = new THREE.LineDashedMaterial();\n  THREE.Material.prototype.clone.call(this, a);\n  a.color.copy(this.color);\n  a.linewidth = this.linewidth;\n  a.scale = this.scale;\n  a.dashSize = this.dashSize;\n  a.gapSize = this.gapSize;\n  a.vertexColors = this.vertexColors;\n  a.fog = this.fog;\n  return a;\n};\nTHREE.MeshBasicMaterial = function (a) {\n  THREE.Material.call(this);\n  this.color = new THREE.Color(16777215);\n  this.envMap = this.specularMap = this.lightMap = this.map = null;\n  this.combine = THREE.MultiplyOperation;\n  this.reflectivity = 1;\n  this.refractionRatio = 0.98;\n  this.fog = !0;\n  this.shading = THREE.SmoothShading;\n  this.wireframe = !1;\n  this.wireframeLinewidth = 1;\n  this.wireframeLinejoin = this.wireframeLinecap = \"round\";\n  this.vertexColors = THREE.NoColors;\n  this.morphTargets = this.skinning = !1;\n  this.setValues(a);\n};\nTHREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshBasicMaterial.prototype.clone = function () {\n  var a = new THREE.MeshBasicMaterial();\n  THREE.Material.prototype.clone.call(this, a);\n  a.color.copy(this.color);\n  a.map = this.map;\n  a.lightMap = this.lightMap;\n  a.specularMap = this.specularMap;\n  a.envMap = this.envMap;\n  a.combine = this.combine;\n  a.reflectivity = this.reflectivity;\n  a.refractionRatio = this.refractionRatio;\n  a.fog = this.fog;\n  a.shading = this.shading;\n  a.wireframe = this.wireframe;\n  a.wireframeLinewidth = this.wireframeLinewidth;\n  a.wireframeLinecap = this.wireframeLinecap;\n  a.wireframeLinejoin = this.wireframeLinejoin;\n  a.vertexColors = this.vertexColors;\n  a.skinning = this.skinning;\n  a.morphTargets = this.morphTargets;\n  return a;\n};\nTHREE.MeshLambertMaterial = function (a) {\n  THREE.Material.call(this);\n  this.color = new THREE.Color(16777215);\n  this.ambient = new THREE.Color(16777215);\n  this.emissive = new THREE.Color(0);\n  this.wrapAround = !1;\n  this.wrapRGB = new THREE.Vector3(1, 1, 1);\n  this.envMap = this.specularMap = this.lightMap = this.map = null;\n  this.combine = THREE.MultiplyOperation;\n  this.reflectivity = 1;\n  this.refractionRatio = 0.98;\n  this.fog = !0;\n  this.shading = THREE.SmoothShading;\n  this.wireframe = !1;\n  this.wireframeLinewidth = 1;\n  this.wireframeLinejoin = this.wireframeLinecap = \"round\";\n  this.vertexColors = THREE.NoColors;\n  this.morphNormals = this.morphTargets = this.skinning = !1;\n  this.setValues(a);\n};\nTHREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshLambertMaterial.prototype.clone = function () {\n  var a = new THREE.MeshLambertMaterial();\n  THREE.Material.prototype.clone.call(this, a);\n  a.color.copy(this.color);\n  a.ambient.copy(this.ambient);\n  a.emissive.copy(this.emissive);\n  a.wrapAround = this.wrapAround;\n  a.wrapRGB.copy(this.wrapRGB);\n  a.map = this.map;\n  a.lightMap = this.lightMap;\n  a.specularMap = this.specularMap;\n  a.envMap = this.envMap;\n  a.combine = this.combine;\n  a.reflectivity = this.reflectivity;\n  a.refractionRatio = this.refractionRatio;\n  a.fog = this.fog;\n  a.shading = this.shading;\n  a.wireframe = this.wireframe;\n  a.wireframeLinewidth = this.wireframeLinewidth;\n  a.wireframeLinecap = this.wireframeLinecap;\n  a.wireframeLinejoin = this.wireframeLinejoin;\n  a.vertexColors = this.vertexColors;\n  a.skinning = this.skinning;\n  a.morphTargets = this.morphTargets;\n  a.morphNormals = this.morphNormals;\n  return a;\n};\nTHREE.MeshPhongMaterial = function (a) {\n  THREE.Material.call(this);\n  this.color = new THREE.Color(16777215);\n  this.ambient = new THREE.Color(16777215);\n  this.emissive = new THREE.Color(0);\n  this.specular = new THREE.Color(1118481);\n  this.shininess = 30;\n  this.metal = !1;\n  this.perPixel = !0;\n  this.wrapAround = !1;\n  this.wrapRGB = new THREE.Vector3(1, 1, 1);\n  this.bumpMap = this.lightMap = this.map = null;\n  this.bumpScale = 1;\n  this.normalMap = null;\n  this.normalScale = new THREE.Vector2(1, 1);\n  this.envMap = this.specularMap = null;\n  this.combine = THREE.MultiplyOperation;\n  this.reflectivity = 1;\n  this.refractionRatio = 0.98;\n  this.fog = !0;\n  this.shading = THREE.SmoothShading;\n  this.wireframe = !1;\n  this.wireframeLinewidth = 1;\n  this.wireframeLinejoin = this.wireframeLinecap = \"round\";\n  this.vertexColors = THREE.NoColors;\n  this.morphNormals = this.morphTargets = this.skinning = !1;\n  this.setValues(a);\n};\nTHREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshPhongMaterial.prototype.clone = function () {\n  var a = new THREE.MeshPhongMaterial();\n  THREE.Material.prototype.clone.call(this, a);\n  a.color.copy(this.color);\n  a.ambient.copy(this.ambient);\n  a.emissive.copy(this.emissive);\n  a.specular.copy(this.specular);\n  a.shininess = this.shininess;\n  a.metal = this.metal;\n  a.perPixel = this.perPixel;\n  a.wrapAround = this.wrapAround;\n  a.wrapRGB.copy(this.wrapRGB);\n  a.map = this.map;\n  a.lightMap = this.lightMap;\n  a.bumpMap = this.bumpMap;\n  a.bumpScale = this.bumpScale;\n  a.normalMap = this.normalMap;\n  a.normalScale.copy(this.normalScale);\n  a.specularMap = this.specularMap;\n  a.envMap = this.envMap;\n  a.combine = this.combine;\n  a.reflectivity = this.reflectivity;\n  a.refractionRatio = this.refractionRatio;\n  a.fog = this.fog;\n  a.shading = this.shading;\n  a.wireframe = this.wireframe;\n  a.wireframeLinewidth = this.wireframeLinewidth;\n  a.wireframeLinecap = this.wireframeLinecap;\n  a.wireframeLinejoin = this.wireframeLinejoin;\n  a.vertexColors = this.vertexColors;\n  a.skinning = this.skinning;\n  a.morphTargets = this.morphTargets;\n  a.morphNormals = this.morphNormals;\n  return a;\n};\nTHREE.MeshDepthMaterial = function (a) {\n  THREE.Material.call(this);\n  this.wireframe = !1;\n  this.wireframeLinewidth = 1;\n  this.setValues(a);\n};\nTHREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshDepthMaterial.prototype.clone = function () {\n  var a = new THREE.LineBasicMaterial();\n  THREE.Material.prototype.clone.call(this, a);\n  a.wireframe = this.wireframe;\n  a.wireframeLinewidth = this.wireframeLinewidth;\n  return a;\n};\nTHREE.MeshNormalMaterial = function (a) {\n  THREE.Material.call(this, a);\n  this.shading = THREE.FlatShading;\n  this.wireframe = !1;\n  this.wireframeLinewidth = 1;\n  this.setValues(a);\n};\nTHREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshNormalMaterial.prototype.clone = function () {\n  var a = new THREE.MeshNormalMaterial();\n  THREE.Material.prototype.clone.call(this, a);\n  a.shading = this.shading;\n  a.wireframe = this.wireframe;\n  a.wireframeLinewidth = this.wireframeLinewidth;\n  return a;\n};\nTHREE.MeshFaceMaterial = function (a) {\n  this.materials = a instanceof Array ? a : [];\n};\nTHREE.MeshFaceMaterial.prototype.clone = function () {\n  return new THREE.MeshFaceMaterial(this.materials.slice(0));\n};\nTHREE.ParticleBasicMaterial = function (a) {\n  THREE.Material.call(this);\n  this.color = new THREE.Color(16777215);\n  this.map = null;\n  this.size = 1;\n  this.sizeAttenuation = !0;\n  this.vertexColors = !1;\n  this.fog = !0;\n  this.setValues(a);\n};\nTHREE.ParticleBasicMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.ParticleBasicMaterial.prototype.clone = function () {\n  var a = new THREE.ParticleBasicMaterial();\n  THREE.Material.prototype.clone.call(this, a);\n  a.color.copy(this.color);\n  a.map = this.map;\n  a.size = this.size;\n  a.sizeAttenuation = this.sizeAttenuation;\n  a.vertexColors = this.vertexColors;\n  a.fog = this.fog;\n  return a;\n};\nTHREE.ParticleCanvasMaterial = function (a) {\n  THREE.Material.call(this);\n  this.color = new THREE.Color(16777215);\n  this.program = function () {};\n  this.setValues(a);\n};\nTHREE.ParticleCanvasMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.ParticleCanvasMaterial.prototype.clone = function () {\n  var a = new THREE.ParticleCanvasMaterial();\n  THREE.Material.prototype.clone.call(this, a);\n  a.color.copy(this.color);\n  a.program = this.program;\n  return a;\n};\nTHREE.ShaderMaterial = function (a) {\n  THREE.Material.call(this);\n  this.vertexShader = this.fragmentShader = \"void main() {}\";\n  this.uniforms = {};\n  this.defines = {};\n  this.attributes = null;\n  this.shading = THREE.SmoothShading;\n  this.wireframe = !1;\n  this.wireframeLinewidth = 1;\n  this.lights = this.fog = !1;\n  this.vertexColors = THREE.NoColors;\n  this.morphNormals = this.morphTargets = this.skinning = !1;\n  this.setValues(a);\n};\nTHREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.ShaderMaterial.prototype.clone = function () {\n  var a = new THREE.ShaderMaterial();\n  THREE.Material.prototype.clone.call(this, a);\n  a.fragmentShader = this.fragmentShader;\n  a.vertexShader = this.vertexShader;\n  a.uniforms = THREE.UniformsUtils.clone(this.uniforms);\n  a.attributes = this.attributes;\n  a.defines = this.defines;\n  a.shading = this.shading;\n  a.wireframe = this.wireframe;\n  a.wireframeLinewidth = this.wireframeLinewidth;\n  a.fog = this.fog;\n  a.lights = this.lights;\n  a.vertexColors = this.vertexColors;\n  a.skinning = this.skinning;\n  a.morphTargets = this.morphTargets;\n  a.morphNormals = this.morphNormals;\n  return a;\n};\nTHREE.SpriteMaterial = function (a) {\n  THREE.Material.call(this);\n  this.color = new THREE.Color(16777215);\n  this.map = new THREE.Texture();\n  this.useScreenCoordinates = !0;\n  this.depthTest = !this.useScreenCoordinates;\n  this.sizeAttenuation = !this.useScreenCoordinates;\n  this.scaleByViewport = !this.sizeAttenuation;\n  this.alignment = THREE.SpriteAlignment.center.clone();\n  this.fog = !1;\n  this.uvOffset = new THREE.Vector2(0, 0);\n  this.uvScale = new THREE.Vector2(1, 1);\n  this.setValues(a);\n  a = a || {};\n  void 0 === a.depthTest && (this.depthTest = !this.useScreenCoordinates);\n  void 0 === a.sizeAttenuation && (this.sizeAttenuation = !this.useScreenCoordinates);\n  void 0 === a.scaleByViewport && (this.scaleByViewport = !this.sizeAttenuation);\n};\nTHREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.SpriteMaterial.prototype.clone = function () {\n  var a = new THREE.SpriteMaterial();\n  THREE.Material.prototype.clone.call(this, a);\n  a.color.copy(this.color);\n  a.map = this.map;\n  a.useScreenCoordinates = this.useScreenCoordinates;\n  a.sizeAttenuation = this.sizeAttenuation;\n  a.scaleByViewport = this.scaleByViewport;\n  a.alignment.copy(this.alignment);\n  a.uvOffset.copy(this.uvOffset);\n  a.uvScale.copy(this.uvScale);\n  a.fog = this.fog;\n  return a;\n};\nTHREE.SpriteAlignment = {};\nTHREE.SpriteAlignment.topLeft = new THREE.Vector2(1, -1);\nTHREE.SpriteAlignment.topCenter = new THREE.Vector2(0, -1);\nTHREE.SpriteAlignment.topRight = new THREE.Vector2(-1, -1);\nTHREE.SpriteAlignment.centerLeft = new THREE.Vector2(1, 0);\nTHREE.SpriteAlignment.center = new THREE.Vector2(0, 0);\nTHREE.SpriteAlignment.centerRight = new THREE.Vector2(-1, 0);\nTHREE.SpriteAlignment.bottomLeft = new THREE.Vector2(1, 1);\nTHREE.SpriteAlignment.bottomCenter = new THREE.Vector2(0, 1);\nTHREE.SpriteAlignment.bottomRight = new THREE.Vector2(-1, 1);\nTHREE.Texture = function (a, b, c, d, e, f, g, h, i) {\n  THREE.EventDispatcher.call(this);\n  this.id = THREE.TextureIdCount++;\n  this.name = \"\";\n  this.image = a;\n  this.mipmaps = [];\n  this.mapping = void 0 !== b ? b : new THREE.UVMapping();\n  this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping;\n  this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping;\n  this.magFilter = void 0 !== e ? e : THREE.LinearFilter;\n  this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter;\n  this.anisotropy = void 0 !== i ? i : 1;\n  this.format = void 0 !== g ? g : THREE.RGBAFormat;\n  this.type = void 0 !== h ? h : THREE.UnsignedByteType;\n  this.offset = new THREE.Vector2(0, 0);\n  this.repeat = new THREE.Vector2(1, 1);\n  this.generateMipmaps = !0;\n  this.premultiplyAlpha = !1;\n  this.flipY = !0;\n  this.unpackAlignment = 4;\n  this.needsUpdate = !1;\n  this.onUpdate = null;\n};\nTHREE.Texture.prototype = {\n  constructor: THREE.Texture,\n  clone: function clone(a) {\n    void 0 === a && (a = new THREE.Texture());\n    a.image = this.image;\n    a.mipmaps = this.mipmaps.slice(0);\n    a.mapping = this.mapping;\n    a.wrapS = this.wrapS;\n    a.wrapT = this.wrapT;\n    a.magFilter = this.magFilter;\n    a.minFilter = this.minFilter;\n    a.anisotropy = this.anisotropy;\n    a.format = this.format;\n    a.type = this.type;\n    a.offset.copy(this.offset);\n    a.repeat.copy(this.repeat);\n    a.generateMipmaps = this.generateMipmaps;\n    a.premultiplyAlpha = this.premultiplyAlpha;\n    a.flipY = this.flipY;\n    a.unpackAlignment = this.unpackAlignment;\n    return a;\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: \"dispose\"\n    });\n  }\n};\nTHREE.TextureIdCount = 0;\nTHREE.CompressedTexture = function (a, b, c, d, e, f, g, h, i, k, l) {\n  THREE.Texture.call(this, null, f, g, h, i, k, d, e, l);\n  this.image = {\n    width: b,\n    height: c\n  };\n  this.mipmaps = a;\n  this.generateMipmaps = !1;\n};\nTHREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);\nTHREE.CompressedTexture.prototype.clone = function () {\n  var a = new THREE.CompressedTexture();\n  THREE.Texture.prototype.clone.call(this, a);\n  return a;\n};\nTHREE.DataTexture = function (a, b, c, d, e, f, g, h, i, k, l) {\n  THREE.Texture.call(this, null, f, g, h, i, k, d, e, l);\n  this.image = {\n    data: a,\n    width: b,\n    height: c\n  };\n};\nTHREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);\nTHREE.DataTexture.prototype.clone = function () {\n  var a = new THREE.DataTexture();\n  THREE.Texture.prototype.clone.call(this, a);\n  return a;\n};\nTHREE.Particle = function (a) {\n  THREE.Object3D.call(this);\n  this.material = a;\n};\nTHREE.Particle.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Particle.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.Particle(this.material));\n  THREE.Object3D.prototype.clone.call(this, a);\n  return a;\n};\nTHREE.ParticleSystem = function (a, b) {\n  THREE.Object3D.call(this);\n  this.geometry = a;\n  this.material = void 0 !== b ? b : new THREE.ParticleBasicMaterial({\n    color: 16777215 * Math.random()\n  });\n  this.sortParticles = !1;\n  this.geometry && null === this.geometry.boundingSphere && this.geometry.computeBoundingSphere();\n  this.frustumCulled = !1;\n};\nTHREE.ParticleSystem.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.ParticleSystem.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.ParticleSystem(this.geometry, this.material));\n  a.sortParticles = this.sortParticles;\n  THREE.Object3D.prototype.clone.call(this, a);\n  return a;\n};\nTHREE.Line = function (a, b, c) {\n  THREE.Object3D.call(this);\n  this.geometry = a;\n  this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({\n    color: 16777215 * Math.random()\n  });\n  this.type = void 0 !== c ? c : THREE.LineStrip;\n  this.geometry && (this.geometry.boundingSphere || this.geometry.computeBoundingSphere());\n};\nTHREE.LineStrip = 0;\nTHREE.LinePieces = 1;\nTHREE.Line.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Line.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.Line(this.geometry, this.material, this.type));\n  THREE.Object3D.prototype.clone.call(this, a);\n  return a;\n};\nTHREE.Mesh = function (a, b) {\n  THREE.Object3D.call(this);\n  this.geometry = a;\n  this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({\n    color: 16777215 * Math.random(),\n    wireframe: !0\n  });\n  void 0 !== this.geometry && (null === this.geometry.boundingSphere && this.geometry.computeBoundingSphere(), this.updateMorphTargets());\n};\nTHREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Mesh.prototype.updateMorphTargets = function () {\n  if (0 < this.geometry.morphTargets.length) {\n    this.morphTargetBase = -1;\n    this.morphTargetForcedOrder = [];\n    this.morphTargetInfluences = [];\n    this.morphTargetDictionary = {};\n    for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a;\n  }\n};\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function (a) {\n  if (void 0 !== this.morphTargetDictionary[a]) return this.morphTargetDictionary[a];\n  console.log(\"THREE.Mesh.getMorphTargetIndexByName: morph target \" + a + \" does not exist. Returning 0.\");\n  return 0;\n};\nTHREE.Mesh.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.Mesh(this.geometry, this.material));\n  THREE.Object3D.prototype.clone.call(this, a);\n  return a;\n};\nTHREE.Bone = function (a) {\n  THREE.Object3D.call(this);\n  this.skin = a;\n  this.skinMatrix = new THREE.Matrix4();\n};\nTHREE.Bone.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Bone.prototype.update = function (a, b) {\n  this.matrixAutoUpdate && (b |= this.updateMatrix());\n  if (b || this.matrixWorldNeedsUpdate) a ? this.skinMatrix.multiplyMatrices(a, this.matrix) : this.skinMatrix.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, b = !0;\n  var c,\n    d = this.children.length;\n  for (c = 0; c < d; c++) this.children[c].update(this.skinMatrix, b);\n};\nTHREE.SkinnedMesh = function (a, b, c) {\n  THREE.Mesh.call(this, a, b);\n  this.useVertexTexture = void 0 !== c ? c : !0;\n  this.identityMatrix = new THREE.Matrix4();\n  this.bones = [];\n  this.boneMatrices = [];\n  var d, e, f;\n  if (this.geometry && void 0 !== this.geometry.bones) {\n    for (a = 0; a < this.geometry.bones.length; a++) c = this.geometry.bones[a], d = c.pos, e = c.rotq, f = c.scl, b = this.addBone(), b.name = c.name, b.position.set(d[0], d[1], d[2]), b.quaternion.set(e[0], e[1], e[2], e[3]), b.useQuaternion = !0, void 0 !== f ? b.scale.set(f[0], f[1], f[2]) : b.scale.set(1, 1, 1);\n    for (a = 0; a < this.bones.length; a++) c = this.geometry.bones[a], b = this.bones[a], -1 === c.parent ? this.add(b) : this.bones[c.parent].add(b);\n    a = this.bones.length;\n    this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = a = 256 < a ? 64 : 64 < a ? 32 : 16 < a ? 16 : 8, this.boneMatrices = new Float32Array(4 * this.boneTextureWidth * this.boneTextureHeight), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * a);\n    this.pose();\n  }\n};\nTHREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.SkinnedMesh.prototype.addBone = function (a) {\n  void 0 === a && (a = new THREE.Bone(this));\n  this.bones.push(a);\n  return a;\n};\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function (a) {\n  this.matrixAutoUpdate && this.updateMatrix();\n  if (this.matrixWorldNeedsUpdate || a) this.parent ? this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1;\n  for (var a = 0, b = this.children.length; a < b; a++) {\n    var c = this.children[a];\n    c instanceof THREE.Bone ? c.update(this.identityMatrix, !1) : c.updateMatrixWorld(!0);\n  }\n  if (void 0 == this.boneInverses) {\n    this.boneInverses = [];\n    a = 0;\n    for (b = this.bones.length; a < b; a++) c = new THREE.Matrix4(), c.getInverse(this.bones[a].skinMatrix), this.boneInverses.push(c);\n  }\n  a = 0;\n  for (b = this.bones.length; a < b; a++) THREE.SkinnedMesh.offsetMatrix.multiplyMatrices(this.bones[a].skinMatrix, this.boneInverses[a]), THREE.SkinnedMesh.offsetMatrix.flattenToArrayOffset(this.boneMatrices, 16 * a);\n  this.useVertexTexture && (this.boneTexture.needsUpdate = !0);\n};\nTHREE.SkinnedMesh.prototype.pose = function () {\n  this.updateMatrixWorld(!0);\n  for (var a = 0; a < this.geometry.skinIndices.length; a++) {\n    var b = this.geometry.skinWeights[a],\n      c = 1 / b.lengthManhattan();\n    Infinity !== c ? b.multiplyScalar(c) : b.set(1);\n  }\n};\nTHREE.SkinnedMesh.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture));\n  THREE.Mesh.prototype.clone.call(this, a);\n  return a;\n};\nTHREE.SkinnedMesh.offsetMatrix = new THREE.Matrix4();\nTHREE.MorphAnimMesh = function (a, b) {\n  THREE.Mesh.call(this, a, b);\n  this.duration = 1E3;\n  this.mirroredLoop = !1;\n  this.currentKeyframe = this.lastKeyframe = this.time = 0;\n  this.direction = 1;\n  this.directionBackwards = !1;\n  this.setFrameRange(0, this.geometry.morphTargets.length - 1);\n};\nTHREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.MorphAnimMesh.prototype.setFrameRange = function (a, b) {\n  this.startKeyframe = a;\n  this.endKeyframe = b;\n  this.length = this.endKeyframe - this.startKeyframe + 1;\n};\nTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\n  this.direction = 1;\n  this.directionBackwards = !1;\n};\nTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\n  this.direction = -1;\n  this.directionBackwards = !0;\n};\nTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\n  var a = this.geometry;\n  a.animations || (a.animations = {});\n  for (var b, c = a.animations, d = /([a-z]+)(\\d+)/, e = 0, f = a.morphTargets.length; e < f; e++) {\n    var g = a.morphTargets[e].name.match(d);\n    if (g && 1 < g.length) {\n      g = g[1];\n      c[g] || (c[g] = {\n        start: Infinity,\n        end: -Infinity\n      });\n      var h = c[g];\n      e < h.start && (h.start = e);\n      e > h.end && (h.end = e);\n      b || (b = g);\n    }\n  }\n  a.firstAnimation = b;\n};\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function (a, b, c) {\n  this.geometry.animations || (this.geometry.animations = {});\n  this.geometry.animations[a] = {\n    start: b,\n    end: c\n  };\n};\nTHREE.MorphAnimMesh.prototype.playAnimation = function (a, b) {\n  var c = this.geometry.animations[a];\n  c ? (this.setFrameRange(c.start, c.end), this.duration = 1E3 * ((c.end - c.start) / b), this.time = 0) : console.warn(\"animation[\" + a + \"] undefined\");\n};\nTHREE.MorphAnimMesh.prototype.updateAnimation = function (a) {\n  var b = this.duration / this.length;\n  this.time += this.direction * a;\n  if (this.mirroredLoop) {\n    if (this.time > this.duration || 0 > this.time) this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 0 > this.time && (this.time = 0, this.directionBackwards = !1);\n  } else this.time %= this.duration, 0 > this.time && (this.time += this.duration);\n  a = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / b), 0, this.length - 1);\n  a !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[a] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = a);\n  b = this.time % b / b;\n  this.directionBackwards && (b = 1 - b);\n  this.morphTargetInfluences[this.currentKeyframe] = b;\n  this.morphTargetInfluences[this.lastKeyframe] = 1 - b;\n};\nTHREE.MorphAnimMesh.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.MorphAnimMesh(this.geometry, this.material));\n  a.duration = this.duration;\n  a.mirroredLoop = this.mirroredLoop;\n  a.time = this.time;\n  a.lastKeyframe = this.lastKeyframe;\n  a.currentKeyframe = this.currentKeyframe;\n  a.direction = this.direction;\n  a.directionBackwards = this.directionBackwards;\n  THREE.Mesh.prototype.clone.call(this, a);\n  return a;\n};\nTHREE.Ribbon = function (a, b) {\n  THREE.Object3D.call(this);\n  this.geometry = a;\n  this.material = b;\n};\nTHREE.Ribbon.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Ribbon.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.Ribbon(this.geometry, this.material));\n  THREE.Object3D.prototype.clone.call(this, a);\n  return a;\n};\nTHREE.LOD = function () {\n  THREE.Object3D.call(this);\n  this.LODs = [];\n};\nTHREE.LOD.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.LOD.prototype.addLevel = function (a, b) {\n  void 0 === b && (b = 0);\n  for (var b = Math.abs(b), c = 0; c < this.LODs.length && !(b < this.LODs[c].visibleAtDistance); c++);\n  this.LODs.splice(c, 0, {\n    visibleAtDistance: b,\n    object3D: a\n  });\n  this.add(a);\n};\nTHREE.LOD.prototype.update = function (a) {\n  if (1 < this.LODs.length) {\n    a.matrixWorldInverse.getInverse(a.matrixWorld);\n    a = a.matrixWorldInverse;\n    a = -(a.elements[2] * this.matrixWorld.elements[12] + a.elements[6] * this.matrixWorld.elements[13] + a.elements[10] * this.matrixWorld.elements[14] + a.elements[14]);\n    this.LODs[0].object3D.visible = !0;\n    for (var b = 1; b < this.LODs.length; b++) if (a >= this.LODs[b].visibleAtDistance) this.LODs[b - 1].object3D.visible = !1, this.LODs[b].object3D.visible = !0;else break;\n    for (; b < this.LODs.length; b++) this.LODs[b].object3D.visible = !1;\n  }\n};\nTHREE.LOD.prototype.clone = function () {};\nTHREE.Sprite = function (a) {\n  THREE.Object3D.call(this);\n  this.material = void 0 !== a ? a : new THREE.SpriteMaterial();\n  this.rotation3d = this.rotation;\n  this.rotation = 0;\n};\nTHREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Sprite.prototype.updateMatrix = function () {\n  this.matrix.setPosition(this.position);\n  this.rotation3d.set(0, 0, this.rotation);\n  this.matrix.setRotationFromEuler(this.rotation3d);\n  (1 !== this.scale.x || 1 !== this.scale.y) && this.matrix.scale(this.scale);\n  this.matrixWorldNeedsUpdate = !0;\n};\nTHREE.Sprite.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.Sprite(this.material));\n  THREE.Object3D.prototype.clone.call(this, a);\n  return a;\n};\nTHREE.Scene = function () {\n  THREE.Object3D.call(this);\n  this.overrideMaterial = this.fog = null;\n  this.matrixAutoUpdate = !1;\n  this.__objects = [];\n  this.__lights = [];\n  this.__objectsAdded = [];\n  this.__objectsRemoved = [];\n};\nTHREE.Scene.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Scene.prototype.__addObject = function (a) {\n  if (a instanceof THREE.Light) -1 === this.__lights.indexOf(a) && this.__lights.push(a), a.target && void 0 === a.target.parent && this.add(a.target);else if (!(a instanceof THREE.Camera || a instanceof THREE.Bone) && -1 === this.__objects.indexOf(a)) {\n    this.__objects.push(a);\n    this.__objectsAdded.push(a);\n    var b = this.__objectsRemoved.indexOf(a);\n    -1 !== b && this.__objectsRemoved.splice(b, 1);\n  }\n  for (b = 0; b < a.children.length; b++) this.__addObject(a.children[b]);\n};\nTHREE.Scene.prototype.__removeObject = function (a) {\n  if (a instanceof THREE.Light) {\n    var b = this.__lights.indexOf(a);\n    -1 !== b && this.__lights.splice(b, 1);\n  } else a instanceof THREE.Camera || (b = this.__objects.indexOf(a), -1 !== b && (this.__objects.splice(b, 1), this.__objectsRemoved.push(a), b = this.__objectsAdded.indexOf(a), -1 !== b && this.__objectsAdded.splice(b, 1)));\n  for (b = 0; b < a.children.length; b++) this.__removeObject(a.children[b]);\n};\nTHREE.Fog = function (a, b, c) {\n  this.name = \"\";\n  this.color = new THREE.Color(a);\n  this.near = void 0 !== b ? b : 1;\n  this.far = void 0 !== c ? c : 1E3;\n};\nTHREE.Fog.prototype.clone = function () {\n  return new THREE.Fog(this.color.getHex(), this.near, this.far);\n};\nTHREE.FogExp2 = function (a, b) {\n  this.name = \"\";\n  this.color = new THREE.Color(a);\n  this.density = void 0 !== b ? b : 2.5E-4;\n};\nTHREE.FogExp2.prototype.clone = function () {\n  return new THREE.FogExp2(this.color.getHex(), this.density);\n};\nTHREE.CanvasRenderer = function (a) {\n  function b(a) {\n    C !== a && (C = t.globalAlpha = a);\n  }\n  function c(a) {\n    x !== a && (a === THREE.NormalBlending ? t.globalCompositeOperation = \"source-over\" : a === THREE.AdditiveBlending ? t.globalCompositeOperation = \"lighter\" : a === THREE.SubtractiveBlending && (t.globalCompositeOperation = \"darker\"), x = a);\n  }\n  function d(a) {\n    E !== a && (E = t.lineWidth = a);\n  }\n  function e(a) {\n    H !== a && (H = t.lineCap = a);\n  }\n  function f(a) {\n    B !== a && (B = t.lineJoin = a);\n  }\n  function g(a) {\n    G !== a && (G = t.strokeStyle = a);\n  }\n  function h(a) {\n    J !== a && (J = t.fillStyle = a);\n  }\n  function i(a, b) {\n    if (W !== a || F !== b) t.setLineDash([a, b]), W = a, F = b;\n  }\n  console.log(\"THREE.CanvasRenderer\", THREE.REVISION);\n  var k = THREE.Math.smoothstep,\n    a = a || {},\n    l = this,\n    m,\n    n,\n    s,\n    r = new THREE.Projector(),\n    p = void 0 !== a.canvas ? a.canvas : document.createElement(\"canvas\"),\n    q,\n    y,\n    v,\n    z,\n    t = p.getContext(\"2d\"),\n    A = new THREE.Color(0),\n    I = 0,\n    C = 1,\n    x = 0,\n    G = null,\n    J = null,\n    E = null,\n    H = null,\n    B = null,\n    W = null,\n    F = 0,\n    K,\n    L,\n    U,\n    fa,\n    Ca = new THREE.RenderableVertex(),\n    $a = new THREE.RenderableVertex(),\n    M,\n    ca,\n    qa,\n    ha,\n    ra,\n    N,\n    Ma,\n    Na,\n    mb,\n    Pa,\n    ta,\n    ka,\n    aa = new THREE.Color(),\n    pa = new THREE.Color(),\n    Y = new THREE.Color(),\n    da = new THREE.Color(),\n    la = new THREE.Color(),\n    Z = new THREE.Color(),\n    oa = new THREE.Color(),\n    gb = new THREE.Color(),\n    nb = {},\n    ia = {},\n    Wa,\n    ab,\n    Fa,\n    Xa,\n    ub,\n    Ib,\n    Jb,\n    fc,\n    Ab,\n    mc,\n    pb = new THREE.Box2(),\n    Ka = new THREE.Box2(),\n    Va = new THREE.Box2(),\n    gc = !1,\n    vb = new THREE.Color(),\n    Qa = new THREE.Color(),\n    La = new THREE.Color(),\n    bb = new THREE.Vector3(),\n    xb,\n    j,\n    yb,\n    Ra,\n    cb,\n    Sa,\n    zb = 16;\n  xb = document.createElement(\"canvas\");\n  xb.width = xb.height = 2;\n  j = xb.getContext(\"2d\");\n  j.fillStyle = \"rgba(0,0,0,1)\";\n  j.fillRect(0, 0, 2, 2);\n  yb = j.getImageData(0, 0, 2, 2);\n  Ra = yb.data;\n  cb = document.createElement(\"canvas\");\n  cb.width = cb.height = zb;\n  Sa = cb.getContext(\"2d\");\n  Sa.translate(-zb / 2, -zb / 2);\n  Sa.scale(zb, zb);\n  zb--;\n  void 0 === t.setLineDash && (t.setLineDash = void 0 !== t.mozDash ? function (a) {\n    t.mozDash = null !== a[0] ? a : null;\n  } : function () {});\n  this.domElement = p;\n  this.devicePixelRatio = void 0 !== a.devicePixelRatio ? a.devicePixelRatio : void 0 !== window.devicePixelRatio ? window.devicePixelRatio : 1;\n  this.sortElements = this.sortObjects = this.autoClear = !0;\n  this.info = {\n    render: {\n      vertices: 0,\n      faces: 0\n    }\n  };\n  this.supportsVertexTextures = function () {};\n  this.setFaceCulling = function () {};\n  this.setSize = function (a, b) {\n    q = a * this.devicePixelRatio;\n    y = b * this.devicePixelRatio;\n    v = Math.floor(q / 2);\n    z = Math.floor(y / 2);\n    p.width = q;\n    p.height = y;\n    p.style.width = a + \"px\";\n    p.style.height = b + \"px\";\n    pb.set(new THREE.Vector2(-v, -z), new THREE.Vector2(v, z));\n    Ka.set(new THREE.Vector2(-v, -z), new THREE.Vector2(v, z));\n    C = 1;\n    x = 0;\n    B = H = E = J = G = null;\n  };\n  this.setClearColor = function (a, b) {\n    A.copy(a);\n    I = void 0 !== b ? b : 1;\n    Ka.set(new THREE.Vector2(-v, -z), new THREE.Vector2(v, z));\n  };\n  this.setClearColorHex = function (a, b) {\n    A.setHex(a);\n    I = void 0 !== b ? b : 1;\n    Ka.set(new THREE.Vector2(-v, -z), new THREE.Vector2(v, z));\n  };\n  this.getMaxAnisotropy = function () {\n    return 0;\n  };\n  this.clear = function () {\n    t.setTransform(1, 0, 0, -1, v, z);\n    !1 === Ka.empty() && (Ka.intersect(pb), Ka.expandByScalar(2), 1 > I && t.clearRect(Ka.min.x | 0, Ka.min.y | 0, Ka.max.x - Ka.min.x | 0, Ka.max.y - Ka.min.y | 0), 0 < I && (c(THREE.NormalBlending), b(1), h(\"rgba(\" + Math.floor(255 * A.r) + \",\" + Math.floor(255 * A.g) + \",\" + Math.floor(255 * A.b) + \",\" + I + \")\"), t.fillRect(Ka.min.x | 0, Ka.min.y | 0, Ka.max.x - Ka.min.x | 0, Ka.max.y - Ka.min.y | 0)), Ka.makeEmpty());\n  };\n  this.render = function (a, p) {\n    function q(a, b, c) {\n      for (var d = 0, e = s.length; d < e; d++) {\n        var f = s[d];\n        gb.copy(f.color);\n        if (f instanceof THREE.DirectionalLight) {\n          var g = bb.getPositionFromMatrix(f.matrixWorld).normalize(),\n            j = b.dot(g);\n          0 >= j || (j *= f.intensity, c.add(gb.multiplyScalar(j)));\n        } else f instanceof THREE.PointLight && (g = bb.getPositionFromMatrix(f.matrixWorld), j = b.dot(bb.subVectors(g, a).normalize()), 0 >= j || (j *= 0 == f.distance ? 1 : 1 - Math.min(a.distanceTo(g) / f.distance, 1), 0 != j && (j *= f.intensity, c.add(gb.multiplyScalar(j)))));\n      }\n    }\n    function x(a, d, e, f, g, j, h, i) {\n      l.info.render.vertices += 3;\n      l.info.render.faces++;\n      b(i.opacity);\n      c(i.blending);\n      M = a.positionScreen.x;\n      ca = a.positionScreen.y;\n      qa = d.positionScreen.x;\n      ha = d.positionScreen.y;\n      ra = e.positionScreen.x;\n      N = e.positionScreen.y;\n      y(M, ca, qa, ha, ra, N);\n      (i instanceof THREE.MeshLambertMaterial || i instanceof THREE.MeshPhongMaterial) && null === i.map ? (Z.copy(i.color), oa.copy(i.emissive), i.vertexColors === THREE.FaceColors && Z.multiply(h.color), !0 === gc ? !1 === i.wireframe && i.shading == THREE.SmoothShading && 3 == h.vertexNormalsLength ? (pa.copy(vb), Y.copy(vb), da.copy(vb), q(h.v1.positionWorld, h.vertexNormalsModel[0], pa), q(h.v2.positionWorld, h.vertexNormalsModel[1], Y), q(h.v3.positionWorld, h.vertexNormalsModel[2], da), pa.multiply(Z).add(oa), Y.multiply(Z).add(oa), da.multiply(Z).add(oa), la.addColors(Y, da).multiplyScalar(0.5), Fa = E(pa, Y, da, la), G(M, ca, qa, ha, ra, N, 0, 0, 1, 0, 0, 1, Fa)) : (aa.copy(vb), q(h.centroidModel, h.normalModel, aa), aa.multiply(Z).add(oa), !0 === i.wireframe ? C(aa, i.wireframeLinewidth, i.wireframeLinecap, i.wireframeLinejoin) : A(aa)) : !0 === i.wireframe ? C(i.color, i.wireframeLinewidth, i.wireframeLinecap, i.wireframeLinejoin) : A(i.color)) : i instanceof THREE.MeshBasicMaterial || i instanceof THREE.MeshLambertMaterial || i instanceof THREE.MeshPhongMaterial ? null !== i.map ? i.map.mapping instanceof THREE.UVMapping && (Xa = h.uvs[0], F(M, ca, qa, ha, ra, N, Xa[f].x, Xa[f].y, Xa[g].x, Xa[g].y, Xa[j].x, Xa[j].y, i.map)) : null !== i.envMap ? i.envMap.mapping instanceof THREE.SphericalReflectionMapping && (bb.copy(h.vertexNormalsModelView[f]), ub = 0.5 * bb.x + 0.5, Ib = 0.5 * bb.y + 0.5, bb.copy(h.vertexNormalsModelView[g]), Jb = 0.5 * bb.x + 0.5, fc = 0.5 * bb.y + 0.5, bb.copy(h.vertexNormalsModelView[j]), Ab = 0.5 * bb.x + 0.5, mc = 0.5 * bb.y + 0.5, F(M, ca, qa, ha, ra, N, ub, Ib, Jb, fc, Ab, mc, i.envMap)) : (aa.copy(i.color), i.vertexColors === THREE.FaceColors && aa.multiply(h.color), !0 === i.wireframe ? C(aa, i.wireframeLinewidth, i.wireframeLinecap, i.wireframeLinejoin) : A(aa)) : i instanceof THREE.MeshDepthMaterial ? (Wa = p.near, ab = p.far, pa.r = pa.g = pa.b = 1 - k(a.positionScreen.z * a.positionScreen.w, Wa, ab), Y.r = Y.g = Y.b = 1 - k(d.positionScreen.z * d.positionScreen.w, Wa, ab), da.r = da.g = da.b = 1 - k(e.positionScreen.z * e.positionScreen.w, Wa, ab), la.addColors(Y, da).multiplyScalar(0.5), Fa = E(pa, Y, da, la), G(M, ca, qa, ha, ra, N, 0, 0, 1, 0, 0, 1, Fa)) : i instanceof THREE.MeshNormalMaterial && (i.shading == THREE.FlatShading ? (a = h.normalModelView, aa.setRGB(a.x, a.y, a.z).multiplyScalar(0.5).addScalar(0.5), !0 === i.wireframe ? C(aa, i.wireframeLinewidth, i.wireframeLinecap, i.wireframeLinejoin) : A(aa)) : i.shading == THREE.SmoothShading && (a = h.vertexNormalsModelView[f], pa.setRGB(a.x, a.y, a.z).multiplyScalar(0.5).addScalar(0.5), a = h.vertexNormalsModelView[g], Y.setRGB(a.x, a.y, a.z).multiplyScalar(0.5).addScalar(0.5), a = h.vertexNormalsModelView[j], da.setRGB(a.x, a.y, a.z).multiplyScalar(0.5).addScalar(0.5), la.addColors(Y, da).multiplyScalar(0.5), Fa = E(pa, Y, da, la), G(M, ca, qa, ha, ra, N, 0, 0, 1, 0, 0, 1, Fa)));\n    }\n    function y(a, b, c, d, e, f) {\n      t.beginPath();\n      t.moveTo(a, b);\n      t.lineTo(c, d);\n      t.lineTo(e, f);\n      t.closePath();\n    }\n    function B(a, b, c, d, e, f, g, j) {\n      t.beginPath();\n      t.moveTo(a, b);\n      t.lineTo(c, d);\n      t.lineTo(e, f);\n      t.lineTo(g, j);\n      t.closePath();\n    }\n    function C(a, b, c, j) {\n      d(b);\n      e(c);\n      f(j);\n      g(a.getStyle());\n      t.stroke();\n      Va.expandByScalar(2 * b);\n    }\n    function A(a) {\n      h(a.getStyle());\n      t.fill();\n    }\n    function F(a, b, c, d, e, f, g, j, i, wa, k, l, n) {\n      if (!(n instanceof THREE.DataTexture || void 0 === n.image || 0 == n.image.width)) {\n        if (!0 === n.needsUpdate) {\n          var m = n.wrapS == THREE.RepeatWrapping,\n            hb = n.wrapT == THREE.RepeatWrapping;\n          nb[n.id] = t.createPattern(n.image, !0 === m && !0 === hb ? \"repeat\" : !0 === m && !1 === hb ? \"repeat-x\" : !1 === m && !0 === hb ? \"repeat-y\" : \"no-repeat\");\n          n.needsUpdate = !1;\n        }\n        void 0 === nb[n.id] ? h(\"rgba(0,0,0,1)\") : h(nb[n.id]);\n        var m = n.offset.x / n.repeat.x,\n          hb = n.offset.y / n.repeat.y,\n          p = n.image.width * n.repeat.x,\n          q = n.image.height * n.repeat.y,\n          g = (g + m) * p,\n          j = (1 - j + hb) * q,\n          c = c - a,\n          d = d - b,\n          e = e - a,\n          f = f - b,\n          i = (i + m) * p - g,\n          wa = (1 - wa + hb) * q - j,\n          k = (k + m) * p - g,\n          l = (1 - l + hb) * q - j,\n          m = i * l - k * wa;\n        0 === m ? (void 0 === ia[n.id] && (b = document.createElement(\"canvas\"), b.width = n.image.width, b.height = n.image.height, b = b.getContext(\"2d\"), b.drawImage(n.image, 0, 0), ia[n.id] = b.getImageData(0, 0, n.image.width, n.image.height).data), b = ia[n.id], g = 4 * (Math.floor(g) + Math.floor(j) * n.image.width), aa.setRGB(b[g] / 255, b[g + 1] / 255, b[g + 2] / 255), A(aa)) : (m = 1 / m, n = (l * c - wa * e) * m, wa = (l * d - wa * f) * m, c = (i * e - k * c) * m, d = (i * f - k * d) * m, a = a - n * g - c * j, g = b - wa * g - d * j, t.save(), t.transform(n, wa, c, d, a, g), t.fill(), t.restore());\n      }\n    }\n    function G(a, b, c, d, e, f, g, j, i, h, wa, k, n) {\n      var l, m;\n      l = n.width - 1;\n      m = n.height - 1;\n      g *= l;\n      j *= m;\n      c -= a;\n      d -= b;\n      e -= a;\n      f -= b;\n      i = i * l - g;\n      h = h * m - j;\n      wa = wa * l - g;\n      k = k * m - j;\n      m = 1 / (i * k - wa * h);\n      l = (k * c - h * e) * m;\n      h = (k * d - h * f) * m;\n      c = (i * e - wa * c) * m;\n      d = (i * f - wa * d) * m;\n      a = a - l * g - c * j;\n      b = b - h * g - d * j;\n      t.save();\n      t.transform(l, h, c, d, a, b);\n      t.clip();\n      t.drawImage(n, 0, 0);\n      t.restore();\n    }\n    function E(a, b, c, d) {\n      Ra[0] = 255 * a.r | 0;\n      Ra[1] = 255 * a.g | 0;\n      Ra[2] = 255 * a.b | 0;\n      Ra[4] = 255 * b.r | 0;\n      Ra[5] = 255 * b.g | 0;\n      Ra[6] = 255 * b.b | 0;\n      Ra[8] = 255 * c.r | 0;\n      Ra[9] = 255 * c.g | 0;\n      Ra[10] = 255 * c.b | 0;\n      Ra[12] = 255 * d.r | 0;\n      Ra[13] = 255 * d.g | 0;\n      Ra[14] = 255 * d.b | 0;\n      j.putImageData(yb, 0, 0);\n      Sa.drawImage(xb, 0, 0);\n      return cb;\n    }\n    function I(a, b) {\n      var c = b.x - a.x,\n        d = b.y - a.y,\n        e = c * c + d * d;\n      0 !== e && (e = 1 / Math.sqrt(e), c *= e, d *= e, b.x += c, b.y += d, a.x -= c, a.y -= d);\n    }\n    if (!1 === p instanceof THREE.Camera) console.error(\"THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.\");else {\n      !0 === this.autoClear && this.clear();\n      t.setTransform(1, 0, 0, -1, v, z);\n      l.info.render.vertices = 0;\n      l.info.render.faces = 0;\n      m = r.projectScene(a, p, this.sortObjects, this.sortElements);\n      n = m.elements;\n      s = m.lights;\n      gc = 0 < s.length;\n      if (!0 === gc) {\n        vb.setRGB(0, 0, 0);\n        Qa.setRGB(0, 0, 0);\n        La.setRGB(0, 0, 0);\n        for (var J = 0, W = s.length; J < W; J++) {\n          var P = s[J],\n            X = P.color;\n          P instanceof THREE.AmbientLight ? vb.add(X) : P instanceof THREE.DirectionalLight ? Qa.add(X) : P instanceof THREE.PointLight && La.add(X);\n        }\n      }\n      J = 0;\n      for (W = n.length; J < W; J++) {\n        var H = n[J],\n          P = H.material;\n        if (!(void 0 === P || !1 === P.visible)) {\n          Va.makeEmpty();\n          if (H instanceof THREE.RenderableParticle) {\n            K = H;\n            K.x *= v;\n            K.y *= z;\n            var X = K,\n              wa = H;\n            b(P.opacity);\n            c(P.blending);\n            var Bb = void 0,\n              hb = void 0,\n              Cb = void 0,\n              Db = void 0,\n              md = H = void 0,\n              nd = void 0;\n            P instanceof THREE.ParticleBasicMaterial ? null === P.map ? (Cb = wa.object.scale.x, Db = wa.object.scale.y, Cb *= wa.scale.x * v, Db *= wa.scale.y * z, Va.min.set(X.x - Cb, X.y - Db), Va.max.set(X.x + Cb, X.y + Db), !1 !== pb.isIntersectionBox(Va) && (h(P.color.getStyle()), t.save(), t.translate(X.x, X.y), t.rotate(-wa.rotation), t.scale(Cb, Db), t.fillRect(-1, -1, 2, 2), t.restore())) : (H = P.map.image, md = H.width >> 1, nd = H.height >> 1, Cb = wa.scale.x * v, Db = wa.scale.y * z, Bb = Cb * md, hb = Db * nd, Va.min.set(X.x - Bb, X.y - hb), Va.max.set(X.x + Bb, X.y + hb), !1 !== pb.isIntersectionBox(Va) && (t.save(), t.translate(X.x, X.y), t.rotate(-wa.rotation), t.scale(Cb, -Db), t.translate(-md, -nd), t.drawImage(H, 0, 0), t.restore())) : P instanceof THREE.ParticleCanvasMaterial && (Bb = wa.scale.x * v, hb = wa.scale.y * z, Va.min.set(X.x - Bb, X.y - hb), Va.max.set(X.x + Bb, X.y + hb), !1 !== pb.isIntersectionBox(Va) && (g(P.color.getStyle()), h(P.color.getStyle()), t.save(), t.translate(X.x, X.y), t.rotate(-wa.rotation), t.scale(Bb, hb), P.program(t), t.restore()));\n          } else if (H instanceof THREE.RenderableLine) K = H.v1, L = H.v2, K.positionScreen.x *= v, K.positionScreen.y *= z, L.positionScreen.x *= v, L.positionScreen.y *= z, Va.setFromPoints([K.positionScreen, L.positionScreen]), !0 === pb.isIntersectionBox(Va) && (X = K, wa = L, b(P.opacity), c(P.blending), t.beginPath(), t.moveTo(X.positionScreen.x, X.positionScreen.y), t.lineTo(wa.positionScreen.x, wa.positionScreen.y), P instanceof THREE.LineBasicMaterial ? (d(P.linewidth), e(P.linecap), f(P.linejoin), g(P.color.getStyle()), i(null, null), t.stroke(), Va.expandByScalar(2 * P.linewidth)) : P instanceof THREE.LineDashedMaterial && (d(P.linewidth), e(P.linecap), f(P.linejoin), g(P.color.getStyle()), i(P.dashSize, P.gapSize), t.stroke(), Va.expandByScalar(2 * P.linewidth)));else if (H instanceof THREE.RenderableFace3) {\n            K = H.v1;\n            L = H.v2;\n            U = H.v3;\n            if (-1 > K.positionScreen.z || 1 < K.positionScreen.z) continue;\n            if (-1 > L.positionScreen.z || 1 < L.positionScreen.z) continue;\n            if (-1 > U.positionScreen.z || 1 < U.positionScreen.z) continue;\n            K.positionScreen.x *= v;\n            K.positionScreen.y *= z;\n            L.positionScreen.x *= v;\n            L.positionScreen.y *= z;\n            U.positionScreen.x *= v;\n            U.positionScreen.y *= z;\n            !0 === P.overdraw && (I(K.positionScreen, L.positionScreen), I(L.positionScreen, U.positionScreen), I(U.positionScreen, K.positionScreen));\n            Va.setFromPoints([K.positionScreen, L.positionScreen, U.positionScreen]);\n            x(K, L, U, 0, 1, 2, H, P);\n          } else if (H instanceof THREE.RenderableFace4) {\n            K = H.v1;\n            L = H.v2;\n            U = H.v3;\n            fa = H.v4;\n            if (-1 > K.positionScreen.z || 1 < K.positionScreen.z) continue;\n            if (-1 > L.positionScreen.z || 1 < L.positionScreen.z) continue;\n            if (-1 > U.positionScreen.z || 1 < U.positionScreen.z) continue;\n            if (-1 > fa.positionScreen.z || 1 < fa.positionScreen.z) continue;\n            K.positionScreen.x *= v;\n            K.positionScreen.y *= z;\n            L.positionScreen.x *= v;\n            L.positionScreen.y *= z;\n            U.positionScreen.x *= v;\n            U.positionScreen.y *= z;\n            fa.positionScreen.x *= v;\n            fa.positionScreen.y *= z;\n            Ca.positionScreen.copy(L.positionScreen);\n            $a.positionScreen.copy(fa.positionScreen);\n            !0 === P.overdraw && (I(K.positionScreen, L.positionScreen), I(L.positionScreen, fa.positionScreen), I(fa.positionScreen, K.positionScreen), I(U.positionScreen, Ca.positionScreen), I(U.positionScreen, $a.positionScreen));\n            Va.setFromPoints([K.positionScreen, L.positionScreen, U.positionScreen, fa.positionScreen]);\n            X = K;\n            wa = L;\n            Bb = U;\n            hb = fa;\n            Cb = Ca;\n            Db = $a;\n            l.info.render.vertices += 4;\n            l.info.render.faces++;\n            b(P.opacity);\n            c(P.blending);\n            void 0 !== P.map && null !== P.map || void 0 !== P.envMap && null !== P.envMap ? (x(X, wa, hb, 0, 1, 3, H, P), x(Cb, Bb, Db, 1, 2, 3, H, P)) : (M = X.positionScreen.x, ca = X.positionScreen.y, qa = wa.positionScreen.x, ha = wa.positionScreen.y, ra = Bb.positionScreen.x, N = Bb.positionScreen.y, Ma = hb.positionScreen.x, Na = hb.positionScreen.y, mb = Cb.positionScreen.x, Pa = Cb.positionScreen.y, ta = Db.positionScreen.x, ka = Db.positionScreen.y, P instanceof THREE.MeshLambertMaterial || P instanceof THREE.MeshPhongMaterial ? (Z.copy(P.color), oa.copy(P.emissive), P.vertexColors === THREE.FaceColors && Z.multiply(H.color), !0 === gc ? !1 === P.wireframe && P.shading == THREE.SmoothShading && 4 == H.vertexNormalsLength ? (pa.copy(vb), Y.copy(vb), da.copy(vb), la.copy(vb), q(H.v1.positionWorld, H.vertexNormalsModel[0], pa), q(H.v2.positionWorld, H.vertexNormalsModel[1], Y), q(H.v4.positionWorld, H.vertexNormalsModel[3], da), q(H.v3.positionWorld, H.vertexNormalsModel[2], la), pa.multiply(Z).add(oa), Y.multiply(Z).add(oa), da.multiply(Z).add(oa), la.multiply(Z).add(oa), Fa = E(pa, Y, da, la), y(M, ca, qa, ha, Ma, Na), G(M, ca, qa, ha, Ma, Na, 0, 0, 1, 0, 0, 1, Fa), y(mb, Pa, ra, N, ta, ka), G(mb, Pa, ra, N, ta, ka, 1, 0, 1, 1, 0, 1, Fa)) : (aa.copy(vb), q(H.centroidModel, H.normalModel, aa), aa.multiply(Z).add(oa), B(M, ca, qa, ha, ra, N, Ma, Na), !0 === P.wireframe ? C(aa, P.wireframeLinewidth, P.wireframeLinecap, P.wireframeLinejoin) : A(aa)) : (aa.addColors(Z, oa), B(M, ca, qa, ha, ra, N, Ma, Na), !0 === P.wireframe ? C(aa, P.wireframeLinewidth, P.wireframeLinecap, P.wireframeLinejoin) : A(aa))) : P instanceof THREE.MeshBasicMaterial ? (aa.copy(P.color), P.vertexColors === THREE.FaceColors && aa.multiply(H.color), B(M, ca, qa, ha, ra, N, Ma, Na), !0 === P.wireframe ? C(aa, P.wireframeLinewidth, P.wireframeLinecap, P.wireframeLinejoin) : A(aa)) : P instanceof THREE.MeshNormalMaterial ? (X = void 0, P.shading == THREE.FlatShading ? (X = H.normalModelView, aa.setRGB(X.x, X.y, X.z).multiplyScalar(0.5).addScalar(0.5), B(M, ca, qa, ha, ra, N, Ma, Na), !0 === P.wireframe ? C(aa, P.wireframeLinewidth, P.wireframeLinecap, P.wireframeLinejoin) : A(aa)) : P.shading == THREE.SmoothShading && (X = H.vertexNormalsModelView[0], pa.setRGB(X.x, X.y, X.z).multiplyScalar(0.5).addScalar(0.5), X = H.vertexNormalsModelView[1], Y.setRGB(X.x, X.y, X.z).multiplyScalar(0.5).addScalar(0.5), X = H.vertexNormalsModelView[3], da.setRGB(X.x, X.y, X.z).multiplyScalar(0.5).addScalar(0.5), X = H.vertexNormalsModelView[2], la.setRGB(X.x, X.y, X.z).multiplyScalar(0.5).addScalar(0.5), Fa = E(pa, Y, da, la), y(M, ca, qa, ha, Ma, Na), G(M, ca, qa, ha, Ma, Na, 0, 0, 1, 0, 0, 1, Fa), y(mb, Pa, ra, N, ta, ka), G(mb, Pa, ra, N, ta, ka, 1, 0, 1, 1, 0, 1, Fa))) : P instanceof THREE.MeshDepthMaterial && (Wa = p.near, ab = p.far, pa.r = pa.g = pa.b = 1 - k(X.positionScreen.z * X.positionScreen.w, Wa, ab), Y.r = Y.g = Y.b = 1 - k(wa.positionScreen.z * wa.positionScreen.w, Wa, ab), da.r = da.g = da.b = 1 - k(hb.positionScreen.z * hb.positionScreen.w, Wa, ab), la.r = la.g = la.b = 1 - k(Bb.positionScreen.z * Bb.positionScreen.w, Wa, ab), Fa = E(pa, Y, da, la), y(M, ca, qa, ha, Ma, Na), G(M, ca, qa, ha, Ma, Na, 0, 0, 1, 0, 0, 1, Fa), y(mb, Pa, ra, N, ta, ka), G(mb, Pa, ra, N, ta, ka, 1, 0, 1, 1, 0, 1, Fa)));\n          }\n          Ka.union(Va);\n        }\n      }\n      t.setTransform(1, 0, 0, 1, 0, 0);\n    }\n  };\n};\nTHREE.ShaderChunk = {\n  fog_pars_fragment: \"#ifdef USE_FOG\\nuniform vec3 fogColor;\\n#ifdef FOG_EXP2\\nuniform float fogDensity;\\n#else\\nuniform float fogNear;\\nuniform float fogFar;\\n#endif\\n#endif\",\n  fog_fragment: \"#ifdef USE_FOG\\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n#ifdef FOG_EXP2\\nconst float LOG2 = 1.442695;\\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\\n#else\\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n#endif\\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n#endif\",\n  envmap_pars_fragment: \"#ifdef USE_ENVMAP\\nuniform float reflectivity;\\nuniform samplerCube envMap;\\nuniform float flipEnvMap;\\nuniform int combine;\\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\nuniform bool useRefract;\\nuniform float refractionRatio;\\n#else\\nvarying vec3 vReflect;\\n#endif\\n#endif\",\n  envmap_fragment: \"#ifdef USE_ENVMAP\\nvec3 reflectVec;\\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\nif ( useRefract ) {\\nreflectVec = refract( cameraToVertex, normal, refractionRatio );\\n} else { \\nreflectVec = reflect( cameraToVertex, normal );\\n}\\n#else\\nreflectVec = vReflect;\\n#endif\\n#ifdef DOUBLE_SIDED\\nfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\nvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n#else\\nvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n#endif\\n#ifdef GAMMA_INPUT\\ncubeColor.xyz *= cubeColor.xyz;\\n#endif\\nif ( combine == 1 ) {\\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\\n} else if ( combine == 2 ) {\\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\\n} else {\\ngl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\\n}\\n#endif\",\n  envmap_pars_vertex: \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\\nvarying vec3 vReflect;\\nuniform float refractionRatio;\\nuniform bool useRefract;\\n#endif\",\n  worldpos_vertex: \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n#ifdef USE_SKINNING\\nvec4 worldPosition = modelMatrix * skinned;\\n#endif\\n#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\\nvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\\n#endif\\n#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n#endif\\n#endif\",\n  envmap_vertex: \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\\nvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\\nworldNormal = normalize( worldNormal );\\nvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\nif ( useRefract ) {\\nvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n} else {\\nvReflect = reflect( cameraToVertex, worldNormal );\\n}\\n#endif\",\n  map_particle_pars_fragment: \"#ifdef USE_MAP\\nuniform sampler2D map;\\n#endif\",\n  map_particle_fragment: \"#ifdef USE_MAP\\ngl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\\n#endif\",\n  map_pars_vertex: \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\\nvarying vec2 vUv;\\nuniform vec4 offsetRepeat;\\n#endif\",\n  map_pars_fragment: \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\\nvarying vec2 vUv;\\n#endif\\n#ifdef USE_MAP\\nuniform sampler2D map;\\n#endif\",\n  map_vertex: \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\\nvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\",\n  map_fragment: \"#ifdef USE_MAP\\nvec4 texelColor = texture2D( map, vUv );\\n#ifdef GAMMA_INPUT\\ntexelColor.xyz *= texelColor.xyz;\\n#endif\\ngl_FragColor = gl_FragColor * texelColor;\\n#endif\",\n  lightmap_pars_fragment: \"#ifdef USE_LIGHTMAP\\nvarying vec2 vUv2;\\nuniform sampler2D lightMap;\\n#endif\",\n  lightmap_pars_vertex: \"#ifdef USE_LIGHTMAP\\nvarying vec2 vUv2;\\n#endif\",\n  lightmap_fragment: \"#ifdef USE_LIGHTMAP\\ngl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\\n#endif\",\n  lightmap_vertex: \"#ifdef USE_LIGHTMAP\\nvUv2 = uv2;\\n#endif\",\n  bumpmap_pars_fragment: \"#ifdef USE_BUMPMAP\\nuniform sampler2D bumpMap;\\nuniform float bumpScale;\\nvec2 dHdxy_fwd() {\\nvec2 dSTdx = dFdx( vUv );\\nvec2 dSTdy = dFdy( vUv );\\nfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\nfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\nfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\nreturn vec2( dBx, dBy );\\n}\\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\nvec3 vSigmaX = dFdx( surf_pos );\\nvec3 vSigmaY = dFdy( surf_pos );\\nvec3 vN = surf_norm;\\nvec3 R1 = cross( vSigmaY, vN );\\nvec3 R2 = cross( vN, vSigmaX );\\nfloat fDet = dot( vSigmaX, R1 );\\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\\n}\\n#endif\",\n  normalmap_pars_fragment: \"#ifdef USE_NORMALMAP\\nuniform sampler2D normalMap;\\nuniform vec2 normalScale;\\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\nvec3 q0 = dFdx( eye_pos.xyz );\\nvec3 q1 = dFdy( eye_pos.xyz );\\nvec2 st0 = dFdx( vUv.st );\\nvec2 st1 = dFdy( vUv.st );\\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\nvec3 N = normalize( surf_norm );\\nvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\nmapN.xy = normalScale * mapN.xy;\\nmat3 tsn = mat3( S, T, N );\\nreturn normalize( tsn * mapN );\\n}\\n#endif\",\n  specularmap_pars_fragment: \"#ifdef USE_SPECULARMAP\\nuniform sampler2D specularMap;\\n#endif\",\n  specularmap_fragment: \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\nvec4 texelSpecular = texture2D( specularMap, vUv );\\nspecularStrength = texelSpecular.r;\\n#else\\nspecularStrength = 1.0;\\n#endif\",\n  lights_lambert_pars_vertex: \"uniform vec3 ambient;\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 ambientLightColor;\\n#if MAX_DIR_LIGHTS > 0\\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n#endif\\n#ifdef WRAP_AROUND\\nuniform vec3 wrapRGB;\\n#endif\",\n  lights_lambert_vertex: \"vLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\nvLightBack = vec3( 0.0 );\\n#endif\\ntransformedNormal = normalize( transformedNormal );\\n#if MAX_DIR_LIGHTS > 0\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\nvec3 dirVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( transformedNormal, dirVector );\\nvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n#ifdef DOUBLE_SIDED\\nvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n#ifdef WRAP_AROUND\\nvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n#endif\\n#endif\\n#ifdef WRAP_AROUND\\nvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\ndirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\\n#ifdef DOUBLE_SIDED\\ndirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\\n#endif\\n#endif\\nvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\\n#ifdef DOUBLE_SIDED\\nvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\\n#endif\\n}\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( pointLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\nlVector = normalize( lVector );\\nfloat dotProduct = dot( transformedNormal, lVector );\\nvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n#ifdef DOUBLE_SIDED\\nvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n#ifdef WRAP_AROUND\\nvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n#endif\\n#endif\\n#ifdef WRAP_AROUND\\nvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\npointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\\n#ifdef DOUBLE_SIDED\\npointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\\n#endif\\n#endif\\nvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\\n#ifdef DOUBLE_SIDED\\nvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\\n#endif\\n}\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\\nif ( spotEffect > spotLightAngleCos[ i ] ) {\\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\\nfloat lDistance = 1.0;\\nif ( spotLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\\nlVector = normalize( lVector );\\nfloat dotProduct = dot( transformedNormal, lVector );\\nvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n#ifdef DOUBLE_SIDED\\nvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n#ifdef WRAP_AROUND\\nvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n#endif\\n#endif\\n#ifdef WRAP_AROUND\\nvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\nspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\\n#ifdef DOUBLE_SIDED\\nspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\\n#endif\\n#endif\\nvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\\n#ifdef DOUBLE_SIDED\\nvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\\n#endif\\n}\\n}\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\nvec3 lVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( transformedNormal, lVector );\\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\nfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\\nvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n#ifdef DOUBLE_SIDED\\nvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\\n#endif\\n}\\n#endif\\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\\n#ifdef DOUBLE_SIDED\\nvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\\n#endif\",\n  lights_phong_pars_vertex: \"#ifndef PHONG_PER_PIXEL\\n#if MAX_POINT_LIGHTS > 0\\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\nvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\nvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\\n#endif\\n#endif\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\\nvarying vec3 vWorldPosition;\\n#endif\",\n  lights_phong_vertex: \"#ifndef PHONG_PER_PIXEL\\n#if MAX_POINT_LIGHTS > 0\\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( pointLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\nvPointLight[ i ] = vec4( lVector, lDistance );\\n}\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( spotLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\\nvSpotLight[ i ] = vec4( lVector, lDistance );\\n}\\n#endif\\n#endif\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\\nvWorldPosition = worldPosition.xyz;\\n#endif\",\n  lights_phong_pars_fragment: \"uniform vec3 ambientLightColor;\\n#if MAX_DIR_LIGHTS > 0\\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n#ifdef PHONG_PER_PIXEL\\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n#else\\nvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\\n#endif\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n#ifdef PHONG_PER_PIXEL\\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n#else\\nvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\\n#endif\\n#endif\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\\nvarying vec3 vWorldPosition;\\n#endif\\n#ifdef WRAP_AROUND\\nuniform vec3 wrapRGB;\\n#endif\\nvarying vec3 vViewPosition;\\nvarying vec3 vNormal;\",\n  lights_phong_fragment: \"vec3 normal = normalize( vNormal );\\nvec3 viewPosition = normalize( vViewPosition );\\n#ifdef DOUBLE_SIDED\\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n#endif\\n#ifdef USE_NORMALMAP\\nnormal = perturbNormal2Arb( -viewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nvec3 pointDiffuse  = vec3( 0.0 );\\nvec3 pointSpecular = vec3( 0.0 );\\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n#ifdef PHONG_PER_PIXEL\\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( pointLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\nlVector = normalize( lVector );\\n#else\\nvec3 lVector = normalize( vPointLight[ i ].xyz );\\nfloat lDistance = vPointLight[ i ].w;\\n#endif\\nfloat dotProduct = dot( normal, lVector );\\n#ifdef WRAP_AROUND\\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\\n#endif\\npointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\\nvec3 pointHalfVector = normalize( lVector + viewPosition );\\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\n#ifdef PHYSICALLY_BASED_SHADING\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\\n#else\\npointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;\\n#endif\\n}\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nvec3 spotDiffuse  = vec3( 0.0 );\\nvec3 spotSpecular = vec3( 0.0 );\\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n#ifdef PHONG_PER_PIXEL\\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( spotLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\\nlVector = normalize( lVector );\\n#else\\nvec3 lVector = normalize( vSpotLight[ i ].xyz );\\nfloat lDistance = vSpotLight[ i ].w;\\n#endif\\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\\nif ( spotEffect > spotLightAngleCos[ i ] ) {\\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\\nfloat dotProduct = dot( normal, lVector );\\n#ifdef WRAP_AROUND\\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\\n#endif\\nspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\\nvec3 spotHalfVector = normalize( lVector + viewPosition );\\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\\n#ifdef PHYSICALLY_BASED_SHADING\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\\n#else\\nspotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;\\n#endif\\n}\\n}\\n#endif\\n#if MAX_DIR_LIGHTS > 0\\nvec3 dirDiffuse  = vec3( 0.0 );\\nvec3 dirSpecular = vec3( 0.0 );\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\nvec3 dirVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( normal, dirVector );\\n#ifdef WRAP_AROUND\\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\\n#endif\\ndirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\n#ifdef PHYSICALLY_BASED_SHADING\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n#else\\ndirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;\\n#endif\\n}\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nvec3 hemiDiffuse  = vec3( 0.0 );\\nvec3 hemiSpecular = vec3( 0.0 );\\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\nvec3 lVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( normal, lVector );\\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\nhemiDiffuse += diffuse * hemiColor;\\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\nfloat hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\\nvec3 lVectorGround = -lVector;\\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\nfloat hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\\n#ifdef PHYSICALLY_BASED_SHADING\\nfloat dotProductGround = dot( normal, lVectorGround );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\n#else\\nhemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\\n#endif\\n}\\n#endif\\nvec3 totalDiffuse = vec3( 0.0 );\\nvec3 totalSpecular = vec3( 0.0 );\\n#if MAX_DIR_LIGHTS > 0\\ntotalDiffuse += dirDiffuse;\\ntotalSpecular += dirSpecular;\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\ntotalDiffuse += hemiDiffuse;\\ntotalSpecular += hemiSpecular;\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\ntotalDiffuse += pointDiffuse;\\ntotalSpecular += pointSpecular;\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\ntotalDiffuse += spotDiffuse;\\ntotalSpecular += spotSpecular;\\n#endif\\n#ifdef METAL\\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\\n#else\\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\\n#endif\",\n  color_pars_fragment: \"#ifdef USE_COLOR\\nvarying vec3 vColor;\\n#endif\",\n  color_fragment: \"#ifdef USE_COLOR\\ngl_FragColor = gl_FragColor * vec4( vColor, opacity );\\n#endif\",\n  color_pars_vertex: \"#ifdef USE_COLOR\\nvarying vec3 vColor;\\n#endif\",\n  color_vertex: \"#ifdef USE_COLOR\\n#ifdef GAMMA_INPUT\\nvColor = color * color;\\n#else\\nvColor = color;\\n#endif\\n#endif\",\n  skinning_pars_vertex: \"#ifdef USE_SKINNING\\n#ifdef BONE_TEXTURE\\nuniform sampler2D boneTexture;\\nmat4 getBoneMatrix( const in float i ) {\\nfloat j = i * 4.0;\\nfloat x = mod( j, N_BONE_PIXEL_X );\\nfloat y = floor( j / N_BONE_PIXEL_X );\\nconst float dx = 1.0 / N_BONE_PIXEL_X;\\nconst float dy = 1.0 / N_BONE_PIXEL_Y;\\ny = dy * ( y + 0.5 );\\nvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\nvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\nvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\nvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\nmat4 bone = mat4( v1, v2, v3, v4 );\\nreturn bone;\\n}\\n#else\\nuniform mat4 boneGlobalMatrices[ MAX_BONES ];\\nmat4 getBoneMatrix( const in float i ) {\\nmat4 bone = boneGlobalMatrices[ int(i) ];\\nreturn bone;\\n}\\n#endif\\n#endif\",\n  skinbase_vertex: \"#ifdef USE_SKINNING\\nmat4 boneMatX = getBoneMatrix( skinIndex.x );\\nmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n#endif\",\n  skinning_vertex: \"#ifdef USE_SKINNING\\n#ifdef USE_MORPHTARGETS\\nvec4 skinVertex = vec4( morphed, 1.0 );\\n#else\\nvec4 skinVertex = vec4( position, 1.0 );\\n#endif\\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\\nskinned \\t  += boneMatY * skinVertex * skinWeight.y;\\n#endif\",\n  morphtarget_pars_vertex: \"#ifdef USE_MORPHTARGETS\\n#ifndef USE_MORPHNORMALS\\nuniform float morphTargetInfluences[ 8 ];\\n#else\\nuniform float morphTargetInfluences[ 4 ];\\n#endif\\n#endif\",\n  morphtarget_vertex: \"#ifdef USE_MORPHTARGETS\\nvec3 morphed = vec3( 0.0 );\\nmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\nmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\nmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\nmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n#ifndef USE_MORPHNORMALS\\nmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\nmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\nmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\nmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n#endif\\nmorphed += position;\\n#endif\",\n  default_vertex: \"vec4 mvPosition;\\n#ifdef USE_SKINNING\\nmvPosition = modelViewMatrix * skinned;\\n#endif\\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\\nmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\\n#endif\\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\\nmvPosition = modelViewMatrix * vec4( position, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\",\n  morphnormal_vertex: \"#ifdef USE_MORPHNORMALS\\nvec3 morphedNormal = vec3( 0.0 );\\nmorphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\nmorphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\nmorphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\nmorphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\nmorphedNormal += normal;\\n#endif\",\n  skinnormal_vertex: \"#ifdef USE_SKINNING\\nmat4 skinMatrix = skinWeight.x * boneMatX;\\nskinMatrix \\t+= skinWeight.y * boneMatY;\\n#ifdef USE_MORPHNORMALS\\nvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\\n#else\\nvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\\n#endif\\n#endif\",\n  defaultnormal_vertex: \"vec3 objectNormal;\\n#ifdef USE_SKINNING\\nobjectNormal = skinnedNormal.xyz;\\n#endif\\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\\nobjectNormal = morphedNormal;\\n#endif\\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\\nobjectNormal = normal;\\n#endif\\n#ifdef FLIP_SIDED\\nobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\",\n  shadowmap_pars_fragment: \"#ifdef USE_SHADOWMAP\\nuniform sampler2D shadowMap[ MAX_SHADOWS ];\\nuniform vec2 shadowMapSize[ MAX_SHADOWS ];\\nuniform float shadowDarkness[ MAX_SHADOWS ];\\nuniform float shadowBias[ MAX_SHADOWS ];\\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\nfloat unpackDepth( const in vec4 rgba_depth ) {\\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\nfloat depth = dot( rgba_depth, bit_shift );\\nreturn depth;\\n}\\n#endif\",\n  shadowmap_fragment: \"#ifdef USE_SHADOWMAP\\n#ifdef SHADOWMAP_DEBUG\\nvec3 frustumColors[3];\\nfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\\nfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\\nfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\\n#endif\\n#ifdef SHADOWMAP_CASCADE\\nint inFrustumCount = 0;\\n#endif\\nfloat fDepth;\\nvec3 shadowColor = vec3( 1.0 );\\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\nvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\nbool inFrustum = all( inFrustumVec );\\n#ifdef SHADOWMAP_CASCADE\\ninFrustumCount += int( inFrustum );\\nbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\\n#else\\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n#endif\\nbool frustumTest = all( frustumTestVec );\\nif ( frustumTest ) {\\nshadowCoord.z += shadowBias[ i ];\\n#if defined( SHADOWMAP_TYPE_PCF )\\nfloat shadow = 0.0;\\nconst float shadowDelta = 1.0 / 9.0;\\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\nfloat dx0 = -1.25 * xPixelOffset;\\nfloat dy0 = -1.25 * yPixelOffset;\\nfloat dx1 = 1.25 * xPixelOffset;\\nfloat dy1 = 1.25 * yPixelOffset;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\nfloat shadow = 0.0;\\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\nfloat dx0 = -1.0 * xPixelOffset;\\nfloat dy0 = -1.0 * yPixelOffset;\\nfloat dx1 = 1.0 * xPixelOffset;\\nfloat dy1 = 1.0 * yPixelOffset;\\nmat3 shadowKernel;\\nmat3 depthKernel;\\ndepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\nif ( depthKernel[0][0] < shadowCoord.z ) shadowKernel[0][0] = 0.25;\\nelse shadowKernel[0][0] = 0.0;\\ndepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\nif ( depthKernel[0][1] < shadowCoord.z ) shadowKernel[0][1] = 0.25;\\nelse shadowKernel[0][1] = 0.0;\\ndepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\nif ( depthKernel[0][2] < shadowCoord.z ) shadowKernel[0][2] = 0.25;\\nelse shadowKernel[0][2] = 0.0;\\ndepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\nif ( depthKernel[1][0] < shadowCoord.z ) shadowKernel[1][0] = 0.25;\\nelse shadowKernel[1][0] = 0.0;\\ndepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\nif ( depthKernel[1][1] < shadowCoord.z ) shadowKernel[1][1] = 0.25;\\nelse shadowKernel[1][1] = 0.0;\\ndepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\nif ( depthKernel[1][2] < shadowCoord.z ) shadowKernel[1][2] = 0.25;\\nelse shadowKernel[1][2] = 0.0;\\ndepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\nif ( depthKernel[2][0] < shadowCoord.z ) shadowKernel[2][0] = 0.25;\\nelse shadowKernel[2][0] = 0.0;\\ndepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\nif ( depthKernel[2][1] < shadowCoord.z ) shadowKernel[2][1] = 0.25;\\nelse shadowKernel[2][1] = 0.0;\\ndepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\nif ( depthKernel[2][2] < shadowCoord.z ) shadowKernel[2][2] = 0.25;\\nelse shadowKernel[2][2] = 0.0;\\nvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\\nshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\\nshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\\nvec4 shadowValues;\\nshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\\nshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\\nshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\\nshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\\nshadow = dot( shadowValues, vec4( 1.0 ) );\\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n#else\\nvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\\nfloat fDepth = unpackDepth( rgbaDepth );\\nif ( fDepth < shadowCoord.z )\\nshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\\n#endif\\n}\\n#ifdef SHADOWMAP_DEBUG\\n#ifdef SHADOWMAP_CASCADE\\nif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\\n#else\\nif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\\n#endif\\n#endif\\n}\\n#ifdef GAMMA_OUTPUT\\nshadowColor *= shadowColor;\\n#endif\\ngl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\\n#endif\",\n  shadowmap_pars_vertex: \"#ifdef USE_SHADOWMAP\\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\nuniform mat4 shadowMatrix[ MAX_SHADOWS ];\\n#endif\",\n  shadowmap_vertex: \"#ifdef USE_SHADOWMAP\\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\n}\\n#endif\",\n  alphatest_fragment: \"#ifdef ALPHATEST\\nif ( gl_FragColor.a < ALPHATEST ) discard;\\n#endif\",\n  linear_to_gamma_fragment: \"#ifdef GAMMA_OUTPUT\\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\\n#endif\"\n};\nTHREE.UniformsUtils = {\n  merge: function merge(a) {\n    var b,\n      c,\n      d,\n      e = {};\n    for (b = 0; b < a.length; b++) for (c in d = this.clone(a[b]), d) e[c] = d[c];\n    return e;\n  },\n  clone: function clone(a) {\n    var b,\n      c,\n      d,\n      e = {};\n    for (b in a) for (c in e[b] = {}, a[b]) d = a[b][c], e[b][c] = d instanceof THREE.Color || d instanceof THREE.Vector2 || d instanceof THREE.Vector3 || d instanceof THREE.Vector4 || d instanceof THREE.Matrix4 || d instanceof THREE.Texture ? d.clone() : d instanceof Array ? d.slice() : d;\n    return e;\n  }\n};\nTHREE.UniformsLib = {\n  common: {\n    diffuse: {\n      type: \"c\",\n      value: new THREE.Color(15658734)\n    },\n    opacity: {\n      type: \"f\",\n      value: 1\n    },\n    map: {\n      type: \"t\",\n      value: null\n    },\n    offsetRepeat: {\n      type: \"v4\",\n      value: new THREE.Vector4(0, 0, 1, 1)\n    },\n    lightMap: {\n      type: \"t\",\n      value: null\n    },\n    specularMap: {\n      type: \"t\",\n      value: null\n    },\n    envMap: {\n      type: \"t\",\n      value: null\n    },\n    flipEnvMap: {\n      type: \"f\",\n      value: -1\n    },\n    useRefract: {\n      type: \"i\",\n      value: 0\n    },\n    reflectivity: {\n      type: \"f\",\n      value: 1\n    },\n    refractionRatio: {\n      type: \"f\",\n      value: 0.98\n    },\n    combine: {\n      type: \"i\",\n      value: 0\n    },\n    morphTargetInfluences: {\n      type: \"f\",\n      value: 0\n    }\n  },\n  bump: {\n    bumpMap: {\n      type: \"t\",\n      value: null\n    },\n    bumpScale: {\n      type: \"f\",\n      value: 1\n    }\n  },\n  normalmap: {\n    normalMap: {\n      type: \"t\",\n      value: null\n    },\n    normalScale: {\n      type: \"v2\",\n      value: new THREE.Vector2(1, 1)\n    }\n  },\n  fog: {\n    fogDensity: {\n      type: \"f\",\n      value: 2.5E-4\n    },\n    fogNear: {\n      type: \"f\",\n      value: 1\n    },\n    fogFar: {\n      type: \"f\",\n      value: 2E3\n    },\n    fogColor: {\n      type: \"c\",\n      value: new THREE.Color(16777215)\n    }\n  },\n  lights: {\n    ambientLightColor: {\n      type: \"fv\",\n      value: []\n    },\n    directionalLightDirection: {\n      type: \"fv\",\n      value: []\n    },\n    directionalLightColor: {\n      type: \"fv\",\n      value: []\n    },\n    hemisphereLightDirection: {\n      type: \"fv\",\n      value: []\n    },\n    hemisphereLightSkyColor: {\n      type: \"fv\",\n      value: []\n    },\n    hemisphereLightGroundColor: {\n      type: \"fv\",\n      value: []\n    },\n    pointLightColor: {\n      type: \"fv\",\n      value: []\n    },\n    pointLightPosition: {\n      type: \"fv\",\n      value: []\n    },\n    pointLightDistance: {\n      type: \"fv1\",\n      value: []\n    },\n    spotLightColor: {\n      type: \"fv\",\n      value: []\n    },\n    spotLightPosition: {\n      type: \"fv\",\n      value: []\n    },\n    spotLightDirection: {\n      type: \"fv\",\n      value: []\n    },\n    spotLightDistance: {\n      type: \"fv1\",\n      value: []\n    },\n    spotLightAngleCos: {\n      type: \"fv1\",\n      value: []\n    },\n    spotLightExponent: {\n      type: \"fv1\",\n      value: []\n    }\n  },\n  particle: {\n    psColor: {\n      type: \"c\",\n      value: new THREE.Color(15658734)\n    },\n    opacity: {\n      type: \"f\",\n      value: 1\n    },\n    size: {\n      type: \"f\",\n      value: 1\n    },\n    scale: {\n      type: \"f\",\n      value: 1\n    },\n    map: {\n      type: \"t\",\n      value: null\n    },\n    fogDensity: {\n      type: \"f\",\n      value: 2.5E-4\n    },\n    fogNear: {\n      type: \"f\",\n      value: 1\n    },\n    fogFar: {\n      type: \"f\",\n      value: 2E3\n    },\n    fogColor: {\n      type: \"c\",\n      value: new THREE.Color(16777215)\n    }\n  },\n  shadowmap: {\n    shadowMap: {\n      type: \"tv\",\n      value: []\n    },\n    shadowMapSize: {\n      type: \"v2v\",\n      value: []\n    },\n    shadowBias: {\n      type: \"fv1\",\n      value: []\n    },\n    shadowDarkness: {\n      type: \"fv1\",\n      value: []\n    },\n    shadowMatrix: {\n      type: \"m4v\",\n      value: []\n    }\n  }\n};\nTHREE.ShaderLib = {\n  basic: {\n    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),\n    vertexShader: [THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, \"void main() {\", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, \"#ifdef USE_ENVMAP\", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, \"#endif\", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform vec3 diffuse;\\nuniform float opacity;\", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, \"void main() {\\ngl_FragColor = vec4( diffuse, opacity );\", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, \"}\"].join(\"\\n\")\n  },\n  lambert: {\n    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {\n      ambient: {\n        type: \"c\",\n        value: new THREE.Color(16777215)\n      },\n      emissive: {\n        type: \"c\",\n        value: new THREE.Color(0)\n      },\n      wrapRGB: {\n        type: \"v3\",\n        value: new THREE.Vector3(1, 1, 1)\n      }\n    }]),\n    vertexShader: [\"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\nvarying vec3 vLightBack;\\n#endif\", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, \"void main() {\", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\nvarying vec3 vLightBack;\\n#endif\", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, \"void main() {\\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );\", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, \"#ifdef DOUBLE_SIDED\\nif ( gl_FrontFacing )\\ngl_FragColor.xyz *= vLightFront;\\nelse\\ngl_FragColor.xyz *= vLightBack;\\n#else\\ngl_FragColor.xyz *= vLightFront;\\n#endif\", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, \"}\"].join(\"\\n\")\n  },\n  phong: {\n    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {\n      ambient: {\n        type: \"c\",\n        value: new THREE.Color(16777215)\n      },\n      emissive: {\n        type: \"c\",\n        value: new THREE.Color(0)\n      },\n      specular: {\n        type: \"c\",\n        value: new THREE.Color(1118481)\n      },\n      shininess: {\n        type: \"f\",\n        value: 30\n      },\n      wrapRGB: {\n        type: \"v3\",\n        value: new THREE.Vector3(1, 1, 1)\n      }\n    }]),\n    vertexShader: [\"#define PHONG\\nvarying vec3 vViewPosition;\\nvarying vec3 vNormal;\", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, \"void main() {\", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, \"vNormal = normalize( transformedNormal );\", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, \"vViewPosition = -mvPosition.xyz;\", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform vec3 ambient;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, \"void main() {\\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );\", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, \"}\"].join(\"\\n\")\n  },\n  particle_basic: {\n    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]),\n    vertexShader: [\"uniform float size;\\nuniform float scale;\", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, \"void main() {\", THREE.ShaderChunk.color_vertex, \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n#ifdef USE_SIZEATTENUATION\\ngl_PointSize = size * ( scale / length( mvPosition.xyz ) );\\n#else\\ngl_PointSize = size;\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, \"}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform vec3 psColor;\\nuniform float opacity;\", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, \"void main() {\\ngl_FragColor = vec4( psColor, opacity );\", THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, \"}\"].join(\"\\n\")\n  },\n  dashed: {\n    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {\n      scale: {\n        type: \"f\",\n        value: 1\n      },\n      dashSize: {\n        type: \"f\",\n        value: 1\n      },\n      totalSize: {\n        type: \"f\",\n        value: 2\n      }\n    }]),\n    vertexShader: [\"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\", THREE.ShaderChunk.color_pars_vertex, \"void main() {\", THREE.ShaderChunk.color_vertex, \"vLineDistance = scale * lineDistance;\\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\\n}\"].join(\"\\n\"),\n    fragmentShader: [\"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, \"void main() {\\nif ( mod( vLineDistance, totalSize ) > dashSize ) {\\ndiscard;\\n}\\ngl_FragColor = vec4( diffuse, opacity );\", THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.fog_fragment, \"}\"].join(\"\\n\")\n  },\n  depth: {\n    uniforms: {\n      mNear: {\n        type: \"f\",\n        value: 1\n      },\n      mFar: {\n        type: \"f\",\n        value: 2E3\n      },\n      opacity: {\n        type: \"f\",\n        value: 1\n      }\n    },\n    vertexShader: \"void main() {\\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",\n    fragmentShader: \"uniform float mNear;\\nuniform float mFar;\\nuniform float opacity;\\nvoid main() {\\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\nfloat color = 1.0 - smoothstep( mNear, mFar, depth );\\ngl_FragColor = vec4( vec3( color ), opacity );\\n}\"\n  },\n  normal: {\n    uniforms: {\n      opacity: {\n        type: \"f\",\n        value: 1\n      }\n    },\n    vertexShader: \"varying vec3 vNormal;\\nvoid main() {\\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\nvNormal = normalize( normalMatrix * normal );\\ngl_Position = projectionMatrix * mvPosition;\\n}\",\n    fragmentShader: \"uniform float opacity;\\nvarying vec3 vNormal;\\nvoid main() {\\ngl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\\n}\"\n  },\n  normalmap: {\n    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {\n      enableAO: {\n        type: \"i\",\n        value: 0\n      },\n      enableDiffuse: {\n        type: \"i\",\n        value: 0\n      },\n      enableSpecular: {\n        type: \"i\",\n        value: 0\n      },\n      enableReflection: {\n        type: \"i\",\n        value: 0\n      },\n      enableDisplacement: {\n        type: \"i\",\n        value: 0\n      },\n      tDisplacement: {\n        type: \"t\",\n        value: null\n      },\n      tDiffuse: {\n        type: \"t\",\n        value: null\n      },\n      tCube: {\n        type: \"t\",\n        value: null\n      },\n      tNormal: {\n        type: \"t\",\n        value: null\n      },\n      tSpecular: {\n        type: \"t\",\n        value: null\n      },\n      tAO: {\n        type: \"t\",\n        value: null\n      },\n      uNormalScale: {\n        type: \"v2\",\n        value: new THREE.Vector2(1, 1)\n      },\n      uDisplacementBias: {\n        type: \"f\",\n        value: 0\n      },\n      uDisplacementScale: {\n        type: \"f\",\n        value: 1\n      },\n      uDiffuseColor: {\n        type: \"c\",\n        value: new THREE.Color(16777215)\n      },\n      uSpecularColor: {\n        type: \"c\",\n        value: new THREE.Color(1118481)\n      },\n      uAmbientColor: {\n        type: \"c\",\n        value: new THREE.Color(16777215)\n      },\n      uShininess: {\n        type: \"f\",\n        value: 30\n      },\n      uOpacity: {\n        type: \"f\",\n        value: 1\n      },\n      useRefract: {\n        type: \"i\",\n        value: 0\n      },\n      uRefractionRatio: {\n        type: \"f\",\n        value: 0.98\n      },\n      uReflectivity: {\n        type: \"f\",\n        value: 0.5\n      },\n      uOffset: {\n        type: \"v2\",\n        value: new THREE.Vector2(0, 0)\n      },\n      uRepeat: {\n        type: \"v2\",\n        value: new THREE.Vector2(1, 1)\n      },\n      wrapRGB: {\n        type: \"v3\",\n        value: new THREE.Vector3(1, 1, 1)\n      }\n    }]),\n    fragmentShader: [\"uniform vec3 uAmbientColor;\\nuniform vec3 uDiffuseColor;\\nuniform vec3 uSpecularColor;\\nuniform float uShininess;\\nuniform float uOpacity;\\nuniform bool enableDiffuse;\\nuniform bool enableSpecular;\\nuniform bool enableAO;\\nuniform bool enableReflection;\\nuniform sampler2D tDiffuse;\\nuniform sampler2D tNormal;\\nuniform sampler2D tSpecular;\\nuniform sampler2D tAO;\\nuniform samplerCube tCube;\\nuniform vec2 uNormalScale;\\nuniform bool useRefract;\\nuniform float uRefractionRatio;\\nuniform float uReflectivity;\\nvarying vec3 vTangent;\\nvarying vec3 vBinormal;\\nvarying vec3 vNormal;\\nvarying vec2 vUv;\\nuniform vec3 ambientLightColor;\\n#if MAX_DIR_LIGHTS > 0\\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n#endif\\n#ifdef WRAP_AROUND\\nuniform vec3 wrapRGB;\\n#endif\\nvarying vec3 vWorldPosition;\\nvarying vec3 vViewPosition;\", THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, \"void main() {\\ngl_FragColor = vec4( vec3( 1.0 ), uOpacity );\\nvec3 specularTex = vec3( 1.0 );\\nvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\\nnormalTex.xy *= uNormalScale;\\nnormalTex = normalize( normalTex );\\nif( enableDiffuse ) {\\n#ifdef GAMMA_INPUT\\nvec4 texelColor = texture2D( tDiffuse, vUv );\\ntexelColor.xyz *= texelColor.xyz;\\ngl_FragColor = gl_FragColor * texelColor;\\n#else\\ngl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\\n#endif\\n}\\nif( enableAO ) {\\n#ifdef GAMMA_INPUT\\nvec4 aoColor = texture2D( tAO, vUv );\\naoColor.xyz *= aoColor.xyz;\\ngl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\\n#else\\ngl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\\n#endif\\n}\\nif( enableSpecular )\\nspecularTex = texture2D( tSpecular, vUv ).xyz;\\nmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\\nvec3 finalNormal = tsb * normalTex;\\n#ifdef FLIP_SIDED\\nfinalNormal = -finalNormal;\\n#endif\\nvec3 normal = normalize( finalNormal );\\nvec3 viewPosition = normalize( vViewPosition );\\n#if MAX_POINT_LIGHTS > 0\\nvec3 pointDiffuse = vec3( 0.0 );\\nvec3 pointSpecular = vec3( 0.0 );\\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\nvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\\nfloat pointDistance = 1.0;\\nif ( pointLightDistance[ i ] > 0.0 )\\npointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\\npointVector = normalize( pointVector );\\n#ifdef WRAP_AROUND\\nfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\\nfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\\n#endif\\npointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;\\nvec3 pointHalfVector = normalize( pointVector + viewPosition );\\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\nfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );\\n#ifdef PHYSICALLY_BASED_SHADING\\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\\nvec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\\n#else\\npointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;\\n#endif\\n}\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nvec3 spotDiffuse = vec3( 0.0 );\\nvec3 spotSpecular = vec3( 0.0 );\\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\nvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\\nfloat spotDistance = 1.0;\\nif ( spotLightDistance[ i ] > 0.0 )\\nspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\\nspotVector = normalize( spotVector );\\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\\nif ( spotEffect > spotLightAngleCos[ i ] ) {\\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\\n#ifdef WRAP_AROUND\\nfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\\nfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\\n#endif\\nspotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;\\nvec3 spotHalfVector = normalize( spotVector + viewPosition );\\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\\nfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );\\n#ifdef PHYSICALLY_BASED_SHADING\\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\\nvec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\\n#else\\nspotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;\\n#endif\\n}\\n}\\n#endif\\n#if MAX_DIR_LIGHTS > 0\\nvec3 dirDiffuse = vec3( 0.0 );\\nvec3 dirSpecular = vec3( 0.0 );\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\nvec3 dirVector = normalize( lDirection.xyz );\\n#ifdef WRAP_AROUND\\nfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\\nfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\\nvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\\n#else\\nfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\\n#endif\\ndirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;\\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\nfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );\\n#ifdef PHYSICALLY_BASED_SHADING\\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\\nvec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n#else\\ndirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;\\n#endif\\n}\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nvec3 hemiDiffuse  = vec3( 0.0 );\\nvec3 hemiSpecular = vec3( 0.0 );\\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\nvec3 lVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( normal, lVector );\\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\nhemiDiffuse += uDiffuseColor * hemiColor;\\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\nfloat hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );\\nvec3 lVectorGround = -lVector;\\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\nfloat hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );\\n#ifdef PHYSICALLY_BASED_SHADING\\nfloat dotProductGround = dot( normal, lVectorGround );\\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\\nvec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\\nvec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\n#else\\nhemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\\n#endif\\n}\\n#endif\\nvec3 totalDiffuse = vec3( 0.0 );\\nvec3 totalSpecular = vec3( 0.0 );\\n#if MAX_DIR_LIGHTS > 0\\ntotalDiffuse += dirDiffuse;\\ntotalSpecular += dirSpecular;\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\ntotalDiffuse += hemiDiffuse;\\ntotalSpecular += hemiSpecular;\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\ntotalDiffuse += pointDiffuse;\\ntotalSpecular += pointSpecular;\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\ntotalDiffuse += spotDiffuse;\\ntotalSpecular += spotSpecular;\\n#endif\\n#ifdef METAL\\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );\\n#else\\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;\\n#endif\\nif ( enableReflection ) {\\nvec3 vReflect;\\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\nif ( useRefract ) {\\nvReflect = refract( cameraToVertex, normal, uRefractionRatio );\\n} else {\\nvReflect = reflect( cameraToVertex, normal );\\n}\\nvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\\n#ifdef GAMMA_INPUT\\ncubeColor.xyz *= cubeColor.xyz;\\n#endif\\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );\\n}\", THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, \"}\"].join(\"\\n\"),\n    vertexShader: [\"attribute vec4 tangent;\\nuniform vec2 uOffset;\\nuniform vec2 uRepeat;\\nuniform bool enableDisplacement;\\n#ifdef VERTEX_TEXTURES\\nuniform sampler2D tDisplacement;\\nuniform float uDisplacementScale;\\nuniform float uDisplacementBias;\\n#endif\\nvarying vec3 vTangent;\\nvarying vec3 vBinormal;\\nvarying vec3 vNormal;\\nvarying vec2 vUv;\\nvarying vec3 vWorldPosition;\\nvarying vec3 vViewPosition;\", THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, \"void main() {\", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, \"#ifdef USE_SKINNING\\nvNormal = normalize( normalMatrix * skinnedNormal.xyz );\\nvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\\nvTangent = normalize( normalMatrix * skinnedTangent.xyz );\\n#else\\nvNormal = normalize( normalMatrix * normal );\\nvTangent = normalize( normalMatrix * tangent.xyz );\\n#endif\\nvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\\nvUv = uv * uRepeat + uOffset;\\nvec3 displacedPosition;\\n#ifdef VERTEX_TEXTURES\\nif ( enableDisplacement ) {\\nvec3 dv = texture2D( tDisplacement, uv ).xyz;\\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\\ndisplacedPosition = position + normalize( normal ) * df;\\n} else {\\n#ifdef USE_SKINNING\\nvec4 skinVertex = vec4( position, 1.0 );\\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\\nskinned \\t  += boneMatY * skinVertex * skinWeight.y;\\ndisplacedPosition  = skinned.xyz;\\n#else\\ndisplacedPosition = position;\\n#endif\\n}\\n#else\\n#ifdef USE_SKINNING\\nvec4 skinVertex = vec4( position, 1.0 );\\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\\nskinned \\t  += boneMatY * skinVertex * skinWeight.y;\\ndisplacedPosition  = skinned.xyz;\\n#else\\ndisplacedPosition = position;\\n#endif\\n#endif\\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\\nvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\\nvWorldPosition = worldPosition.xyz;\\nvViewPosition = -mvPosition.xyz;\\n#ifdef USE_SHADOWMAP\\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\n}\\n#endif\\n}\"].join(\"\\n\")\n  },\n  cube: {\n    uniforms: {\n      tCube: {\n        type: \"t\",\n        value: null\n      },\n      tFlip: {\n        type: \"f\",\n        value: -1\n      }\n    },\n    vertexShader: \"varying vec3 vWorldPosition;\\nvoid main() {\\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\nvWorldPosition = worldPosition.xyz;\\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",\n    fragmentShader: \"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\nvoid main() {\\ngl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n}\"\n  },\n  depthRGBA: {\n    uniforms: {},\n    vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, \"void main() {\", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, \"}\"].join(\"\\n\"),\n    fragmentShader: \"vec4 pack_depth( const in float depth ) {\\nconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\\nvec4 res = fract( depth * bit_shift );\\nres -= res.xxyz * bit_mask;\\nreturn res;\\n}\\nvoid main() {\\ngl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\\n}\"\n  }\n};\nTHREE.WebGLRenderer = function (a) {\n  function b(a) {\n    if (a.__webglCustomAttributesList) for (var b in a.__webglCustomAttributesList) j.deleteBuffer(a.__webglCustomAttributesList[b].buffer);\n  }\n  function c(a, b) {\n    var c = a.vertices.length,\n      d = b.material;\n    if (d.attributes) {\n      void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);\n      for (var e in d.attributes) {\n        var f = d.attributes[e];\n        if (!f.__webglInitialized || f.createUniqueBuffers) {\n          f.__webglInitialized = !0;\n          var g = 1;\n          \"v2\" === f.type ? g = 2 : \"v3\" === f.type ? g = 3 : \"v4\" === f.type ? g = 4 : \"c\" === f.type && (g = 3);\n          f.size = g;\n          f.array = new Float32Array(c * g);\n          f.buffer = j.createBuffer();\n          f.buffer.belongsToAttribute = e;\n          f.needsUpdate = !0;\n        }\n        a.__webglCustomAttributesList.push(f);\n      }\n    }\n  }\n  function d(a, b) {\n    var c = b.geometry,\n      d = a.faces3,\n      h = a.faces4,\n      i = 3 * d.length + 4 * h.length,\n      k = 1 * d.length + 2 * h.length,\n      h = 3 * d.length + 4 * h.length,\n      d = e(b, a),\n      n = g(d),\n      l = f(d),\n      m = d.vertexColors ? d.vertexColors : !1;\n    a.__vertexArray = new Float32Array(3 * i);\n    l && (a.__normalArray = new Float32Array(3 * i));\n    c.hasTangents && (a.__tangentArray = new Float32Array(4 * i));\n    m && (a.__colorArray = new Float32Array(3 * i));\n    if (n) {\n      if (0 < c.faceUvs.length || 0 < c.faceVertexUvs.length) a.__uvArray = new Float32Array(2 * i);\n      if (1 < c.faceUvs.length || 1 < c.faceVertexUvs.length) a.__uv2Array = new Float32Array(2 * i);\n    }\n    b.geometry.skinWeights.length && b.geometry.skinIndices.length && (a.__skinIndexArray = new Float32Array(4 * i), a.__skinWeightArray = new Float32Array(4 * i));\n    a.__faceArray = new Uint16Array(3 * k);\n    a.__lineArray = new Uint16Array(2 * h);\n    if (a.numMorphTargets) {\n      a.__morphTargetsArrays = [];\n      c = 0;\n      for (n = a.numMorphTargets; c < n; c++) a.__morphTargetsArrays.push(new Float32Array(3 * i));\n    }\n    if (a.numMorphNormals) {\n      a.__morphNormalsArrays = [];\n      c = 0;\n      for (n = a.numMorphNormals; c < n; c++) a.__morphNormalsArrays.push(new Float32Array(3 * i));\n    }\n    a.__webglFaceCount = 3 * k;\n    a.__webglLineCount = 2 * h;\n    if (d.attributes) {\n      void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);\n      for (var p in d.attributes) {\n        var k = d.attributes[p],\n          c = {},\n          q;\n        for (q in k) c[q] = k[q];\n        if (!c.__webglInitialized || c.createUniqueBuffers) c.__webglInitialized = !0, h = 1, \"v2\" === c.type ? h = 2 : \"v3\" === c.type ? h = 3 : \"v4\" === c.type ? h = 4 : \"c\" === c.type && (h = 3), c.size = h, c.array = new Float32Array(i * h), c.buffer = j.createBuffer(), c.buffer.belongsToAttribute = p, k.needsUpdate = !0, c.__original = k;\n        a.__webglCustomAttributesList.push(c);\n      }\n    }\n    a.__inittedArrays = !0;\n  }\n  function e(a, b) {\n    return a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[b.materialIndex] : a.material;\n  }\n  function f(a) {\n    return a instanceof THREE.MeshBasicMaterial && !a.envMap || a instanceof THREE.MeshDepthMaterial ? !1 : a && void 0 !== a.shading && a.shading === THREE.SmoothShading ? THREE.SmoothShading : THREE.FlatShading;\n  }\n  function g(a) {\n    return a.map || a.lightMap || a.bumpMap || a.normalMap || a.specularMap || a instanceof THREE.ShaderMaterial ? !0 : !1;\n  }\n  function h(a) {\n    var b, c, d;\n    for (b in a.attributes) d = \"index\" === b ? j.ELEMENT_ARRAY_BUFFER : j.ARRAY_BUFFER, c = a.attributes[b], c.buffer = j.createBuffer(), j.bindBuffer(d, c.buffer), j.bufferData(d, c.array, j.STATIC_DRAW);\n  }\n  function i(a, b, c) {\n    var d = a.attributes,\n      e = d.index,\n      f = d.position,\n      g = d.normal,\n      h = d.uv,\n      i = d.color,\n      d = d.tangent;\n    a.elementsNeedUpdate && void 0 !== e && (j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, e.buffer), j.bufferData(j.ELEMENT_ARRAY_BUFFER, e.array, b));\n    a.verticesNeedUpdate && void 0 !== f && (j.bindBuffer(j.ARRAY_BUFFER, f.buffer), j.bufferData(j.ARRAY_BUFFER, f.array, b));\n    a.normalsNeedUpdate && void 0 !== g && (j.bindBuffer(j.ARRAY_BUFFER, g.buffer), j.bufferData(j.ARRAY_BUFFER, g.array, b));\n    a.uvsNeedUpdate && void 0 !== h && (j.bindBuffer(j.ARRAY_BUFFER, h.buffer), j.bufferData(j.ARRAY_BUFFER, h.array, b));\n    a.colorsNeedUpdate && void 0 !== i && (j.bindBuffer(j.ARRAY_BUFFER, i.buffer), j.bufferData(j.ARRAY_BUFFER, i.array, b));\n    a.tangentsNeedUpdate && void 0 !== d && (j.bindBuffer(j.ARRAY_BUFFER, d.buffer), j.bufferData(j.ARRAY_BUFFER, d.array, b));\n    if (c) for (var k in a.attributes) delete a.attributes[k].array;\n  }\n  function k(a) {\n    Ka[a] || (j.enableVertexAttribArray(a), Ka[a] = !0);\n  }\n  function l() {\n    for (var a in Ka) Ka[a] && (j.disableVertexAttribArray(a), Ka[a] = !1);\n  }\n  function m(a, b) {\n    return a.z !== b.z ? b.z - a.z : b.id - a.id;\n  }\n  function n(a, b) {\n    return b[0] - a[0];\n  }\n  function s(a, b, c) {\n    if (a.length) for (var d = 0, e = a.length; d < e; d++) aa = mb = null, ta = ka = la = da = Wa = ia = Z = -1, bb = !0, a[d].render(b, c, mc, pb), aa = mb = null, ta = ka = la = da = Wa = ia = Z = -1, bb = !0;\n  }\n  function r(a, b, c, d, e, f, g, j) {\n    var h, i, k, n;\n    b ? (i = a.length - 1, n = b = -1) : (i = 0, b = a.length, n = 1);\n    for (var l = i; l !== b; l += n) if (h = a[l], h.render) {\n      i = h.object;\n      k = h.buffer;\n      if (j) h = j;else {\n        h = h[c];\n        if (!h) continue;\n        g && N.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst);\n        N.setDepthTest(h.depthTest);\n        N.setDepthWrite(h.depthWrite);\n        E(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits);\n      }\n      N.setMaterialFaces(h);\n      k instanceof THREE.BufferGeometry ? N.renderBufferDirect(d, e, f, h, k, i) : N.renderBuffer(d, e, f, h, k, i);\n    }\n  }\n  function p(a, b, c, d, e, f, g) {\n    for (var h, j, i = 0, k = a.length; i < k; i++) if (h = a[i], j = h.object, j.visible) {\n      if (g) h = g;else {\n        h = h[b];\n        if (!h) continue;\n        f && N.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst);\n        N.setDepthTest(h.depthTest);\n        N.setDepthWrite(h.depthWrite);\n        E(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits);\n      }\n      N.renderImmediateObject(c, d, e, h, j);\n    }\n  }\n  function q(a, b, c) {\n    a.push({\n      buffer: b,\n      object: c,\n      opaque: null,\n      transparent: null\n    });\n  }\n  function y(a) {\n    for (var b in a.attributes) if (a.attributes[b].needsUpdate) return !0;\n    return !1;\n  }\n  function v(a) {\n    for (var b in a.attributes) a.attributes[b].needsUpdate = !1;\n  }\n  function z(a, b) {\n    for (var c = a.length - 1; 0 <= c; c--) a[c].object === b && a.splice(c, 1);\n  }\n  function t(a, b) {\n    for (var c = a.length - 1; 0 <= c; c--) a[c] === b && a.splice(c, 1);\n  }\n  function A(a, b, c, d, e) {\n    Y = 0;\n    d.needsUpdate && (d.program && Pc(d), N.initMaterial(d, b, c, e), d.needsUpdate = !1);\n    d.morphTargets && !e.__webglMorphTargetInfluences && (e.__webglMorphTargetInfluences = new Float32Array(N.maxMorphTargets));\n    var f = !1,\n      g = d.program,\n      h = g.uniforms,\n      i = d.uniforms;\n    g !== mb && (j.useProgram(g), mb = g, f = !0);\n    d.id !== ta && (ta = d.id, f = !0);\n    if (f || a !== aa) j.uniformMatrix4fv(h.projectionMatrix, !1, a.projectionMatrix.elements), a !== aa && (aa = a);\n    if (d.skinning) if (tc && e.useVertexTexture) {\n      if (null !== h.boneTexture) {\n        var k = I();\n        j.uniform1i(h.boneTexture, k);\n        N.setTexture(e.boneTexture, k);\n      }\n    } else null !== h.boneGlobalMatrices && j.uniformMatrix4fv(h.boneGlobalMatrices, !1, e.boneMatrices);\n    if (f) {\n      c && d.fog && (i.fogColor.value = c.color, c instanceof THREE.Fog ? (i.fogNear.value = c.near, i.fogFar.value = c.far) : c instanceof THREE.FogExp2 && (i.fogDensity.value = c.density));\n      if (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d.lights) {\n        if (bb) {\n          for (var n, l = k = 0, m = 0, p, q, s, r = xb, t = r.directional.colors, v = r.directional.positions, y = r.point.colors, z = r.point.positions, B = r.point.distances, C = r.spot.colors, A = r.spot.positions, F = r.spot.distances, E = r.spot.directions, J = r.spot.anglesCos, K = r.spot.exponents, H = r.hemi.skyColors, M = r.hemi.groundColors, P = r.hemi.positions, X = 0, da = 0, ka = 0, fa = 0, ca = 0, pa = 0, Ma = 0, ha = 0, O = n = 0, c = s = O = 0, f = b.length; c < f; c++) n = b[c], n.onlyShadow || (p = n.color, q = n.intensity, s = n.distance, n instanceof THREE.AmbientLight ? n.visible && (N.gammaInput ? (k += p.r * p.r, l += p.g * p.g, m += p.b * p.b) : (k += p.r, l += p.g, m += p.b)) : n instanceof THREE.DirectionalLight ? (ca += 1, n.visible && (La.getPositionFromMatrix(n.matrixWorld), Qa.getPositionFromMatrix(n.target.matrixWorld), La.sub(Qa), La.normalize(), 0 === La.x && 0 === La.y && 0 === La.z || (n = 3 * X, v[n] = La.x, v[n + 1] = La.y, v[n + 2] = La.z, N.gammaInput ? x(t, n, p, q * q) : G(t, n, p, q), X += 1))) : n instanceof THREE.PointLight ? (pa += 1, n.visible && (O = 3 * da, N.gammaInput ? x(y, O, p, q * q) : G(y, O, p, q), Qa.getPositionFromMatrix(n.matrixWorld), z[O] = Qa.x, z[O + 1] = Qa.y, z[O + 2] = Qa.z, B[da] = s, da += 1)) : n instanceof THREE.SpotLight ? (Ma += 1, n.visible && (O = 3 * ka, N.gammaInput ? x(C, O, p, q * q) : G(C, O, p, q), Qa.getPositionFromMatrix(n.matrixWorld), A[O] = Qa.x, A[O + 1] = Qa.y, A[O + 2] = Qa.z, F[ka] = s, La.copy(Qa), Qa.getPositionFromMatrix(n.target.matrixWorld), La.sub(Qa), La.normalize(), E[O] = La.x, E[O + 1] = La.y, E[O + 2] = La.z, J[ka] = Math.cos(n.angle), K[ka] = n.exponent, ka += 1)) : n instanceof THREE.HemisphereLight && (ha += 1, n.visible && (La.getPositionFromMatrix(n.matrixWorld), La.normalize(), 0 === La.x && 0 === La.y && 0 === La.z || (s = 3 * fa, P[s] = La.x, P[s + 1] = La.y, P[s + 2] = La.z, p = n.color, n = n.groundColor, N.gammaInput ? (q *= q, x(H, s, p, q), x(M, s, n, q)) : (G(H, s, p, q), G(M, s, n, q)), fa += 1))));\n          c = 3 * X;\n          for (f = Math.max(t.length, 3 * ca); c < f; c++) t[c] = 0;\n          c = 3 * da;\n          for (f = Math.max(y.length, 3 * pa); c < f; c++) y[c] = 0;\n          c = 3 * ka;\n          for (f = Math.max(C.length, 3 * Ma); c < f; c++) C[c] = 0;\n          c = 3 * fa;\n          for (f = Math.max(H.length, 3 * ha); c < f; c++) H[c] = 0;\n          c = 3 * fa;\n          for (f = Math.max(M.length, 3 * ha); c < f; c++) M[c] = 0;\n          r.directional.length = X;\n          r.point.length = da;\n          r.spot.length = ka;\n          r.hemi.length = fa;\n          r.ambient[0] = k;\n          r.ambient[1] = l;\n          r.ambient[2] = m;\n          bb = !1;\n        }\n        c = xb;\n        i.ambientLightColor.value = c.ambient;\n        i.directionalLightColor.value = c.directional.colors;\n        i.directionalLightDirection.value = c.directional.positions;\n        i.pointLightColor.value = c.point.colors;\n        i.pointLightPosition.value = c.point.positions;\n        i.pointLightDistance.value = c.point.distances;\n        i.spotLightColor.value = c.spot.colors;\n        i.spotLightPosition.value = c.spot.positions;\n        i.spotLightDistance.value = c.spot.distances;\n        i.spotLightDirection.value = c.spot.directions;\n        i.spotLightAngleCos.value = c.spot.anglesCos;\n        i.spotLightExponent.value = c.spot.exponents;\n        i.hemisphereLightSkyColor.value = c.hemi.skyColors;\n        i.hemisphereLightGroundColor.value = c.hemi.groundColors;\n        i.hemisphereLightDirection.value = c.hemi.positions;\n      }\n      if (d instanceof THREE.MeshBasicMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshPhongMaterial) {\n        i.opacity.value = d.opacity;\n        N.gammaInput ? i.diffuse.value.copyGammaToLinear(d.color) : i.diffuse.value = d.color;\n        i.map.value = d.map;\n        i.lightMap.value = d.lightMap;\n        i.specularMap.value = d.specularMap;\n        d.bumpMap && (i.bumpMap.value = d.bumpMap, i.bumpScale.value = d.bumpScale);\n        d.normalMap && (i.normalMap.value = d.normalMap, i.normalScale.value.copy(d.normalScale));\n        var Z;\n        d.map ? Z = d.map : d.specularMap ? Z = d.specularMap : d.normalMap ? Z = d.normalMap : d.bumpMap && (Z = d.bumpMap);\n        void 0 !== Z && (c = Z.offset, Z = Z.repeat, i.offsetRepeat.value.set(c.x, c.y, Z.x, Z.y));\n        i.envMap.value = d.envMap;\n        i.flipEnvMap.value = d.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;\n        i.reflectivity.value = d.reflectivity;\n        i.refractionRatio.value = d.refractionRatio;\n        i.combine.value = d.combine;\n        i.useRefract.value = d.envMap && d.envMap.mapping instanceof THREE.CubeRefractionMapping;\n      }\n      d instanceof THREE.LineBasicMaterial ? (i.diffuse.value = d.color, i.opacity.value = d.opacity) : d instanceof THREE.LineDashedMaterial ? (i.diffuse.value = d.color, i.opacity.value = d.opacity, i.dashSize.value = d.dashSize, i.totalSize.value = d.dashSize + d.gapSize, i.scale.value = d.scale) : d instanceof THREE.ParticleBasicMaterial ? (i.psColor.value = d.color, i.opacity.value = d.opacity, i.size.value = d.size, i.scale.value = U.height / 2, i.map.value = d.map) : d instanceof THREE.MeshPhongMaterial ? (i.shininess.value = d.shininess, N.gammaInput ? (i.ambient.value.copyGammaToLinear(d.ambient), i.emissive.value.copyGammaToLinear(d.emissive), i.specular.value.copyGammaToLinear(d.specular)) : (i.ambient.value = d.ambient, i.emissive.value = d.emissive, i.specular.value = d.specular), d.wrapAround && i.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshLambertMaterial ? (N.gammaInput ? (i.ambient.value.copyGammaToLinear(d.ambient), i.emissive.value.copyGammaToLinear(d.emissive)) : (i.ambient.value = d.ambient, i.emissive.value = d.emissive), d.wrapAround && i.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshDepthMaterial ? (i.mNear.value = a.near, i.mFar.value = a.far, i.opacity.value = d.opacity) : d instanceof THREE.MeshNormalMaterial && (i.opacity.value = d.opacity);\n      if (e.receiveShadow && !d._shadowPass && i.shadowMatrix) {\n        c = Z = 0;\n        for (f = b.length; c < f; c++) if (k = b[c], k.castShadow && (k instanceof THREE.SpotLight || k instanceof THREE.DirectionalLight && !k.shadowCascade)) i.shadowMap.value[Z] = k.shadowMap, i.shadowMapSize.value[Z] = k.shadowMapSize, i.shadowMatrix.value[Z] = k.shadowMatrix, i.shadowDarkness.value[Z] = k.shadowDarkness, i.shadowBias.value[Z] = k.shadowBias, Z++;\n      }\n      b = d.uniformsList;\n      i = 0;\n      for (Z = b.length; i < Z; i++) if (f = g.uniforms[b[i][1]]) if (c = b[i][0], l = c.type, k = c.value, \"i\" === l) j.uniform1i(f, k);else if (\"f\" === l) j.uniform1f(f, k);else if (\"v2\" === l) j.uniform2f(f, k.x, k.y);else if (\"v3\" === l) j.uniform3f(f, k.x, k.y, k.z);else if (\"v4\" === l) j.uniform4f(f, k.x, k.y, k.z, k.w);else if (\"c\" === l) j.uniform3f(f, k.r, k.g, k.b);else if (\"iv1\" === l) j.uniform1iv(f, k);else if (\"iv\" === l) j.uniform3iv(f, k);else if (\"fv1\" === l) j.uniform1fv(f, k);else if (\"fv\" === l) j.uniform3fv(f, k);else if (\"v2v\" === l) {\n        void 0 === c._array && (c._array = new Float32Array(2 * k.length));\n        l = 0;\n        for (m = k.length; l < m; l++) r = 2 * l, c._array[r] = k[l].x, c._array[r + 1] = k[l].y;\n        j.uniform2fv(f, c._array);\n      } else if (\"v3v\" === l) {\n        void 0 === c._array && (c._array = new Float32Array(3 * k.length));\n        l = 0;\n        for (m = k.length; l < m; l++) r = 3 * l, c._array[r] = k[l].x, c._array[r + 1] = k[l].y, c._array[r + 2] = k[l].z;\n        j.uniform3fv(f, c._array);\n      } else if (\"v4v\" === l) {\n        void 0 === c._array && (c._array = new Float32Array(4 * k.length));\n        l = 0;\n        for (m = k.length; l < m; l++) r = 4 * l, c._array[r] = k[l].x, c._array[r + 1] = k[l].y, c._array[r + 2] = k[l].z, c._array[r + 3] = k[l].w;\n        j.uniform4fv(f, c._array);\n      } else if (\"m4\" === l) void 0 === c._array && (c._array = new Float32Array(16)), k.flattenToArray(c._array), j.uniformMatrix4fv(f, !1, c._array);else if (\"m4v\" === l) {\n        void 0 === c._array && (c._array = new Float32Array(16 * k.length));\n        l = 0;\n        for (m = k.length; l < m; l++) k[l].flattenToArrayOffset(c._array, 16 * l);\n        j.uniformMatrix4fv(f, !1, c._array);\n      } else if (\"t\" === l) {\n        if (r = k, k = I(), j.uniform1i(f, k), r) if (r.image instanceof Array && 6 === r.image.length) {\n          if (c = r, f = k, 6 === c.image.length) if (c.needsUpdate) {\n            c.image.__webglTextureCube || (c.image.__webglTextureCube = j.createTexture(), N.info.memory.textures++);\n            j.activeTexture(j.TEXTURE0 + f);\n            j.bindTexture(j.TEXTURE_CUBE_MAP, c.image.__webglTextureCube);\n            j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL, c.flipY);\n            f = c instanceof THREE.CompressedTexture;\n            k = [];\n            for (l = 0; 6 > l; l++) N.autoScaleCubemaps && !f ? (m = k, r = l, t = c.image[l], y = gd, t.width <= y && t.height <= y || (z = Math.max(t.width, t.height), v = Math.floor(t.width * y / z), y = Math.floor(t.height * y / z), z = document.createElement(\"canvas\"), z.width = v, z.height = y, z.getContext(\"2d\").drawImage(t, 0, 0, t.width, t.height, 0, 0, v, y), t = z), m[r] = t) : k[l] = c.image[l];\n            l = k[0];\n            m = 0 === (l.width & l.width - 1) && 0 === (l.height & l.height - 1);\n            r = L(c.format);\n            t = L(c.type);\n            W(j.TEXTURE_CUBE_MAP, c, m);\n            for (l = 0; 6 > l; l++) if (f) {\n              y = k[l].mipmaps;\n              z = 0;\n              for (B = y.length; z < B; z++) v = y[z], j.compressedTexImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X + l, z, r, v.width, v.height, 0, v.data);\n            } else j.texImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X + l, 0, r, r, t, k[l]);\n            c.generateMipmaps && m && j.generateMipmap(j.TEXTURE_CUBE_MAP);\n            c.needsUpdate = !1;\n            if (c.onUpdate) c.onUpdate();\n          } else j.activeTexture(j.TEXTURE0 + f), j.bindTexture(j.TEXTURE_CUBE_MAP, c.image.__webglTextureCube);\n        } else r instanceof THREE.WebGLRenderTargetCube ? (c = r, j.activeTexture(j.TEXTURE0 + k), j.bindTexture(j.TEXTURE_CUBE_MAP, c.__webglTexture)) : N.setTexture(r, k);\n      } else if (\"tv\" === l) {\n        void 0 === c._array && (c._array = []);\n        l = 0;\n        for (m = c.value.length; l < m; l++) c._array[l] = I();\n        j.uniform1iv(f, c._array);\n        l = 0;\n        for (m = c.value.length; l < m; l++) r = c.value[l], k = c._array[l], r && N.setTexture(r, k);\n      }\n      if ((d instanceof THREE.ShaderMaterial || d instanceof THREE.MeshPhongMaterial || d.envMap) && null !== h.cameraPosition) Qa.getPositionFromMatrix(a.matrixWorld), j.uniform3f(h.cameraPosition, Qa.x, Qa.y, Qa.z);\n      (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.ShaderMaterial || d.skinning) && null !== h.viewMatrix && j.uniformMatrix4fv(h.viewMatrix, !1, a.matrixWorldInverse.elements);\n    }\n    j.uniformMatrix4fv(h.modelViewMatrix, !1, e._modelViewMatrix.elements);\n    h.normalMatrix && j.uniformMatrix3fv(h.normalMatrix, !1, e._normalMatrix.elements);\n    null !== h.modelMatrix && j.uniformMatrix4fv(h.modelMatrix, !1, e.matrixWorld.elements);\n    return g;\n  }\n  function I() {\n    var a = Y;\n    a >= Mc && console.warn(\"WebGLRenderer: trying to use \" + a + \" texture units while this GPU supports only \" + Mc);\n    Y += 1;\n    return a;\n  }\n  function C(a, b) {\n    a._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, a.matrixWorld);\n    a._normalMatrix.getInverse(a._modelViewMatrix);\n    a._normalMatrix.transpose();\n  }\n  function x(a, b, c, d) {\n    a[b] = c.r * c.r * d;\n    a[b + 1] = c.g * c.g * d;\n    a[b + 2] = c.b * c.b * d;\n  }\n  function G(a, b, c, d) {\n    a[b] = c.r * d;\n    a[b + 1] = c.g * d;\n    a[b + 2] = c.b * d;\n  }\n  function J(a) {\n    a !== ub && (j.lineWidth(a), ub = a);\n  }\n  function E(a, b, c) {\n    ab !== a && (a ? j.enable(j.POLYGON_OFFSET_FILL) : j.disable(j.POLYGON_OFFSET_FILL), ab = a);\n    if (a && (Fa !== b || Xa !== c)) j.polygonOffset(b, c), Fa = b, Xa = c;\n  }\n  function H(a) {\n    for (var a = a.split(\"\\n\"), b = 0, c = a.length; b < c; b++) a[b] = b + 1 + \": \" + a[b];\n    return a.join(\"\\n\");\n  }\n  function B(a, b) {\n    var c;\n    \"fragment\" === a ? c = j.createShader(j.FRAGMENT_SHADER) : \"vertex\" === a && (c = j.createShader(j.VERTEX_SHADER));\n    j.shaderSource(c, b);\n    j.compileShader(c);\n    return !j.getShaderParameter(c, j.COMPILE_STATUS) ? (console.error(j.getShaderInfoLog(c)), console.error(H(b)), null) : c;\n  }\n  function W(a, b, c) {\n    c ? (j.texParameteri(a, j.TEXTURE_WRAP_S, L(b.wrapS)), j.texParameteri(a, j.TEXTURE_WRAP_T, L(b.wrapT)), j.texParameteri(a, j.TEXTURE_MAG_FILTER, L(b.magFilter)), j.texParameteri(a, j.TEXTURE_MIN_FILTER, L(b.minFilter))) : (j.texParameteri(a, j.TEXTURE_WRAP_S, j.CLAMP_TO_EDGE), j.texParameteri(a, j.TEXTURE_WRAP_T, j.CLAMP_TO_EDGE), j.texParameteri(a, j.TEXTURE_MAG_FILTER, K(b.magFilter)), j.texParameteri(a, j.TEXTURE_MIN_FILTER, K(b.minFilter)));\n    if (cb && b.type !== THREE.FloatType && (1 < b.anisotropy || b.__oldAnisotropy)) j.texParameterf(a, cb.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, Cc)), b.__oldAnisotropy = b.anisotropy;\n  }\n  function F(a, b) {\n    j.bindRenderbuffer(j.RENDERBUFFER, a);\n    b.depthBuffer && !b.stencilBuffer ? (j.renderbufferStorage(j.RENDERBUFFER, j.DEPTH_COMPONENT16, b.width, b.height), j.framebufferRenderbuffer(j.FRAMEBUFFER, j.DEPTH_ATTACHMENT, j.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (j.renderbufferStorage(j.RENDERBUFFER, j.DEPTH_STENCIL, b.width, b.height), j.framebufferRenderbuffer(j.FRAMEBUFFER, j.DEPTH_STENCIL_ATTACHMENT, j.RENDERBUFFER, a)) : j.renderbufferStorage(j.RENDERBUFFER, j.RGBA4, b.width, b.height);\n  }\n  function K(a) {\n    return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? j.NEAREST : j.LINEAR;\n  }\n  function L(a) {\n    if (a === THREE.RepeatWrapping) return j.REPEAT;\n    if (a === THREE.ClampToEdgeWrapping) return j.CLAMP_TO_EDGE;\n    if (a === THREE.MirroredRepeatWrapping) return j.MIRRORED_REPEAT;\n    if (a === THREE.NearestFilter) return j.NEAREST;\n    if (a === THREE.NearestMipMapNearestFilter) return j.NEAREST_MIPMAP_NEAREST;\n    if (a === THREE.NearestMipMapLinearFilter) return j.NEAREST_MIPMAP_LINEAR;\n    if (a === THREE.LinearFilter) return j.LINEAR;\n    if (a === THREE.LinearMipMapNearestFilter) return j.LINEAR_MIPMAP_NEAREST;\n    if (a === THREE.LinearMipMapLinearFilter) return j.LINEAR_MIPMAP_LINEAR;\n    if (a === THREE.UnsignedByteType) return j.UNSIGNED_BYTE;\n    if (a === THREE.UnsignedShort4444Type) return j.UNSIGNED_SHORT_4_4_4_4;\n    if (a === THREE.UnsignedShort5551Type) return j.UNSIGNED_SHORT_5_5_5_1;\n    if (a === THREE.UnsignedShort565Type) return j.UNSIGNED_SHORT_5_6_5;\n    if (a === THREE.ByteType) return j.BYTE;\n    if (a === THREE.ShortType) return j.SHORT;\n    if (a === THREE.UnsignedShortType) return j.UNSIGNED_SHORT;\n    if (a === THREE.IntType) return j.INT;\n    if (a === THREE.UnsignedIntType) return j.UNSIGNED_INT;\n    if (a === THREE.FloatType) return j.FLOAT;\n    if (a === THREE.AlphaFormat) return j.ALPHA;\n    if (a === THREE.RGBFormat) return j.RGB;\n    if (a === THREE.RGBAFormat) return j.RGBA;\n    if (a === THREE.LuminanceFormat) return j.LUMINANCE;\n    if (a === THREE.LuminanceAlphaFormat) return j.LUMINANCE_ALPHA;\n    if (a === THREE.AddEquation) return j.FUNC_ADD;\n    if (a === THREE.SubtractEquation) return j.FUNC_SUBTRACT;\n    if (a === THREE.ReverseSubtractEquation) return j.FUNC_REVERSE_SUBTRACT;\n    if (a === THREE.ZeroFactor) return j.ZERO;\n    if (a === THREE.OneFactor) return j.ONE;\n    if (a === THREE.SrcColorFactor) return j.SRC_COLOR;\n    if (a === THREE.OneMinusSrcColorFactor) return j.ONE_MINUS_SRC_COLOR;\n    if (a === THREE.SrcAlphaFactor) return j.SRC_ALPHA;\n    if (a === THREE.OneMinusSrcAlphaFactor) return j.ONE_MINUS_SRC_ALPHA;\n    if (a === THREE.DstAlphaFactor) return j.DST_ALPHA;\n    if (a === THREE.OneMinusDstAlphaFactor) return j.ONE_MINUS_DST_ALPHA;\n    if (a === THREE.DstColorFactor) return j.DST_COLOR;\n    if (a === THREE.OneMinusDstColorFactor) return j.ONE_MINUS_DST_COLOR;\n    if (a === THREE.SrcAlphaSaturateFactor) return j.SRC_ALPHA_SATURATE;\n    if (void 0 !== Sa) {\n      if (a === THREE.RGB_S3TC_DXT1_Format) return Sa.COMPRESSED_RGB_S3TC_DXT1_EXT;\n      if (a === THREE.RGBA_S3TC_DXT1_Format) return Sa.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n      if (a === THREE.RGBA_S3TC_DXT3_Format) return Sa.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n      if (a === THREE.RGBA_S3TC_DXT5_Format) return Sa.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n    }\n    return 0;\n  }\n  console.log(\"THREE.WebGLRenderer\", THREE.REVISION);\n  var a = a || {},\n    U = void 0 !== a.canvas ? a.canvas : document.createElement(\"canvas\"),\n    fa = void 0 !== a.precision ? a.precision : \"highp\",\n    Ca = void 0 !== a.alpha ? a.alpha : !0,\n    $a = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0,\n    M = void 0 !== a.antialias ? a.antialias : !1,\n    ca = void 0 !== a.stencil ? a.stencil : !0,\n    qa = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1,\n    ha = void 0 !== a.clearColor ? new THREE.Color(a.clearColor) : new THREE.Color(0),\n    ra = void 0 !== a.clearAlpha ? a.clearAlpha : 0;\n  this.domElement = U;\n  this.context = null;\n  this.devicePixelRatio = void 0 !== a.devicePixelRatio ? a.devicePixelRatio : void 0 !== window.devicePixelRatio ? window.devicePixelRatio : 1;\n  this.autoUpdateScene = this.autoUpdateObjects = this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;\n  this.shadowMapEnabled = this.physicallyBasedShading = this.gammaOutput = this.gammaInput = !1;\n  this.shadowMapAutoUpdate = !0;\n  this.shadowMapType = THREE.PCFShadowMap;\n  this.shadowMapCullFace = THREE.CullFaceFront;\n  this.shadowMapCascade = this.shadowMapDebug = !1;\n  this.maxMorphTargets = 8;\n  this.maxMorphNormals = 4;\n  this.autoScaleCubemaps = !0;\n  this.renderPluginsPre = [];\n  this.renderPluginsPost = [];\n  this.info = {\n    memory: {\n      programs: 0,\n      geometries: 0,\n      textures: 0\n    },\n    render: {\n      calls: 0,\n      vertices: 0,\n      faces: 0,\n      points: 0\n    }\n  };\n  var N = this,\n    Ma = [],\n    Na = 0,\n    mb = null,\n    Pa = null,\n    ta = -1,\n    ka = null,\n    aa = null,\n    pa = 0,\n    Y = 0,\n    da = -1,\n    la = -1,\n    Z = -1,\n    oa = -1,\n    gb = -1,\n    nb = -1,\n    ia = -1,\n    Wa = -1,\n    ab = null,\n    Fa = null,\n    Xa = null,\n    ub = null,\n    Ib = 0,\n    Jb = 0,\n    fc = 0,\n    Ab = 0,\n    mc = 0,\n    pb = 0,\n    Ka = {},\n    Va = new THREE.Frustum(),\n    gc = new THREE.Matrix4(),\n    vb = new THREE.Matrix4(),\n    Qa = new THREE.Vector3(),\n    La = new THREE.Vector3(),\n    bb = !0,\n    xb = {\n      ambient: [0, 0, 0],\n      directional: {\n        length: 0,\n        colors: [],\n        positions: []\n      },\n      point: {\n        length: 0,\n        colors: [],\n        positions: [],\n        distances: []\n      },\n      spot: {\n        length: 0,\n        colors: [],\n        positions: [],\n        distances: [],\n        directions: [],\n        anglesCos: [],\n        exponents: []\n      },\n      hemi: {\n        length: 0,\n        skyColors: [],\n        groundColors: [],\n        positions: []\n      }\n    },\n    j,\n    yb,\n    Ra,\n    cb,\n    Sa;\n  try {\n    if (!(j = U.getContext(\"experimental-webgl\", {\n      alpha: Ca,\n      premultipliedAlpha: $a,\n      antialias: M,\n      stencil: ca,\n      preserveDrawingBuffer: qa\n    }))) throw \"Error creating WebGL context.\";\n  } catch (zb) {\n    console.error(zb);\n  }\n  yb = j.getExtension(\"OES_texture_float\");\n  Ra = j.getExtension(\"OES_standard_derivatives\");\n  cb = j.getExtension(\"EXT_texture_filter_anisotropic\") || j.getExtension(\"MOZ_EXT_texture_filter_anisotropic\") || j.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\");\n  Sa = j.getExtension(\"WEBGL_compressed_texture_s3tc\") || j.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\") || j.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\");\n  yb || console.log(\"THREE.WebGLRenderer: Float textures not supported.\");\n  Ra || console.log(\"THREE.WebGLRenderer: Standard derivatives not supported.\");\n  cb || console.log(\"THREE.WebGLRenderer: Anisotropic texture filtering not supported.\");\n  Sa || console.log(\"THREE.WebGLRenderer: S3TC compressed textures not supported.\");\n  void 0 === j.getShaderPrecisionFormat && (j.getShaderPrecisionFormat = function () {\n    return {\n      rangeMin: 1,\n      rangeMax: 1,\n      precision: 1\n    };\n  });\n  j.clearColor(0, 0, 0, 1);\n  j.clearDepth(1);\n  j.clearStencil(0);\n  j.enable(j.DEPTH_TEST);\n  j.depthFunc(j.LEQUAL);\n  j.frontFace(j.CCW);\n  j.cullFace(j.BACK);\n  j.enable(j.CULL_FACE);\n  j.enable(j.BLEND);\n  j.blendEquation(j.FUNC_ADD);\n  j.blendFunc(j.SRC_ALPHA, j.ONE_MINUS_SRC_ALPHA);\n  j.clearColor(ha.r, ha.g, ha.b, ra);\n  this.context = j;\n  var Mc = j.getParameter(j.MAX_TEXTURE_IMAGE_UNITS),\n    fd = j.getParameter(j.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n  j.getParameter(j.MAX_TEXTURE_SIZE);\n  var gd = j.getParameter(j.MAX_CUBE_MAP_TEXTURE_SIZE),\n    Cc = cb ? j.getParameter(cb.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,\n    sc = 0 < fd,\n    tc = sc && yb;\n  Sa && j.getParameter(j.COMPRESSED_TEXTURE_FORMATS);\n  var jd = j.getShaderPrecisionFormat(j.VERTEX_SHADER, j.HIGH_FLOAT),\n    kd = j.getShaderPrecisionFormat(j.VERTEX_SHADER, j.MEDIUM_FLOAT);\n  j.getShaderPrecisionFormat(j.VERTEX_SHADER, j.LOW_FLOAT);\n  var ld = j.getShaderPrecisionFormat(j.FRAGMENT_SHADER, j.HIGH_FLOAT),\n    id = j.getShaderPrecisionFormat(j.FRAGMENT_SHADER, j.MEDIUM_FLOAT);\n  j.getShaderPrecisionFormat(j.FRAGMENT_SHADER, j.LOW_FLOAT);\n  j.getShaderPrecisionFormat(j.VERTEX_SHADER, j.HIGH_INT);\n  j.getShaderPrecisionFormat(j.VERTEX_SHADER, j.MEDIUM_INT);\n  j.getShaderPrecisionFormat(j.VERTEX_SHADER, j.LOW_INT);\n  j.getShaderPrecisionFormat(j.FRAGMENT_SHADER, j.HIGH_INT);\n  j.getShaderPrecisionFormat(j.FRAGMENT_SHADER, j.MEDIUM_INT);\n  j.getShaderPrecisionFormat(j.FRAGMENT_SHADER, j.LOW_INT);\n  var hd = 0 < jd.precision && 0 < ld.precision,\n    Nc = 0 < kd.precision && 0 < id.precision;\n  \"highp\" === fa && !hd && (Nc ? (fa = \"mediump\", console.warn(\"WebGLRenderer: highp not supported, using mediump\")) : (fa = \"lowp\", console.warn(\"WebGLRenderer: highp and mediump not supported, using lowp\")));\n  \"mediump\" === fa && !Nc && (fa = \"lowp\", console.warn(\"WebGLRenderer: mediump not supported, using lowp\"));\n  this.getContext = function () {\n    return j;\n  };\n  this.supportsVertexTextures = function () {\n    return sc;\n  };\n  this.supportsFloatTextures = function () {\n    return yb;\n  };\n  this.supportsStandardDerivatives = function () {\n    return Ra;\n  };\n  this.supportsCompressedTextureS3TC = function () {\n    return Sa;\n  };\n  this.getMaxAnisotropy = function () {\n    return Cc;\n  };\n  this.getPrecision = function () {\n    return fa;\n  };\n  this.setSize = function (a, b) {\n    U.width = a * this.devicePixelRatio;\n    U.height = b * this.devicePixelRatio;\n    U.style.width = a + \"px\";\n    U.style.height = b + \"px\";\n    this.setViewport(0, 0, U.width, U.height);\n  };\n  this.setViewport = function (a, b, c, d) {\n    Ib = void 0 !== a ? a : 0;\n    Jb = void 0 !== b ? b : 0;\n    fc = void 0 !== c ? c : U.width;\n    Ab = void 0 !== d ? d : U.height;\n    j.viewport(Ib, Jb, fc, Ab);\n  };\n  this.setScissor = function (a, b, c, d) {\n    j.scissor(a, b, c, d);\n  };\n  this.enableScissorTest = function (a) {\n    a ? j.enable(j.SCISSOR_TEST) : j.disable(j.SCISSOR_TEST);\n  };\n  this.setClearColorHex = function (a, b) {\n    ha.setHex(a);\n    ra = b;\n    j.clearColor(ha.r, ha.g, ha.b, ra);\n  };\n  this.setClearColor = function (a, b) {\n    ha.copy(a);\n    ra = b;\n    j.clearColor(ha.r, ha.g, ha.b, ra);\n  };\n  this.getClearColor = function () {\n    return ha;\n  };\n  this.getClearAlpha = function () {\n    return ra;\n  };\n  this.clear = function (a, b, c) {\n    var d = 0;\n    if (void 0 === a || a) d |= j.COLOR_BUFFER_BIT;\n    if (void 0 === b || b) d |= j.DEPTH_BUFFER_BIT;\n    if (void 0 === c || c) d |= j.STENCIL_BUFFER_BIT;\n    j.clear(d);\n  };\n  this.clearTarget = function (a, b, c, d) {\n    this.setRenderTarget(a);\n    this.clear(b, c, d);\n  };\n  this.addPostPlugin = function (a) {\n    a.init(this);\n    this.renderPluginsPost.push(a);\n  };\n  this.addPrePlugin = function (a) {\n    a.init(this);\n    this.renderPluginsPre.push(a);\n  };\n  this.updateShadowMap = function (a, b) {\n    mb = null;\n    ta = ka = Wa = ia = Z = -1;\n    bb = !0;\n    la = da = -1;\n    this.shadowMapPlugin.update(a, b);\n  };\n  var wd = function wd(a) {\n      a = a.target;\n      a.removeEventListener(\"dispose\", wd);\n      a.__webglInit = void 0;\n      void 0 !== a.__webglVertexBuffer && j.deleteBuffer(a.__webglVertexBuffer);\n      void 0 !== a.__webglNormalBuffer && j.deleteBuffer(a.__webglNormalBuffer);\n      void 0 !== a.__webglTangentBuffer && j.deleteBuffer(a.__webglTangentBuffer);\n      void 0 !== a.__webglColorBuffer && j.deleteBuffer(a.__webglColorBuffer);\n      void 0 !== a.__webglUVBuffer && j.deleteBuffer(a.__webglUVBuffer);\n      void 0 !== a.__webglUV2Buffer && j.deleteBuffer(a.__webglUV2Buffer);\n      void 0 !== a.__webglSkinIndicesBuffer && j.deleteBuffer(a.__webglSkinIndicesBuffer);\n      void 0 !== a.__webglSkinWeightsBuffer && j.deleteBuffer(a.__webglSkinWeightsBuffer);\n      void 0 !== a.__webglFaceBuffer && j.deleteBuffer(a.__webglFaceBuffer);\n      void 0 !== a.__webglLineBuffer && j.deleteBuffer(a.__webglLineBuffer);\n      void 0 !== a.__webglLineDistanceBuffer && j.deleteBuffer(a.__webglLineDistanceBuffer);\n      if (void 0 !== a.geometryGroups) for (var c in a.geometryGroups) {\n        var d = a.geometryGroups[c];\n        if (void 0 !== d.numMorphTargets) for (var e = 0, f = d.numMorphTargets; e < f; e++) j.deleteBuffer(d.__webglMorphTargetsBuffers[e]);\n        if (void 0 !== d.numMorphNormals) {\n          e = 0;\n          for (f = d.numMorphNormals; e < f; e++) j.deleteBuffer(d.__webglMorphNormalsBuffers[e]);\n        }\n        b(d);\n      }\n      b(a);\n      N.info.memory.geometries--;\n    },\n    Oc = function Oc(a) {\n      a = a.target;\n      a.removeEventListener(\"dispose\", Oc);\n      a.image && a.image.__webglTextureCube ? j.deleteTexture(a.image.__webglTextureCube) : a.__webglInit && (a.__webglInit = !1, j.deleteTexture(a.__webglTexture));\n      N.info.memory.textures--;\n    },\n    P = function P(a) {\n      a = a.target;\n      a.removeEventListener(\"dispose\", P);\n      if (a && a.__webglTexture) if (j.deleteTexture(a.__webglTexture), a instanceof THREE.WebGLRenderTargetCube) for (var b = 0; 6 > b; b++) j.deleteFramebuffer(a.__webglFramebuffer[b]), j.deleteRenderbuffer(a.__webglRenderbuffer[b]);else j.deleteFramebuffer(a.__webglFramebuffer), j.deleteRenderbuffer(a.__webglRenderbuffer);\n      N.info.memory.textures--;\n    },\n    X = function X(a) {\n      a = a.target;\n      a.removeEventListener(\"dispose\", X);\n      Pc(a);\n    },\n    Pc = function Pc(a) {\n      var b = a.program;\n      if (void 0 !== b) {\n        a.program = void 0;\n        var c,\n          d,\n          e = !1,\n          a = 0;\n        for (c = Ma.length; a < c; a++) if (d = Ma[a], d.program === b) {\n          d.usedTimes--;\n          0 === d.usedTimes && (e = !0);\n          break;\n        }\n        if (!0 === e) {\n          e = [];\n          a = 0;\n          for (c = Ma.length; a < c; a++) d = Ma[a], d.program !== b && e.push(d);\n          Ma = e;\n          j.deleteProgram(b);\n          N.info.memory.programs--;\n        }\n      }\n    };\n  this.renderBufferImmediate = function (a, b, c) {\n    a.hasPositions && !a.__webglVertexBuffer && (a.__webglVertexBuffer = j.createBuffer());\n    a.hasNormals && !a.__webglNormalBuffer && (a.__webglNormalBuffer = j.createBuffer());\n    a.hasUvs && !a.__webglUvBuffer && (a.__webglUvBuffer = j.createBuffer());\n    a.hasColors && !a.__webglColorBuffer && (a.__webglColorBuffer = j.createBuffer());\n    a.hasPositions && (j.bindBuffer(j.ARRAY_BUFFER, a.__webglVertexBuffer), j.bufferData(j.ARRAY_BUFFER, a.positionArray, j.DYNAMIC_DRAW), j.enableVertexAttribArray(b.attributes.position), j.vertexAttribPointer(b.attributes.position, 3, j.FLOAT, !1, 0, 0));\n    if (a.hasNormals) {\n      j.bindBuffer(j.ARRAY_BUFFER, a.__webglNormalBuffer);\n      if (c.shading === THREE.FlatShading) {\n        var d,\n          e,\n          f,\n          g,\n          i,\n          h,\n          k,\n          l,\n          n,\n          m,\n          p,\n          q = 3 * a.count;\n        for (p = 0; p < q; p += 9) m = a.normalArray, d = m[p], e = m[p + 1], f = m[p + 2], g = m[p + 3], h = m[p + 4], l = m[p + 5], i = m[p + 6], k = m[p + 7], n = m[p + 8], d = (d + g + i) / 3, e = (e + h + k) / 3, f = (f + l + n) / 3, m[p] = d, m[p + 1] = e, m[p + 2] = f, m[p + 3] = d, m[p + 4] = e, m[p + 5] = f, m[p + 6] = d, m[p + 7] = e, m[p + 8] = f;\n      }\n      j.bufferData(j.ARRAY_BUFFER, a.normalArray, j.DYNAMIC_DRAW);\n      j.enableVertexAttribArray(b.attributes.normal);\n      j.vertexAttribPointer(b.attributes.normal, 3, j.FLOAT, !1, 0, 0);\n    }\n    a.hasUvs && c.map && (j.bindBuffer(j.ARRAY_BUFFER, a.__webglUvBuffer), j.bufferData(j.ARRAY_BUFFER, a.uvArray, j.DYNAMIC_DRAW), j.enableVertexAttribArray(b.attributes.uv), j.vertexAttribPointer(b.attributes.uv, 2, j.FLOAT, !1, 0, 0));\n    a.hasColors && c.vertexColors !== THREE.NoColors && (j.bindBuffer(j.ARRAY_BUFFER, a.__webglColorBuffer), j.bufferData(j.ARRAY_BUFFER, a.colorArray, j.DYNAMIC_DRAW), j.enableVertexAttribArray(b.attributes.color), j.vertexAttribPointer(b.attributes.color, 3, j.FLOAT, !1, 0, 0));\n    j.drawArrays(j.TRIANGLES, 0, a.count);\n    a.count = 0;\n  };\n  this.renderBufferDirect = function (a, b, c, d, e, f) {\n    if (!1 !== d.visible) if (c = A(a, b, c, d, f), a = c.attributes, b = !1, c = 16777215 * e.id + 2 * c.id + (d.wireframe ? 1 : 0), c !== ka && (ka = c, b = !0), b && l(), f instanceof THREE.Mesh) {\n      if (d = e.attributes.index) {\n        f = e.offsets;\n        1 < f.length && (b = !0);\n        for (var c = 0, g = f.length; c < g; c++) {\n          var i = f[c].index;\n          if (b) {\n            var h = e.attributes.position,\n              n = h.itemSize;\n            j.bindBuffer(j.ARRAY_BUFFER, h.buffer);\n            k(a.position);\n            j.vertexAttribPointer(a.position, n, j.FLOAT, !1, 0, 4 * i * n);\n            n = e.attributes.normal;\n            if (0 <= a.normal && n) {\n              var m = n.itemSize;\n              j.bindBuffer(j.ARRAY_BUFFER, n.buffer);\n              k(a.normal);\n              j.vertexAttribPointer(a.normal, m, j.FLOAT, !1, 0, 4 * i * m);\n            }\n            n = e.attributes.uv;\n            0 <= a.uv && n && (m = n.itemSize, j.bindBuffer(j.ARRAY_BUFFER, n.buffer), k(a.uv), j.vertexAttribPointer(a.uv, m, j.FLOAT, !1, 0, 4 * i * m));\n            n = e.attributes.color;\n            0 <= a.color && n && (m = n.itemSize, j.bindBuffer(j.ARRAY_BUFFER, n.buffer), k(a.color), j.vertexAttribPointer(a.color, m, j.FLOAT, !1, 0, 4 * i * m));\n            n = e.attributes.tangent;\n            0 <= a.tangent && n && (m = n.itemSize, j.bindBuffer(j.ARRAY_BUFFER, n.buffer), k(a.tangent), j.vertexAttribPointer(a.tangent, m, j.FLOAT, !1, 0, 4 * i * m));\n            j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, d.buffer);\n          }\n          j.drawElements(j.TRIANGLES, f[c].count, j.UNSIGNED_SHORT, 2 * f[c].start);\n          N.info.render.calls++;\n          N.info.render.vertices += f[c].count;\n          N.info.render.faces += f[c].count / 3;\n        }\n      } else b && (h = e.attributes.position, n = h.itemSize, j.bindBuffer(j.ARRAY_BUFFER, h.buffer), k(a.position), j.vertexAttribPointer(a.position, n, j.FLOAT, !1, 0, 0), n = e.attributes.normal, 0 <= a.normal && n && (m = n.itemSize, j.bindBuffer(j.ARRAY_BUFFER, n.buffer), k(a.normal), j.vertexAttribPointer(a.normal, m, j.FLOAT, !1, 0, 0)), n = e.attributes.uv, 0 <= a.uv && n && (m = n.itemSize, j.bindBuffer(j.ARRAY_BUFFER, n.buffer), k(a.uv), j.vertexAttribPointer(a.uv, m, j.FLOAT, !1, 0, 0)), n = e.attributes.color, 0 <= a.color && n && (m = n.itemSize, j.bindBuffer(j.ARRAY_BUFFER, n.buffer), k(a.color), j.vertexAttribPointer(a.color, m, j.FLOAT, !1, 0, 0)), n = e.attributes.tangent, 0 <= a.tangent && n && (m = n.itemSize, j.bindBuffer(j.ARRAY_BUFFER, n.buffer), k(a.tangent), j.vertexAttribPointer(a.tangent, m, j.FLOAT, !1, 0, 0))), j.drawArrays(j.TRIANGLES, 0, h.numItems / 3), N.info.render.calls++, N.info.render.vertices += h.numItems / 3, N.info.render.faces += h.numItems / 3 / 3;\n    } else f instanceof THREE.ParticleSystem ? b && (h = e.attributes.position, n = h.itemSize, j.bindBuffer(j.ARRAY_BUFFER, h.buffer), k(a.position), j.vertexAttribPointer(a.position, n, j.FLOAT, !1, 0, 0), n = e.attributes.color, 0 <= a.color && n && (m = n.itemSize, j.bindBuffer(j.ARRAY_BUFFER, n.buffer), k(a.color), j.vertexAttribPointer(a.color, m, j.FLOAT, !1, 0, 0)), j.drawArrays(j.POINTS, 0, h.numItems / 3), N.info.render.calls++, N.info.render.points += h.numItems / 3) : f instanceof THREE.Line && b && (h = e.attributes.position, n = h.itemSize, j.bindBuffer(j.ARRAY_BUFFER, h.buffer), k(a.position), j.vertexAttribPointer(a.position, n, j.FLOAT, !1, 0, 0), n = e.attributes.color, 0 <= a.color && n && (m = n.itemSize, j.bindBuffer(j.ARRAY_BUFFER, n.buffer), k(a.color), j.vertexAttribPointer(a.color, m, j.FLOAT, !1, 0, 0)), J(d.linewidth), j.drawArrays(j.LINE_STRIP, 0, h.numItems / 3), N.info.render.calls++, N.info.render.points += h.numItems);\n  };\n  this.renderBuffer = function (a, b, c, d, e, f) {\n    if (!1 !== d.visible) {\n      var g,\n        i,\n        c = A(a, b, c, d, f),\n        a = c.attributes,\n        b = !1,\n        c = 16777215 * e.id + 2 * c.id + (d.wireframe ? 1 : 0);\n      c !== ka && (ka = c, b = !0);\n      b && l();\n      if (!d.morphTargets && 0 <= a.position) b && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglVertexBuffer), k(a.position), j.vertexAttribPointer(a.position, 3, j.FLOAT, !1, 0, 0));else if (f.morphTargetBase) {\n        c = d.program.attributes;\n        -1 !== f.morphTargetBase && 0 <= c.position ? (j.bindBuffer(j.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[f.morphTargetBase]), k(c.position), j.vertexAttribPointer(c.position, 3, j.FLOAT, !1, 0, 0)) : 0 <= c.position && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglVertexBuffer), k(c.position), j.vertexAttribPointer(c.position, 3, j.FLOAT, !1, 0, 0));\n        if (f.morphTargetForcedOrder.length) {\n          var h = 0;\n          i = f.morphTargetForcedOrder;\n          for (g = f.morphTargetInfluences; h < d.numSupportedMorphTargets && h < i.length;) 0 <= c[\"morphTarget\" + h] && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[i[h]]), k(c[\"morphTarget\" + h]), j.vertexAttribPointer(c[\"morphTarget\" + h], 3, j.FLOAT, !1, 0, 0)), 0 <= c[\"morphNormal\" + h] && d.morphNormals && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[i[h]]), k(c[\"morphNormal\" + h]), j.vertexAttribPointer(c[\"morphNormal\" + h], 3, j.FLOAT, !1, 0, 0)), f.__webglMorphTargetInfluences[h] = g[i[h]], h++;\n        } else {\n          i = [];\n          g = f.morphTargetInfluences;\n          var m,\n            p = g.length;\n          for (m = 0; m < p; m++) h = g[m], 0 < h && i.push([h, m]);\n          i.length > d.numSupportedMorphTargets ? (i.sort(n), i.length = d.numSupportedMorphTargets) : i.length > d.numSupportedMorphNormals ? i.sort(n) : 0 === i.length && i.push([0, 0]);\n          for (h = 0; h < d.numSupportedMorphTargets;) i[h] ? (m = i[h][1], 0 <= c[\"morphTarget\" + h] && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[m]), k(c[\"morphTarget\" + h]), j.vertexAttribPointer(c[\"morphTarget\" + h], 3, j.FLOAT, !1, 0, 0)), 0 <= c[\"morphNormal\" + h] && d.morphNormals && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[m]), k(c[\"morphNormal\" + h]), j.vertexAttribPointer(c[\"morphNormal\" + h], 3, j.FLOAT, !1, 0, 0)), f.__webglMorphTargetInfluences[h] = g[m]) : f.__webglMorphTargetInfluences[h] = 0, h++;\n        }\n        null !== d.program.uniforms.morphTargetInfluences && j.uniform1fv(d.program.uniforms.morphTargetInfluences, f.__webglMorphTargetInfluences);\n      }\n      if (b) {\n        if (e.__webglCustomAttributesList) {\n          g = 0;\n          for (i = e.__webglCustomAttributesList.length; g < i; g++) c = e.__webglCustomAttributesList[g], 0 <= a[c.buffer.belongsToAttribute] && (j.bindBuffer(j.ARRAY_BUFFER, c.buffer), k(a[c.buffer.belongsToAttribute]), j.vertexAttribPointer(a[c.buffer.belongsToAttribute], c.size, j.FLOAT, !1, 0, 0));\n        }\n        0 <= a.color && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglColorBuffer), k(a.color), j.vertexAttribPointer(a.color, 3, j.FLOAT, !1, 0, 0));\n        0 <= a.normal && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglNormalBuffer), k(a.normal), j.vertexAttribPointer(a.normal, 3, j.FLOAT, !1, 0, 0));\n        0 <= a.tangent && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglTangentBuffer), k(a.tangent), j.vertexAttribPointer(a.tangent, 4, j.FLOAT, !1, 0, 0));\n        0 <= a.uv && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglUVBuffer), k(a.uv), j.vertexAttribPointer(a.uv, 2, j.FLOAT, !1, 0, 0));\n        0 <= a.uv2 && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglUV2Buffer), k(a.uv2), j.vertexAttribPointer(a.uv2, 2, j.FLOAT, !1, 0, 0));\n        d.skinning && 0 <= a.skinIndex && 0 <= a.skinWeight && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglSkinIndicesBuffer), k(a.skinIndex), j.vertexAttribPointer(a.skinIndex, 4, j.FLOAT, !1, 0, 0), j.bindBuffer(j.ARRAY_BUFFER, e.__webglSkinWeightsBuffer), k(a.skinWeight), j.vertexAttribPointer(a.skinWeight, 4, j.FLOAT, !1, 0, 0));\n        0 <= a.lineDistance && (j.bindBuffer(j.ARRAY_BUFFER, e.__webglLineDistanceBuffer), k(a.lineDistance), j.vertexAttribPointer(a.lineDistance, 1, j.FLOAT, !1, 0, 0));\n      }\n      f instanceof THREE.Mesh ? (d.wireframe ? (J(d.wireframeLinewidth), b && j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer), j.drawElements(j.LINES, e.__webglLineCount, j.UNSIGNED_SHORT, 0)) : (b && j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer), j.drawElements(j.TRIANGLES, e.__webglFaceCount, j.UNSIGNED_SHORT, 0)), N.info.render.calls++, N.info.render.vertices += e.__webglFaceCount, N.info.render.faces += e.__webglFaceCount / 3) : f instanceof THREE.Line ? (f = f.type === THREE.LineStrip ? j.LINE_STRIP : j.LINES, J(d.linewidth), j.drawArrays(f, 0, e.__webglLineCount), N.info.render.calls++) : f instanceof THREE.ParticleSystem ? (j.drawArrays(j.POINTS, 0, e.__webglParticleCount), N.info.render.calls++, N.info.render.points += e.__webglParticleCount) : f instanceof THREE.Ribbon && (j.drawArrays(j.TRIANGLE_STRIP, 0, e.__webglVertexCount), N.info.render.calls++);\n    }\n  };\n  this.render = function (a, b, c, d) {\n    if (!1 === b instanceof THREE.Camera) console.error(\"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.\");else {\n      var e,\n        f,\n        g,\n        i,\n        h = a.__lights,\n        k = a.fog;\n      ta = -1;\n      bb = !0;\n      this.autoUpdateScene && a.updateMatrixWorld();\n      void 0 === b.parent && b.updateMatrixWorld();\n      b.matrixWorldInverse.getInverse(b.matrixWorld);\n      gc.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);\n      Va.setFromMatrix(gc);\n      this.autoUpdateObjects && this.initWebGLObjects(a);\n      s(this.renderPluginsPre, a, b);\n      N.info.render.calls = 0;\n      N.info.render.vertices = 0;\n      N.info.render.faces = 0;\n      N.info.render.points = 0;\n      this.setRenderTarget(c);\n      (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);\n      i = a.__webglObjects;\n      d = 0;\n      for (e = i.length; d < e; d++) if (f = i[d], g = f.object, f.render = !1, g.visible && (!(g instanceof THREE.Mesh || g instanceof THREE.ParticleSystem) || !g.frustumCulled || Va.intersectsObject(g))) {\n        C(g, b);\n        var n = f,\n          l = n.buffer,\n          q = void 0,\n          t = q = void 0,\n          t = n.object.material;\n        if (t instanceof THREE.MeshFaceMaterial) q = l.materialIndex, q = t.materials[q], q.transparent ? (n.transparent = q, n.opaque = null) : (n.opaque = q, n.transparent = null);else if (q = t) q.transparent ? (n.transparent = q, n.opaque = null) : (n.opaque = q, n.transparent = null);\n        f.render = !0;\n        !0 === this.sortObjects && (null !== g.renderDepth ? f.z = g.renderDepth : (Qa.getPositionFromMatrix(g.matrixWorld), Qa.applyProjection(gc), f.z = Qa.z), f.id = g.id);\n      }\n      this.sortObjects && i.sort(m);\n      i = a.__webglObjectsImmediate;\n      d = 0;\n      for (e = i.length; d < e; d++) f = i[d], g = f.object, g.visible && (C(g, b), g = f.object.material, g.transparent ? (f.transparent = g, f.opaque = null) : (f.opaque = g, f.transparent = null));\n      a.overrideMaterial ? (d = a.overrideMaterial, this.setBlending(d.blending, d.blendEquation, d.blendSrc, d.blendDst), this.setDepthTest(d.depthTest), this.setDepthWrite(d.depthWrite), E(d.polygonOffset, d.polygonOffsetFactor, d.polygonOffsetUnits), r(a.__webglObjects, !1, \"\", b, h, k, !0, d), p(a.__webglObjectsImmediate, \"\", b, h, k, !1, d)) : (d = null, this.setBlending(THREE.NoBlending), r(a.__webglObjects, !0, \"opaque\", b, h, k, !1, d), p(a.__webglObjectsImmediate, \"opaque\", b, h, k, !1, d), r(a.__webglObjects, !1, \"transparent\", b, h, k, !0, d), p(a.__webglObjectsImmediate, \"transparent\", b, h, k, !0, d));\n      s(this.renderPluginsPost, a, b);\n      c && c.generateMipmaps && c.minFilter !== THREE.NearestFilter && c.minFilter !== THREE.LinearFilter && (c instanceof THREE.WebGLRenderTargetCube ? (j.bindTexture(j.TEXTURE_CUBE_MAP, c.__webglTexture), j.generateMipmap(j.TEXTURE_CUBE_MAP), j.bindTexture(j.TEXTURE_CUBE_MAP, null)) : (j.bindTexture(j.TEXTURE_2D, c.__webglTexture), j.generateMipmap(j.TEXTURE_2D), j.bindTexture(j.TEXTURE_2D, null)));\n      this.setDepthTest(!0);\n      this.setDepthWrite(!0);\n    }\n  };\n  this.renderImmediateObject = function (a, b, c, d, e) {\n    var f = A(a, b, c, d, e);\n    ka = -1;\n    N.setMaterialFaces(d);\n    e.immediateRenderCallback ? e.immediateRenderCallback(f, j, Va) : e.render(function (a) {\n      N.renderBufferImmediate(a, f, d);\n    });\n  };\n  this.initWebGLObjects = function (a) {\n    a.__webglObjects || (a.__webglObjects = [], a.__webglObjectsImmediate = [], a.__webglSprites = [], a.__webglFlares = []);\n    for (; a.__objectsAdded.length;) {\n      var b = a.__objectsAdded[0],\n        k = a,\n        l = void 0,\n        m = void 0,\n        p = void 0,\n        r = void 0;\n      if (!b.__webglInit) if (b.__webglInit = !0, b._modelViewMatrix = new THREE.Matrix4(), b._normalMatrix = new THREE.Matrix3(), void 0 !== b.geometry && void 0 === b.geometry.__webglInit && (b.geometry.__webglInit = !0, b.geometry.addEventListener(\"dispose\", wd)), b instanceof THREE.Mesh) {\n        if (m = b.geometry, p = b.material, m instanceof THREE.Geometry) {\n          if (void 0 === m.geometryGroups) {\n            var s = m,\n              x = void 0,\n              C = void 0,\n              B = void 0,\n              A = void 0,\n              F = void 0,\n              E = void 0,\n              G = {},\n              I = s.morphTargets.length,\n              J = s.morphNormals.length,\n              K = p instanceof THREE.MeshFaceMaterial;\n            s.geometryGroups = {};\n            x = 0;\n            for (C = s.faces.length; x < C; x++) B = s.faces[x], A = K ? B.materialIndex : 0, void 0 === G[A] && (G[A] = {\n              hash: A,\n              counter: 0\n            }), E = G[A].hash + \"_\" + G[A].counter, void 0 === s.geometryGroups[E] && (s.geometryGroups[E] = {\n              faces3: [],\n              faces4: [],\n              materialIndex: A,\n              vertices: 0,\n              numMorphTargets: I,\n              numMorphNormals: J\n            }), F = B instanceof THREE.Face3 ? 3 : 4, 65535 < s.geometryGroups[E].vertices + F && (G[A].counter += 1, E = G[A].hash + \"_\" + G[A].counter, void 0 === s.geometryGroups[E] && (s.geometryGroups[E] = {\n              faces3: [],\n              faces4: [],\n              materialIndex: A,\n              vertices: 0,\n              numMorphTargets: I,\n              numMorphNormals: J\n            })), B instanceof THREE.Face3 ? s.geometryGroups[E].faces3.push(x) : s.geometryGroups[E].faces4.push(x), s.geometryGroups[E].vertices += F;\n            s.geometryGroupsList = [];\n            var L = void 0;\n            for (L in s.geometryGroups) s.geometryGroups[L].id = pa++, s.geometryGroupsList.push(s.geometryGroups[L]);\n          }\n          for (l in m.geometryGroups) if (r = m.geometryGroups[l], !r.__webglVertexBuffer) {\n            var H = r;\n            H.__webglVertexBuffer = j.createBuffer();\n            H.__webglNormalBuffer = j.createBuffer();\n            H.__webglTangentBuffer = j.createBuffer();\n            H.__webglColorBuffer = j.createBuffer();\n            H.__webglUVBuffer = j.createBuffer();\n            H.__webglUV2Buffer = j.createBuffer();\n            H.__webglSkinIndicesBuffer = j.createBuffer();\n            H.__webglSkinWeightsBuffer = j.createBuffer();\n            H.__webglFaceBuffer = j.createBuffer();\n            H.__webglLineBuffer = j.createBuffer();\n            var M = void 0,\n              P = void 0;\n            if (H.numMorphTargets) {\n              H.__webglMorphTargetsBuffers = [];\n              M = 0;\n              for (P = H.numMorphTargets; M < P; M++) H.__webglMorphTargetsBuffers.push(j.createBuffer());\n            }\n            if (H.numMorphNormals) {\n              H.__webglMorphNormalsBuffers = [];\n              M = 0;\n              for (P = H.numMorphNormals; M < P; M++) H.__webglMorphNormalsBuffers.push(j.createBuffer());\n            }\n            N.info.memory.geometries++;\n            d(r, b);\n            m.verticesNeedUpdate = !0;\n            m.morphTargetsNeedUpdate = !0;\n            m.elementsNeedUpdate = !0;\n            m.uvsNeedUpdate = !0;\n            m.normalsNeedUpdate = !0;\n            m.tangentsNeedUpdate = !0;\n            m.colorsNeedUpdate = !0;\n          }\n        } else m instanceof THREE.BufferGeometry && h(m);\n      } else if (b instanceof THREE.Ribbon) {\n        if (m = b.geometry, !m.__webglVertexBuffer) {\n          var U = m;\n          U.__webglVertexBuffer = j.createBuffer();\n          U.__webglColorBuffer = j.createBuffer();\n          U.__webglNormalBuffer = j.createBuffer();\n          N.info.memory.geometries++;\n          var aa = m,\n            W = b,\n            Y = aa.vertices.length;\n          aa.__vertexArray = new Float32Array(3 * Y);\n          aa.__colorArray = new Float32Array(3 * Y);\n          aa.__normalArray = new Float32Array(3 * Y);\n          aa.__webglVertexCount = Y;\n          c(aa, W);\n          m.verticesNeedUpdate = !0;\n          m.colorsNeedUpdate = !0;\n          m.normalsNeedUpdate = !0;\n        }\n      } else if (b instanceof THREE.Line) {\n        if (m = b.geometry, !m.__webglVertexBuffer) if (m instanceof THREE.Geometry) {\n          var Z = m;\n          Z.__webglVertexBuffer = j.createBuffer();\n          Z.__webglColorBuffer = j.createBuffer();\n          Z.__webglLineDistanceBuffer = j.createBuffer();\n          N.info.memory.geometries++;\n          var X = m,\n            da = b,\n            ka = X.vertices.length;\n          X.__vertexArray = new Float32Array(3 * ka);\n          X.__colorArray = new Float32Array(3 * ka);\n          X.__lineDistanceArray = new Float32Array(1 * ka);\n          X.__webglLineCount = ka;\n          c(X, da);\n          m.verticesNeedUpdate = !0;\n          m.colorsNeedUpdate = !0;\n          m.lineDistancesNeedUpdate = !0;\n        } else m instanceof THREE.BufferGeometry && h(m);\n      } else if (b instanceof THREE.ParticleSystem && (m = b.geometry, !m.__webglVertexBuffer)) if (m instanceof THREE.Geometry) {\n        var fa = m;\n        fa.__webglVertexBuffer = j.createBuffer();\n        fa.__webglColorBuffer = j.createBuffer();\n        N.info.memory.geometries++;\n        var ca = m,\n          Ma = b,\n          ha = ca.vertices.length;\n        ca.__vertexArray = new Float32Array(3 * ha);\n        ca.__colorArray = new Float32Array(3 * ha);\n        ca.__sortArray = [];\n        ca.__webglParticleCount = ha;\n        c(ca, Ma);\n        m.verticesNeedUpdate = !0;\n        m.colorsNeedUpdate = !0;\n      } else m instanceof THREE.BufferGeometry && h(m);\n      if (!b.__webglActive) {\n        if (b instanceof THREE.Mesh) {\n          if (m = b.geometry, m instanceof THREE.BufferGeometry) q(k.__webglObjects, m, b);else {\n            if (m instanceof THREE.Geometry) for (l in m.geometryGroups) r = m.geometryGroups[l], q(k.__webglObjects, r, b);\n          }\n        } else b instanceof THREE.Ribbon || b instanceof THREE.Line || b instanceof THREE.ParticleSystem ? (m = b.geometry, q(k.__webglObjects, m, b)) : b instanceof THREE.ImmediateRenderObject || b.immediateRenderCallback ? k.__webglObjectsImmediate.push({\n          object: b,\n          opaque: null,\n          transparent: null\n        }) : b instanceof THREE.Sprite ? k.__webglSprites.push(b) : b instanceof THREE.LensFlare && k.__webglFlares.push(b);\n        b.__webglActive = !0;\n      }\n      a.__objectsAdded.splice(0, 1);\n    }\n    for (; a.__objectsRemoved.length;) {\n      var Na = a.__objectsRemoved[0],\n        la = a;\n      Na instanceof THREE.Mesh || Na instanceof THREE.ParticleSystem || Na instanceof THREE.Ribbon || Na instanceof THREE.Line ? z(la.__webglObjects, Na) : Na instanceof THREE.Sprite ? t(la.__webglSprites, Na) : Na instanceof THREE.LensFlare ? t(la.__webglFlares, Na) : (Na instanceof THREE.ImmediateRenderObject || Na.immediateRenderCallback) && z(la.__webglObjectsImmediate, Na);\n      Na.__webglActive = !1;\n      a.__objectsRemoved.splice(0, 1);\n    }\n    for (var oa = 0, ra = a.__webglObjects.length; oa < ra; oa++) {\n      var ta = a.__webglObjects[oa].object,\n        O = ta.geometry,\n        mb = void 0,\n        qa = void 0,\n        ia = void 0;\n      if (ta instanceof THREE.Mesh) {\n        if (O instanceof THREE.BufferGeometry) (O.verticesNeedUpdate || O.elementsNeedUpdate || O.uvsNeedUpdate || O.normalsNeedUpdate || O.colorsNeedUpdate || O.tangentsNeedUpdate) && i(O, j.DYNAMIC_DRAW, !O.dynamic), O.verticesNeedUpdate = !1, O.elementsNeedUpdate = !1, O.uvsNeedUpdate = !1, O.normalsNeedUpdate = !1, O.colorsNeedUpdate = !1, O.tangentsNeedUpdate = !1;else {\n          for (var Ca = 0, Ka = O.geometryGroupsList.length; Ca < Ka; Ca++) if (mb = O.geometryGroupsList[Ca], ia = e(ta, mb), O.buffersNeedUpdate && d(mb, ta), qa = ia.attributes && y(ia), O.verticesNeedUpdate || O.morphTargetsNeedUpdate || O.elementsNeedUpdate || O.uvsNeedUpdate || O.normalsNeedUpdate || O.colorsNeedUpdate || O.tangentsNeedUpdate || qa) {\n            var sa = mb,\n              La = ta,\n              Pa = j.DYNAMIC_DRAW,\n              Va = !O.dynamic,\n              Fa = ia;\n            if (sa.__inittedArrays) {\n              var gb = f(Fa),\n                Wa = Fa.vertexColors ? Fa.vertexColors : !1,\n                bb = g(Fa),\n                $a = gb === THREE.SmoothShading,\n                D = void 0,\n                V = void 0,\n                Ra = void 0,\n                Q = void 0,\n                ab = void 0,\n                Xa = void 0,\n                Sa = void 0,\n                nb = void 0,\n                cb = void 0,\n                pb = void 0,\n                ub = void 0,\n                R = void 0,\n                S = void 0,\n                T = void 0,\n                na = void 0,\n                Mb = void 0,\n                Nb = void 0,\n                Ob = void 0,\n                xb = void 0,\n                Pb = void 0,\n                Qb = void 0,\n                Rb = void 0,\n                yb = void 0,\n                Sb = void 0,\n                Tb = void 0,\n                Ub = void 0,\n                zb = void 0,\n                Vb = void 0,\n                Wb = void 0,\n                Xb = void 0,\n                Ib = void 0,\n                Yb = void 0,\n                Zb = void 0,\n                $b = void 0,\n                Jb = void 0,\n                xa = void 0,\n                fc = void 0,\n                nc = void 0,\n                Ab = void 0,\n                yc = void 0,\n                db = void 0,\n                mc = void 0,\n                Ya = void 0,\n                Za = void 0,\n                oc = void 0,\n                hc = void 0,\n                Oa = 0,\n                Ua = 0,\n                ic = 0,\n                jc = 0,\n                Eb = 0,\n                kb = 0,\n                Aa = 0,\n                ob = 0,\n                Ta = 0,\n                ba = 0,\n                ja = 0,\n                w = 0,\n                ya = void 0,\n                eb = sa.__vertexArray,\n                Dc = sa.__uvArray,\n                Ec = sa.__uv2Array,\n                Fb = sa.__normalArray,\n                Ga = sa.__tangentArray,\n                fb = sa.__colorArray,\n                Ha = sa.__skinIndexArray,\n                Ia = sa.__skinWeightArray,\n                sc = sa.__morphTargetsArrays,\n                tc = sa.__morphNormalsArrays,\n                od = sa.__webglCustomAttributesList,\n                u = void 0,\n                ac = sa.__faceArray,\n                wb = sa.__lineArray,\n                qb = La.geometry,\n                Mc = qb.elementsNeedUpdate,\n                Cc = qb.uvsNeedUpdate,\n                Nc = qb.normalsNeedUpdate,\n                Oc = qb.tangentsNeedUpdate,\n                Pc = qb.colorsNeedUpdate,\n                fd = qb.morphTargetsNeedUpdate,\n                uc = qb.vertices,\n                ua = sa.faces3,\n                va = sa.faces4,\n                lb = qb.faces,\n                pd = qb.faceVertexUvs[0],\n                qd = qb.faceVertexUvs[1],\n                vc = qb.skinIndices,\n                pc = qb.skinWeights,\n                qc = qb.morphTargets,\n                Qc = qb.morphNormals;\n              if (qb.verticesNeedUpdate) {\n                D = 0;\n                for (V = ua.length; D < V; D++) Q = lb[ua[D]], R = uc[Q.a], S = uc[Q.b], T = uc[Q.c], eb[Ua] = R.x, eb[Ua + 1] = R.y, eb[Ua + 2] = R.z, eb[Ua + 3] = S.x, eb[Ua + 4] = S.y, eb[Ua + 5] = S.z, eb[Ua + 6] = T.x, eb[Ua + 7] = T.y, eb[Ua + 8] = T.z, Ua += 9;\n                D = 0;\n                for (V = va.length; D < V; D++) Q = lb[va[D]], R = uc[Q.a], S = uc[Q.b], T = uc[Q.c], na = uc[Q.d], eb[Ua] = R.x, eb[Ua + 1] = R.y, eb[Ua + 2] = R.z, eb[Ua + 3] = S.x, eb[Ua + 4] = S.y, eb[Ua + 5] = S.z, eb[Ua + 6] = T.x, eb[Ua + 7] = T.y, eb[Ua + 8] = T.z, eb[Ua + 9] = na.x, eb[Ua + 10] = na.y, eb[Ua + 11] = na.z, Ua += 12;\n                j.bindBuffer(j.ARRAY_BUFFER, sa.__webglVertexBuffer);\n                j.bufferData(j.ARRAY_BUFFER, eb, Pa);\n              }\n              if (fd) {\n                db = 0;\n                for (mc = qc.length; db < mc; db++) {\n                  D = ja = 0;\n                  for (V = ua.length; D < V; D++) oc = ua[D], Q = lb[oc], R = qc[db].vertices[Q.a], S = qc[db].vertices[Q.b], T = qc[db].vertices[Q.c], Ya = sc[db], Ya[ja] = R.x, Ya[ja + 1] = R.y, Ya[ja + 2] = R.z, Ya[ja + 3] = S.x, Ya[ja + 4] = S.y, Ya[ja + 5] = S.z, Ya[ja + 6] = T.x, Ya[ja + 7] = T.y, Ya[ja + 8] = T.z, Fa.morphNormals && ($a ? (hc = Qc[db].vertexNormals[oc], Pb = hc.a, Qb = hc.b, Rb = hc.c) : Rb = Qb = Pb = Qc[db].faceNormals[oc], Za = tc[db], Za[ja] = Pb.x, Za[ja + 1] = Pb.y, Za[ja + 2] = Pb.z, Za[ja + 3] = Qb.x, Za[ja + 4] = Qb.y, Za[ja + 5] = Qb.z, Za[ja + 6] = Rb.x, Za[ja + 7] = Rb.y, Za[ja + 8] = Rb.z), ja += 9;\n                  D = 0;\n                  for (V = va.length; D < V; D++) oc = va[D], Q = lb[oc], R = qc[db].vertices[Q.a], S = qc[db].vertices[Q.b], T = qc[db].vertices[Q.c], na = qc[db].vertices[Q.d], Ya = sc[db], Ya[ja] = R.x, Ya[ja + 1] = R.y, Ya[ja + 2] = R.z, Ya[ja + 3] = S.x, Ya[ja + 4] = S.y, Ya[ja + 5] = S.z, Ya[ja + 6] = T.x, Ya[ja + 7] = T.y, Ya[ja + 8] = T.z, Ya[ja + 9] = na.x, Ya[ja + 10] = na.y, Ya[ja + 11] = na.z, Fa.morphNormals && ($a ? (hc = Qc[db].vertexNormals[oc], Pb = hc.a, Qb = hc.b, Rb = hc.c, yb = hc.d) : yb = Rb = Qb = Pb = Qc[db].faceNormals[oc], Za = tc[db], Za[ja] = Pb.x, Za[ja + 1] = Pb.y, Za[ja + 2] = Pb.z, Za[ja + 3] = Qb.x, Za[ja + 4] = Qb.y, Za[ja + 5] = Qb.z, Za[ja + 6] = Rb.x, Za[ja + 7] = Rb.y, Za[ja + 8] = Rb.z, Za[ja + 9] = yb.x, Za[ja + 10] = yb.y, Za[ja + 11] = yb.z), ja += 12;\n                  j.bindBuffer(j.ARRAY_BUFFER, sa.__webglMorphTargetsBuffers[db]);\n                  j.bufferData(j.ARRAY_BUFFER, sc[db], Pa);\n                  Fa.morphNormals && (j.bindBuffer(j.ARRAY_BUFFER, sa.__webglMorphNormalsBuffers[db]), j.bufferData(j.ARRAY_BUFFER, tc[db], Pa));\n                }\n              }\n              if (pc.length) {\n                D = 0;\n                for (V = ua.length; D < V; D++) Q = lb[ua[D]], Vb = pc[Q.a], Wb = pc[Q.b], Xb = pc[Q.c], Ia[ba] = Vb.x, Ia[ba + 1] = Vb.y, Ia[ba + 2] = Vb.z, Ia[ba + 3] = Vb.w, Ia[ba + 4] = Wb.x, Ia[ba + 5] = Wb.y, Ia[ba + 6] = Wb.z, Ia[ba + 7] = Wb.w, Ia[ba + 8] = Xb.x, Ia[ba + 9] = Xb.y, Ia[ba + 10] = Xb.z, Ia[ba + 11] = Xb.w, Yb = vc[Q.a], Zb = vc[Q.b], $b = vc[Q.c], Ha[ba] = Yb.x, Ha[ba + 1] = Yb.y, Ha[ba + 2] = Yb.z, Ha[ba + 3] = Yb.w, Ha[ba + 4] = Zb.x, Ha[ba + 5] = Zb.y, Ha[ba + 6] = Zb.z, Ha[ba + 7] = Zb.w, Ha[ba + 8] = $b.x, Ha[ba + 9] = $b.y, Ha[ba + 10] = $b.z, Ha[ba + 11] = $b.w, ba += 12;\n                D = 0;\n                for (V = va.length; D < V; D++) Q = lb[va[D]], Vb = pc[Q.a], Wb = pc[Q.b], Xb = pc[Q.c], Ib = pc[Q.d], Ia[ba] = Vb.x, Ia[ba + 1] = Vb.y, Ia[ba + 2] = Vb.z, Ia[ba + 3] = Vb.w, Ia[ba + 4] = Wb.x, Ia[ba + 5] = Wb.y, Ia[ba + 6] = Wb.z, Ia[ba + 7] = Wb.w, Ia[ba + 8] = Xb.x, Ia[ba + 9] = Xb.y, Ia[ba + 10] = Xb.z, Ia[ba + 11] = Xb.w, Ia[ba + 12] = Ib.x, Ia[ba + 13] = Ib.y, Ia[ba + 14] = Ib.z, Ia[ba + 15] = Ib.w, Yb = vc[Q.a], Zb = vc[Q.b], $b = vc[Q.c], Jb = vc[Q.d], Ha[ba] = Yb.x, Ha[ba + 1] = Yb.y, Ha[ba + 2] = Yb.z, Ha[ba + 3] = Yb.w, Ha[ba + 4] = Zb.x, Ha[ba + 5] = Zb.y, Ha[ba + 6] = Zb.z, Ha[ba + 7] = Zb.w, Ha[ba + 8] = $b.x, Ha[ba + 9] = $b.y, Ha[ba + 10] = $b.z, Ha[ba + 11] = $b.w, Ha[ba + 12] = Jb.x, Ha[ba + 13] = Jb.y, Ha[ba + 14] = Jb.z, Ha[ba + 15] = Jb.w, ba += 16;\n                0 < ba && (j.bindBuffer(j.ARRAY_BUFFER, sa.__webglSkinIndicesBuffer), j.bufferData(j.ARRAY_BUFFER, Ha, Pa), j.bindBuffer(j.ARRAY_BUFFER, sa.__webglSkinWeightsBuffer), j.bufferData(j.ARRAY_BUFFER, Ia, Pa));\n              }\n              if (Pc && Wa) {\n                D = 0;\n                for (V = ua.length; D < V; D++) Q = lb[ua[D]], Sa = Q.vertexColors, nb = Q.color, 3 === Sa.length && Wa === THREE.VertexColors ? (Sb = Sa[0], Tb = Sa[1], Ub = Sa[2]) : Ub = Tb = Sb = nb, fb[Ta] = Sb.r, fb[Ta + 1] = Sb.g, fb[Ta + 2] = Sb.b, fb[Ta + 3] = Tb.r, fb[Ta + 4] = Tb.g, fb[Ta + 5] = Tb.b, fb[Ta + 6] = Ub.r, fb[Ta + 7] = Ub.g, fb[Ta + 8] = Ub.b, Ta += 9;\n                D = 0;\n                for (V = va.length; D < V; D++) Q = lb[va[D]], Sa = Q.vertexColors, nb = Q.color, 4 === Sa.length && Wa === THREE.VertexColors ? (Sb = Sa[0], Tb = Sa[1], Ub = Sa[2], zb = Sa[3]) : zb = Ub = Tb = Sb = nb, fb[Ta] = Sb.r, fb[Ta + 1] = Sb.g, fb[Ta + 2] = Sb.b, fb[Ta + 3] = Tb.r, fb[Ta + 4] = Tb.g, fb[Ta + 5] = Tb.b, fb[Ta + 6] = Ub.r, fb[Ta + 7] = Ub.g, fb[Ta + 8] = Ub.b, fb[Ta + 9] = zb.r, fb[Ta + 10] = zb.g, fb[Ta + 11] = zb.b, Ta += 12;\n                0 < Ta && (j.bindBuffer(j.ARRAY_BUFFER, sa.__webglColorBuffer), j.bufferData(j.ARRAY_BUFFER, fb, Pa));\n              }\n              if (Oc && qb.hasTangents) {\n                D = 0;\n                for (V = ua.length; D < V; D++) Q = lb[ua[D]], cb = Q.vertexTangents, Mb = cb[0], Nb = cb[1], Ob = cb[2], Ga[Aa] = Mb.x, Ga[Aa + 1] = Mb.y, Ga[Aa + 2] = Mb.z, Ga[Aa + 3] = Mb.w, Ga[Aa + 4] = Nb.x, Ga[Aa + 5] = Nb.y, Ga[Aa + 6] = Nb.z, Ga[Aa + 7] = Nb.w, Ga[Aa + 8] = Ob.x, Ga[Aa + 9] = Ob.y, Ga[Aa + 10] = Ob.z, Ga[Aa + 11] = Ob.w, Aa += 12;\n                D = 0;\n                for (V = va.length; D < V; D++) Q = lb[va[D]], cb = Q.vertexTangents, Mb = cb[0], Nb = cb[1], Ob = cb[2], xb = cb[3], Ga[Aa] = Mb.x, Ga[Aa + 1] = Mb.y, Ga[Aa + 2] = Mb.z, Ga[Aa + 3] = Mb.w, Ga[Aa + 4] = Nb.x, Ga[Aa + 5] = Nb.y, Ga[Aa + 6] = Nb.z, Ga[Aa + 7] = Nb.w, Ga[Aa + 8] = Ob.x, Ga[Aa + 9] = Ob.y, Ga[Aa + 10] = Ob.z, Ga[Aa + 11] = Ob.w, Ga[Aa + 12] = xb.x, Ga[Aa + 13] = xb.y, Ga[Aa + 14] = xb.z, Ga[Aa + 15] = xb.w, Aa += 16;\n                j.bindBuffer(j.ARRAY_BUFFER, sa.__webglTangentBuffer);\n                j.bufferData(j.ARRAY_BUFFER, Ga, Pa);\n              }\n              if (Nc && gb) {\n                D = 0;\n                for (V = ua.length; D < V; D++) if (Q = lb[ua[D]], ab = Q.vertexNormals, Xa = Q.normal, 3 === ab.length && $a) for (xa = 0; 3 > xa; xa++) nc = ab[xa], Fb[kb] = nc.x, Fb[kb + 1] = nc.y, Fb[kb + 2] = nc.z, kb += 3;else for (xa = 0; 3 > xa; xa++) Fb[kb] = Xa.x, Fb[kb + 1] = Xa.y, Fb[kb + 2] = Xa.z, kb += 3;\n                D = 0;\n                for (V = va.length; D < V; D++) if (Q = lb[va[D]], ab = Q.vertexNormals, Xa = Q.normal, 4 === ab.length && $a) for (xa = 0; 4 > xa; xa++) nc = ab[xa], Fb[kb] = nc.x, Fb[kb + 1] = nc.y, Fb[kb + 2] = nc.z, kb += 3;else for (xa = 0; 4 > xa; xa++) Fb[kb] = Xa.x, Fb[kb + 1] = Xa.y, Fb[kb + 2] = Xa.z, kb += 3;\n                j.bindBuffer(j.ARRAY_BUFFER, sa.__webglNormalBuffer);\n                j.bufferData(j.ARRAY_BUFFER, Fb, Pa);\n              }\n              if (Cc && pd && bb) {\n                D = 0;\n                for (V = ua.length; D < V; D++) if (Ra = ua[D], pb = pd[Ra], void 0 !== pb) for (xa = 0; 3 > xa; xa++) Ab = pb[xa], Dc[ic] = Ab.x, Dc[ic + 1] = Ab.y, ic += 2;\n                D = 0;\n                for (V = va.length; D < V; D++) if (Ra = va[D], pb = pd[Ra], void 0 !== pb) for (xa = 0; 4 > xa; xa++) Ab = pb[xa], Dc[ic] = Ab.x, Dc[ic + 1] = Ab.y, ic += 2;\n                0 < ic && (j.bindBuffer(j.ARRAY_BUFFER, sa.__webglUVBuffer), j.bufferData(j.ARRAY_BUFFER, Dc, Pa));\n              }\n              if (Cc && qd && bb) {\n                D = 0;\n                for (V = ua.length; D < V; D++) if (Ra = ua[D], ub = qd[Ra], void 0 !== ub) for (xa = 0; 3 > xa; xa++) yc = ub[xa], Ec[jc] = yc.x, Ec[jc + 1] = yc.y, jc += 2;\n                D = 0;\n                for (V = va.length; D < V; D++) if (Ra = va[D], ub = qd[Ra], void 0 !== ub) for (xa = 0; 4 > xa; xa++) yc = ub[xa], Ec[jc] = yc.x, Ec[jc + 1] = yc.y, jc += 2;\n                0 < jc && (j.bindBuffer(j.ARRAY_BUFFER, sa.__webglUV2Buffer), j.bufferData(j.ARRAY_BUFFER, Ec, Pa));\n              }\n              if (Mc) {\n                D = 0;\n                for (V = ua.length; D < V; D++) ac[Eb] = Oa, ac[Eb + 1] = Oa + 1, ac[Eb + 2] = Oa + 2, Eb += 3, wb[ob] = Oa, wb[ob + 1] = Oa + 1, wb[ob + 2] = Oa, wb[ob + 3] = Oa + 2, wb[ob + 4] = Oa + 1, wb[ob + 5] = Oa + 2, ob += 6, Oa += 3;\n                D = 0;\n                for (V = va.length; D < V; D++) ac[Eb] = Oa, ac[Eb + 1] = Oa + 1, ac[Eb + 2] = Oa + 3, ac[Eb + 3] = Oa + 1, ac[Eb + 4] = Oa + 2, ac[Eb + 5] = Oa + 3, Eb += 6, wb[ob] = Oa, wb[ob + 1] = Oa + 1, wb[ob + 2] = Oa, wb[ob + 3] = Oa + 3, wb[ob + 4] = Oa + 1, wb[ob + 5] = Oa + 2, wb[ob + 6] = Oa + 2, wb[ob + 7] = Oa + 3, ob += 8, Oa += 4;\n                j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, sa.__webglFaceBuffer);\n                j.bufferData(j.ELEMENT_ARRAY_BUFFER, ac, Pa);\n                j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, sa.__webglLineBuffer);\n                j.bufferData(j.ELEMENT_ARRAY_BUFFER, wb, Pa);\n              }\n              if (od) {\n                xa = 0;\n                for (fc = od.length; xa < fc; xa++) if (u = od[xa], u.__original.needsUpdate) {\n                  w = 0;\n                  if (1 === u.size) {\n                    if (void 0 === u.boundTo || \"vertices\" === u.boundTo) {\n                      D = 0;\n                      for (V = ua.length; D < V; D++) Q = lb[ua[D]], u.array[w] = u.value[Q.a], u.array[w + 1] = u.value[Q.b], u.array[w + 2] = u.value[Q.c], w += 3;\n                      D = 0;\n                      for (V = va.length; D < V; D++) Q = lb[va[D]], u.array[w] = u.value[Q.a], u.array[w + 1] = u.value[Q.b], u.array[w + 2] = u.value[Q.c], u.array[w + 3] = u.value[Q.d], w += 4;\n                    } else {\n                      if (\"faces\" === u.boundTo) {\n                        D = 0;\n                        for (V = ua.length; D < V; D++) ya = u.value[ua[D]], u.array[w] = ya, u.array[w + 1] = ya, u.array[w + 2] = ya, w += 3;\n                        D = 0;\n                        for (V = va.length; D < V; D++) ya = u.value[va[D]], u.array[w] = ya, u.array[w + 1] = ya, u.array[w + 2] = ya, u.array[w + 3] = ya, w += 4;\n                      }\n                    }\n                  } else if (2 === u.size) {\n                    if (void 0 === u.boundTo || \"vertices\" === u.boundTo) {\n                      D = 0;\n                      for (V = ua.length; D < V; D++) Q = lb[ua[D]], R = u.value[Q.a], S = u.value[Q.b], T = u.value[Q.c], u.array[w] = R.x, u.array[w + 1] = R.y, u.array[w + 2] = S.x, u.array[w + 3] = S.y, u.array[w + 4] = T.x, u.array[w + 5] = T.y, w += 6;\n                      D = 0;\n                      for (V = va.length; D < V; D++) Q = lb[va[D]], R = u.value[Q.a], S = u.value[Q.b], T = u.value[Q.c], na = u.value[Q.d], u.array[w] = R.x, u.array[w + 1] = R.y, u.array[w + 2] = S.x, u.array[w + 3] = S.y, u.array[w + 4] = T.x, u.array[w + 5] = T.y, u.array[w + 6] = na.x, u.array[w + 7] = na.y, w += 8;\n                    } else {\n                      if (\"faces\" === u.boundTo) {\n                        D = 0;\n                        for (V = ua.length; D < V; D++) T = S = R = ya = u.value[ua[D]], u.array[w] = R.x, u.array[w + 1] = R.y, u.array[w + 2] = S.x, u.array[w + 3] = S.y, u.array[w + 4] = T.x, u.array[w + 5] = T.y, w += 6;\n                        D = 0;\n                        for (V = va.length; D < V; D++) na = T = S = R = ya = u.value[va[D]], u.array[w] = R.x, u.array[w + 1] = R.y, u.array[w + 2] = S.x, u.array[w + 3] = S.y, u.array[w + 4] = T.x, u.array[w + 5] = T.y, u.array[w + 6] = na.x, u.array[w + 7] = na.y, w += 8;\n                      }\n                    }\n                  } else if (3 === u.size) {\n                    var $;\n                    $ = \"c\" === u.type ? [\"r\", \"g\", \"b\"] : [\"x\", \"y\", \"z\"];\n                    if (void 0 === u.boundTo || \"vertices\" === u.boundTo) {\n                      D = 0;\n                      for (V = ua.length; D < V; D++) Q = lb[ua[D]], R = u.value[Q.a], S = u.value[Q.b], T = u.value[Q.c], u.array[w] = R[$[0]], u.array[w + 1] = R[$[1]], u.array[w + 2] = R[$[2]], u.array[w + 3] = S[$[0]], u.array[w + 4] = S[$[1]], u.array[w + 5] = S[$[2]], u.array[w + 6] = T[$[0]], u.array[w + 7] = T[$[1]], u.array[w + 8] = T[$[2]], w += 9;\n                      D = 0;\n                      for (V = va.length; D < V; D++) Q = lb[va[D]], R = u.value[Q.a], S = u.value[Q.b], T = u.value[Q.c], na = u.value[Q.d], u.array[w] = R[$[0]], u.array[w + 1] = R[$[1]], u.array[w + 2] = R[$[2]], u.array[w + 3] = S[$[0]], u.array[w + 4] = S[$[1]], u.array[w + 5] = S[$[2]], u.array[w + 6] = T[$[0]], u.array[w + 7] = T[$[1]], u.array[w + 8] = T[$[2]], u.array[w + 9] = na[$[0]], u.array[w + 10] = na[$[1]], u.array[w + 11] = na[$[2]], w += 12;\n                    } else if (\"faces\" === u.boundTo) {\n                      D = 0;\n                      for (V = ua.length; D < V; D++) T = S = R = ya = u.value[ua[D]], u.array[w] = R[$[0]], u.array[w + 1] = R[$[1]], u.array[w + 2] = R[$[2]], u.array[w + 3] = S[$[0]], u.array[w + 4] = S[$[1]], u.array[w + 5] = S[$[2]], u.array[w + 6] = T[$[0]], u.array[w + 7] = T[$[1]], u.array[w + 8] = T[$[2]], w += 9;\n                      D = 0;\n                      for (V = va.length; D < V; D++) na = T = S = R = ya = u.value[va[D]], u.array[w] = R[$[0]], u.array[w + 1] = R[$[1]], u.array[w + 2] = R[$[2]], u.array[w + 3] = S[$[0]], u.array[w + 4] = S[$[1]], u.array[w + 5] = S[$[2]], u.array[w + 6] = T[$[0]], u.array[w + 7] = T[$[1]], u.array[w + 8] = T[$[2]], u.array[w + 9] = na[$[0]], u.array[w + 10] = na[$[1]], u.array[w + 11] = na[$[2]], w += 12;\n                    } else if (\"faceVertices\" === u.boundTo) {\n                      D = 0;\n                      for (V = ua.length; D < V; D++) ya = u.value[ua[D]], R = ya[0], S = ya[1], T = ya[2], u.array[w] = R[$[0]], u.array[w + 1] = R[$[1]], u.array[w + 2] = R[$[2]], u.array[w + 3] = S[$[0]], u.array[w + 4] = S[$[1]], u.array[w + 5] = S[$[2]], u.array[w + 6] = T[$[0]], u.array[w + 7] = T[$[1]], u.array[w + 8] = T[$[2]], w += 9;\n                      D = 0;\n                      for (V = va.length; D < V; D++) ya = u.value[va[D]], R = ya[0], S = ya[1], T = ya[2], na = ya[3], u.array[w] = R[$[0]], u.array[w + 1] = R[$[1]], u.array[w + 2] = R[$[2]], u.array[w + 3] = S[$[0]], u.array[w + 4] = S[$[1]], u.array[w + 5] = S[$[2]], u.array[w + 6] = T[$[0]], u.array[w + 7] = T[$[1]], u.array[w + 8] = T[$[2]], u.array[w + 9] = na[$[0]], u.array[w + 10] = na[$[1]], u.array[w + 11] = na[$[2]], w += 12;\n                    }\n                  } else if (4 === u.size) if (void 0 === u.boundTo || \"vertices\" === u.boundTo) {\n                    D = 0;\n                    for (V = ua.length; D < V; D++) Q = lb[ua[D]], R = u.value[Q.a], S = u.value[Q.b], T = u.value[Q.c], u.array[w] = R.x, u.array[w + 1] = R.y, u.array[w + 2] = R.z, u.array[w + 3] = R.w, u.array[w + 4] = S.x, u.array[w + 5] = S.y, u.array[w + 6] = S.z, u.array[w + 7] = S.w, u.array[w + 8] = T.x, u.array[w + 9] = T.y, u.array[w + 10] = T.z, u.array[w + 11] = T.w, w += 12;\n                    D = 0;\n                    for (V = va.length; D < V; D++) Q = lb[va[D]], R = u.value[Q.a], S = u.value[Q.b], T = u.value[Q.c], na = u.value[Q.d], u.array[w] = R.x, u.array[w + 1] = R.y, u.array[w + 2] = R.z, u.array[w + 3] = R.w, u.array[w + 4] = S.x, u.array[w + 5] = S.y, u.array[w + 6] = S.z, u.array[w + 7] = S.w, u.array[w + 8] = T.x, u.array[w + 9] = T.y, u.array[w + 10] = T.z, u.array[w + 11] = T.w, u.array[w + 12] = na.x, u.array[w + 13] = na.y, u.array[w + 14] = na.z, u.array[w + 15] = na.w, w += 16;\n                  } else if (\"faces\" === u.boundTo) {\n                    D = 0;\n                    for (V = ua.length; D < V; D++) T = S = R = ya = u.value[ua[D]], u.array[w] = R.x, u.array[w + 1] = R.y, u.array[w + 2] = R.z, u.array[w + 3] = R.w, u.array[w + 4] = S.x, u.array[w + 5] = S.y, u.array[w + 6] = S.z, u.array[w + 7] = S.w, u.array[w + 8] = T.x, u.array[w + 9] = T.y, u.array[w + 10] = T.z, u.array[w + 11] = T.w, w += 12;\n                    D = 0;\n                    for (V = va.length; D < V; D++) na = T = S = R = ya = u.value[va[D]], u.array[w] = R.x, u.array[w + 1] = R.y, u.array[w + 2] = R.z, u.array[w + 3] = R.w, u.array[w + 4] = S.x, u.array[w + 5] = S.y, u.array[w + 6] = S.z, u.array[w + 7] = S.w, u.array[w + 8] = T.x, u.array[w + 9] = T.y, u.array[w + 10] = T.z, u.array[w + 11] = T.w, u.array[w + 12] = na.x, u.array[w + 13] = na.y, u.array[w + 14] = na.z, u.array[w + 15] = na.w, w += 16;\n                  } else if (\"faceVertices\" === u.boundTo) {\n                    D = 0;\n                    for (V = ua.length; D < V; D++) ya = u.value[ua[D]], R = ya[0], S = ya[1], T = ya[2], u.array[w] = R.x, u.array[w + 1] = R.y, u.array[w + 2] = R.z, u.array[w + 3] = R.w, u.array[w + 4] = S.x, u.array[w + 5] = S.y, u.array[w + 6] = S.z, u.array[w + 7] = S.w, u.array[w + 8] = T.x, u.array[w + 9] = T.y, u.array[w + 10] = T.z, u.array[w + 11] = T.w, w += 12;\n                    D = 0;\n                    for (V = va.length; D < V; D++) ya = u.value[va[D]], R = ya[0], S = ya[1], T = ya[2], na = ya[3], u.array[w] = R.x, u.array[w + 1] = R.y, u.array[w + 2] = R.z, u.array[w + 3] = R.w, u.array[w + 4] = S.x, u.array[w + 5] = S.y, u.array[w + 6] = S.z, u.array[w + 7] = S.w, u.array[w + 8] = T.x, u.array[w + 9] = T.y, u.array[w + 10] = T.z, u.array[w + 11] = T.w, u.array[w + 12] = na.x, u.array[w + 13] = na.y, u.array[w + 14] = na.z, u.array[w + 15] = na.w, w += 16;\n                  }\n                  j.bindBuffer(j.ARRAY_BUFFER, u.buffer);\n                  j.bufferData(j.ARRAY_BUFFER, u.array, Pa);\n                }\n              }\n              Va && (delete sa.__inittedArrays, delete sa.__colorArray, delete sa.__normalArray, delete sa.__tangentArray, delete sa.__uvArray, delete sa.__uv2Array, delete sa.__faceArray, delete sa.__vertexArray, delete sa.__lineArray, delete sa.__skinIndexArray, delete sa.__skinWeightArray);\n            }\n          }\n          O.verticesNeedUpdate = !1;\n          O.morphTargetsNeedUpdate = !1;\n          O.elementsNeedUpdate = !1;\n          O.uvsNeedUpdate = !1;\n          O.normalsNeedUpdate = !1;\n          O.colorsNeedUpdate = !1;\n          O.tangentsNeedUpdate = !1;\n          O.buffersNeedUpdate = !1;\n          ia.attributes && v(ia);\n        }\n      } else if (ta instanceof THREE.Ribbon) {\n        ia = e(ta, O);\n        qa = ia.attributes && y(ia);\n        if (O.verticesNeedUpdate || O.colorsNeedUpdate || O.normalsNeedUpdate || qa) {\n          var Gb = O,\n            Rc = j.DYNAMIC_DRAW,\n            Fc = void 0,\n            Gc = void 0,\n            Hc = void 0,\n            Sc = void 0,\n            za = void 0,\n            Tc = void 0,\n            Uc = void 0,\n            Vc = void 0,\n            xd = void 0,\n            ib = void 0,\n            zc = void 0,\n            Da = void 0,\n            rb = void 0,\n            yd = Gb.vertices,\n            zd = Gb.colors,\n            Ad = Gb.normals,\n            gd = yd.length,\n            hd = zd.length,\n            id = Ad.length,\n            Wc = Gb.__vertexArray,\n            Xc = Gb.__colorArray,\n            Yc = Gb.__normalArray,\n            jd = Gb.colorsNeedUpdate,\n            kd = Gb.normalsNeedUpdate,\n            rd = Gb.__webglCustomAttributesList;\n          if (Gb.verticesNeedUpdate) {\n            for (Fc = 0; Fc < gd; Fc++) Sc = yd[Fc], za = 3 * Fc, Wc[za] = Sc.x, Wc[za + 1] = Sc.y, Wc[za + 2] = Sc.z;\n            j.bindBuffer(j.ARRAY_BUFFER, Gb.__webglVertexBuffer);\n            j.bufferData(j.ARRAY_BUFFER, Wc, Rc);\n          }\n          if (jd) {\n            for (Gc = 0; Gc < hd; Gc++) Tc = zd[Gc], za = 3 * Gc, Xc[za] = Tc.r, Xc[za + 1] = Tc.g, Xc[za + 2] = Tc.b;\n            j.bindBuffer(j.ARRAY_BUFFER, Gb.__webglColorBuffer);\n            j.bufferData(j.ARRAY_BUFFER, Xc, Rc);\n          }\n          if (kd) {\n            for (Hc = 0; Hc < id; Hc++) Uc = Ad[Hc], za = 3 * Hc, Yc[za] = Uc.x, Yc[za + 1] = Uc.y, Yc[za + 2] = Uc.z;\n            j.bindBuffer(j.ARRAY_BUFFER, Gb.__webglNormalBuffer);\n            j.bufferData(j.ARRAY_BUFFER, Yc, Rc);\n          }\n          if (rd) {\n            Vc = 0;\n            for (xd = rd.length; Vc < xd; Vc++) if (Da = rd[Vc], Da.needsUpdate && (void 0 === Da.boundTo || \"vertices\" === Da.boundTo)) {\n              za = 0;\n              zc = Da.value.length;\n              if (1 === Da.size) for (ib = 0; ib < zc; ib++) Da.array[ib] = Da.value[ib];else if (2 === Da.size) for (ib = 0; ib < zc; ib++) rb = Da.value[ib], Da.array[za] = rb.x, Da.array[za + 1] = rb.y, za += 2;else if (3 === Da.size) {\n                if (\"c\" === Da.type) for (ib = 0; ib < zc; ib++) rb = Da.value[ib], Da.array[za] = rb.r, Da.array[za + 1] = rb.g, Da.array[za + 2] = rb.b, za += 3;else for (ib = 0; ib < zc; ib++) rb = Da.value[ib], Da.array[za] = rb.x, Da.array[za + 1] = rb.y, Da.array[za + 2] = rb.z, za += 3;\n              } else if (4 === Da.size) for (ib = 0; ib < zc; ib++) rb = Da.value[ib], Da.array[za] = rb.x, Da.array[za + 1] = rb.y, Da.array[za + 2] = rb.z, Da.array[za + 3] = rb.w, za += 4;\n              j.bindBuffer(j.ARRAY_BUFFER, Da.buffer);\n              j.bufferData(j.ARRAY_BUFFER, Da.array, Rc);\n            }\n          }\n        }\n        O.verticesNeedUpdate = !1;\n        O.colorsNeedUpdate = !1;\n        O.normalsNeedUpdate = !1;\n        ia.attributes && v(ia);\n      } else if (ta instanceof THREE.Line) {\n        if (O instanceof THREE.BufferGeometry) (O.verticesNeedUpdate || O.colorsNeedUpdate) && i(O, j.DYNAMIC_DRAW, !O.dynamic), O.verticesNeedUpdate = !1, O.colorsNeedUpdate = !1;else {\n          ia = e(ta, O);\n          qa = ia.attributes && y(ia);\n          if (O.verticesNeedUpdate || O.colorsNeedUpdate || O.lineDistancesNeedUpdate || qa) {\n            var Hb = O,\n              Zc = j.DYNAMIC_DRAW,\n              Ic = void 0,\n              Jc = void 0,\n              Kc = void 0,\n              $c = void 0,\n              Ja = void 0,\n              ad = void 0,\n              Bd = Hb.vertices,\n              Cd = Hb.colors,\n              Dd = Hb.lineDistances,\n              ld = Bd.length,\n              Jd = Cd.length,\n              Kd = Dd.length,\n              bd = Hb.__vertexArray,\n              cd = Hb.__colorArray,\n              Ed = Hb.__lineDistanceArray,\n              Ld = Hb.colorsNeedUpdate,\n              Md = Hb.lineDistancesNeedUpdate,\n              sd = Hb.__webglCustomAttributesList,\n              dd = void 0,\n              Fd = void 0,\n              jb = void 0,\n              Ac = void 0,\n              sb = void 0,\n              Ea = void 0;\n            if (Hb.verticesNeedUpdate) {\n              for (Ic = 0; Ic < ld; Ic++) $c = Bd[Ic], Ja = 3 * Ic, bd[Ja] = $c.x, bd[Ja + 1] = $c.y, bd[Ja + 2] = $c.z;\n              j.bindBuffer(j.ARRAY_BUFFER, Hb.__webglVertexBuffer);\n              j.bufferData(j.ARRAY_BUFFER, bd, Zc);\n            }\n            if (Ld) {\n              for (Jc = 0; Jc < Jd; Jc++) ad = Cd[Jc], Ja = 3 * Jc, cd[Ja] = ad.r, cd[Ja + 1] = ad.g, cd[Ja + 2] = ad.b;\n              j.bindBuffer(j.ARRAY_BUFFER, Hb.__webglColorBuffer);\n              j.bufferData(j.ARRAY_BUFFER, cd, Zc);\n            }\n            if (Md) {\n              for (Kc = 0; Kc < Kd; Kc++) Ed[Kc] = Dd[Kc];\n              j.bindBuffer(j.ARRAY_BUFFER, Hb.__webglLineDistanceBuffer);\n              j.bufferData(j.ARRAY_BUFFER, Ed, Zc);\n            }\n            if (sd) {\n              dd = 0;\n              for (Fd = sd.length; dd < Fd; dd++) if (Ea = sd[dd], Ea.needsUpdate && (void 0 === Ea.boundTo || \"vertices\" === Ea.boundTo)) {\n                Ja = 0;\n                Ac = Ea.value.length;\n                if (1 === Ea.size) for (jb = 0; jb < Ac; jb++) Ea.array[jb] = Ea.value[jb];else if (2 === Ea.size) for (jb = 0; jb < Ac; jb++) sb = Ea.value[jb], Ea.array[Ja] = sb.x, Ea.array[Ja + 1] = sb.y, Ja += 2;else if (3 === Ea.size) {\n                  if (\"c\" === Ea.type) for (jb = 0; jb < Ac; jb++) sb = Ea.value[jb], Ea.array[Ja] = sb.r, Ea.array[Ja + 1] = sb.g, Ea.array[Ja + 2] = sb.b, Ja += 3;else for (jb = 0; jb < Ac; jb++) sb = Ea.value[jb], Ea.array[Ja] = sb.x, Ea.array[Ja + 1] = sb.y, Ea.array[Ja + 2] = sb.z, Ja += 3;\n                } else if (4 === Ea.size) for (jb = 0; jb < Ac; jb++) sb = Ea.value[jb], Ea.array[Ja] = sb.x, Ea.array[Ja + 1] = sb.y, Ea.array[Ja + 2] = sb.z, Ea.array[Ja + 3] = sb.w, Ja += 4;\n                j.bindBuffer(j.ARRAY_BUFFER, Ea.buffer);\n                j.bufferData(j.ARRAY_BUFFER, Ea.array, Zc);\n              }\n            }\n          }\n          O.verticesNeedUpdate = !1;\n          O.colorsNeedUpdate = !1;\n          O.lineDistancesNeedUpdate = !1;\n          ia.attributes && v(ia);\n        }\n      } else if (ta instanceof THREE.ParticleSystem) if (O instanceof THREE.BufferGeometry) (O.verticesNeedUpdate || O.colorsNeedUpdate) && i(O, j.DYNAMIC_DRAW, !O.dynamic), O.verticesNeedUpdate = !1, O.colorsNeedUpdate = !1;else {\n        ia = e(ta, O);\n        qa = ia.attributes && y(ia);\n        if (O.verticesNeedUpdate || O.colorsNeedUpdate || ta.sortParticles || qa) {\n          var bc = O,\n            td = j.DYNAMIC_DRAW,\n            Lc = ta,\n            tb = void 0,\n            cc = void 0,\n            dc = void 0,\n            ga = void 0,\n            ec = void 0,\n            rc = void 0,\n            ed = bc.vertices,\n            ud = ed.length,\n            vd = bc.colors,\n            Gd = vd.length,\n            wc = bc.__vertexArray,\n            xc = bc.__colorArray,\n            kc = bc.__sortArray,\n            Hd = bc.verticesNeedUpdate,\n            Id = bc.colorsNeedUpdate,\n            lc = bc.__webglCustomAttributesList,\n            Kb = void 0,\n            Bc = void 0,\n            ma = void 0,\n            Lb = void 0,\n            Ba = void 0,\n            ea = void 0;\n          if (Lc.sortParticles) {\n            vb.copy(gc);\n            vb.multiply(Lc.matrixWorld);\n            for (tb = 0; tb < ud; tb++) dc = ed[tb], Qa.copy(dc), Qa.applyProjection(vb), kc[tb] = [Qa.z, tb];\n            kc.sort(n);\n            for (tb = 0; tb < ud; tb++) dc = ed[kc[tb][1]], ga = 3 * tb, wc[ga] = dc.x, wc[ga + 1] = dc.y, wc[ga + 2] = dc.z;\n            for (cc = 0; cc < Gd; cc++) ga = 3 * cc, rc = vd[kc[cc][1]], xc[ga] = rc.r, xc[ga + 1] = rc.g, xc[ga + 2] = rc.b;\n            if (lc) {\n              Kb = 0;\n              for (Bc = lc.length; Kb < Bc; Kb++) if (ea = lc[Kb], void 0 === ea.boundTo || \"vertices\" === ea.boundTo) if (ga = 0, Lb = ea.value.length, 1 === ea.size) for (ma = 0; ma < Lb; ma++) ec = kc[ma][1], ea.array[ma] = ea.value[ec];else if (2 === ea.size) for (ma = 0; ma < Lb; ma++) ec = kc[ma][1], Ba = ea.value[ec], ea.array[ga] = Ba.x, ea.array[ga + 1] = Ba.y, ga += 2;else if (3 === ea.size) {\n                if (\"c\" === ea.type) for (ma = 0; ma < Lb; ma++) ec = kc[ma][1], Ba = ea.value[ec], ea.array[ga] = Ba.r, ea.array[ga + 1] = Ba.g, ea.array[ga + 2] = Ba.b, ga += 3;else for (ma = 0; ma < Lb; ma++) ec = kc[ma][1], Ba = ea.value[ec], ea.array[ga] = Ba.x, ea.array[ga + 1] = Ba.y, ea.array[ga + 2] = Ba.z, ga += 3;\n              } else if (4 === ea.size) for (ma = 0; ma < Lb; ma++) ec = kc[ma][1], Ba = ea.value[ec], ea.array[ga] = Ba.x, ea.array[ga + 1] = Ba.y, ea.array[ga + 2] = Ba.z, ea.array[ga + 3] = Ba.w, ga += 4;\n            }\n          } else {\n            if (Hd) for (tb = 0; tb < ud; tb++) dc = ed[tb], ga = 3 * tb, wc[ga] = dc.x, wc[ga + 1] = dc.y, wc[ga + 2] = dc.z;\n            if (Id) for (cc = 0; cc < Gd; cc++) rc = vd[cc], ga = 3 * cc, xc[ga] = rc.r, xc[ga + 1] = rc.g, xc[ga + 2] = rc.b;\n            if (lc) {\n              Kb = 0;\n              for (Bc = lc.length; Kb < Bc; Kb++) if (ea = lc[Kb], ea.needsUpdate && (void 0 === ea.boundTo || \"vertices\" === ea.boundTo)) if (Lb = ea.value.length, ga = 0, 1 === ea.size) for (ma = 0; ma < Lb; ma++) ea.array[ma] = ea.value[ma];else if (2 === ea.size) for (ma = 0; ma < Lb; ma++) Ba = ea.value[ma], ea.array[ga] = Ba.x, ea.array[ga + 1] = Ba.y, ga += 2;else if (3 === ea.size) {\n                if (\"c\" === ea.type) for (ma = 0; ma < Lb; ma++) Ba = ea.value[ma], ea.array[ga] = Ba.r, ea.array[ga + 1] = Ba.g, ea.array[ga + 2] = Ba.b, ga += 3;else for (ma = 0; ma < Lb; ma++) Ba = ea.value[ma], ea.array[ga] = Ba.x, ea.array[ga + 1] = Ba.y, ea.array[ga + 2] = Ba.z, ga += 3;\n              } else if (4 === ea.size) for (ma = 0; ma < Lb; ma++) Ba = ea.value[ma], ea.array[ga] = Ba.x, ea.array[ga + 1] = Ba.y, ea.array[ga + 2] = Ba.z, ea.array[ga + 3] = Ba.w, ga += 4;\n            }\n          }\n          if (Hd || Lc.sortParticles) j.bindBuffer(j.ARRAY_BUFFER, bc.__webglVertexBuffer), j.bufferData(j.ARRAY_BUFFER, wc, td);\n          if (Id || Lc.sortParticles) j.bindBuffer(j.ARRAY_BUFFER, bc.__webglColorBuffer), j.bufferData(j.ARRAY_BUFFER, xc, td);\n          if (lc) {\n            Kb = 0;\n            for (Bc = lc.length; Kb < Bc; Kb++) if (ea = lc[Kb], ea.needsUpdate || Lc.sortParticles) j.bindBuffer(j.ARRAY_BUFFER, ea.buffer), j.bufferData(j.ARRAY_BUFFER, ea.array, td);\n          }\n        }\n        O.verticesNeedUpdate = !1;\n        O.colorsNeedUpdate = !1;\n        ia.attributes && v(ia);\n      }\n    }\n  };\n  this.initMaterial = function (a, b, c, d) {\n    var e, f, g, i;\n    a.addEventListener(\"dispose\", X);\n    var h, k, m, n, l;\n    a instanceof THREE.MeshDepthMaterial ? l = \"depth\" : a instanceof THREE.MeshNormalMaterial ? l = \"normal\" : a instanceof THREE.MeshBasicMaterial ? l = \"basic\" : a instanceof THREE.MeshLambertMaterial ? l = \"lambert\" : a instanceof THREE.MeshPhongMaterial ? l = \"phong\" : a instanceof THREE.LineBasicMaterial ? l = \"basic\" : a instanceof THREE.LineDashedMaterial ? l = \"dashed\" : a instanceof THREE.ParticleBasicMaterial && (l = \"particle_basic\");\n    if (l) {\n      var p = THREE.ShaderLib[l];\n      a.uniforms = THREE.UniformsUtils.clone(p.uniforms);\n      a.vertexShader = p.vertexShader;\n      a.fragmentShader = p.fragmentShader;\n    }\n    var q, s, r;\n    e = g = s = r = p = 0;\n    for (f = b.length; e < f; e++) q = b[e], q.onlyShadow || (q instanceof THREE.DirectionalLight && g++, q instanceof THREE.PointLight && s++, q instanceof THREE.SpotLight && r++, q instanceof THREE.HemisphereLight && p++);\n    e = g;\n    f = s;\n    g = r;\n    i = p;\n    p = q = 0;\n    for (r = b.length; p < r; p++) s = b[p], s.castShadow && (s instanceof THREE.SpotLight && q++, s instanceof THREE.DirectionalLight && !s.shadowCascade && q++);\n    n = q;\n    tc && d && d.useVertexTexture ? m = 1024 : (b = j.getParameter(j.MAX_VERTEX_UNIFORM_VECTORS), b = Math.floor((b - 20) / 4), void 0 !== d && d instanceof THREE.SkinnedMesh && (b = Math.min(d.bones.length, b), b < d.bones.length && console.warn(\"WebGLRenderer: too many bones - \" + d.bones.length + \", this GPU supports just \" + b + \" (try OpenGL instead of ANGLE)\")), m = b);\n    a: {\n      s = a.fragmentShader;\n      r = a.vertexShader;\n      p = a.uniforms;\n      b = a.attributes;\n      q = a.defines;\n      var c = {\n          map: !!a.map,\n          envMap: !!a.envMap,\n          lightMap: !!a.lightMap,\n          bumpMap: !!a.bumpMap,\n          normalMap: !!a.normalMap,\n          specularMap: !!a.specularMap,\n          vertexColors: a.vertexColors,\n          fog: c,\n          useFog: a.fog,\n          fogExp: c instanceof THREE.FogExp2,\n          sizeAttenuation: a.sizeAttenuation,\n          skinning: a.skinning,\n          maxBones: m,\n          useVertexTexture: tc && d && d.useVertexTexture,\n          boneTextureWidth: d && d.boneTextureWidth,\n          boneTextureHeight: d && d.boneTextureHeight,\n          morphTargets: a.morphTargets,\n          morphNormals: a.morphNormals,\n          maxMorphTargets: this.maxMorphTargets,\n          maxMorphNormals: this.maxMorphNormals,\n          maxDirLights: e,\n          maxPointLights: f,\n          maxSpotLights: g,\n          maxHemiLights: i,\n          maxShadows: n,\n          shadowMapEnabled: this.shadowMapEnabled && d.receiveShadow,\n          shadowMapType: this.shadowMapType,\n          shadowMapDebug: this.shadowMapDebug,\n          shadowMapCascade: this.shadowMapCascade,\n          alphaTest: a.alphaTest,\n          metal: a.metal,\n          perPixel: a.perPixel,\n          wrapAround: a.wrapAround,\n          doubleSided: a.side === THREE.DoubleSide,\n          flipSided: a.side === THREE.BackSide\n        },\n        t,\n        v,\n        y,\n        d = [];\n      l ? d.push(l) : (d.push(s), d.push(r));\n      for (v in q) d.push(v), d.push(q[v]);\n      for (t in c) d.push(t), d.push(c[t]);\n      l = d.join();\n      t = 0;\n      for (v = Ma.length; t < v; t++) if (d = Ma[t], d.code === l) {\n        d.usedTimes++;\n        k = d.program;\n        break a;\n      }\n      t = \"SHADOWMAP_TYPE_BASIC\";\n      c.shadowMapType === THREE.PCFShadowMap ? t = \"SHADOWMAP_TYPE_PCF\" : c.shadowMapType === THREE.PCFSoftShadowMap && (t = \"SHADOWMAP_TYPE_PCF_SOFT\");\n      v = [];\n      for (y in q) d = q[y], !1 !== d && (d = \"#define \" + y + \" \" + d, v.push(d));\n      d = v.join(\"\\n\");\n      y = j.createProgram();\n      v = [\"precision \" + fa + \" float;\", d, sc ? \"#define VERTEX_TEXTURES\" : \"\", N.gammaInput ? \"#define GAMMA_INPUT\" : \"\", N.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\", N.physicallyBasedShading ? \"#define PHYSICALLY_BASED_SHADING\" : \"\", \"#define MAX_DIR_LIGHTS \" + c.maxDirLights, \"#define MAX_POINT_LIGHTS \" + c.maxPointLights, \"#define MAX_SPOT_LIGHTS \" + c.maxSpotLights, \"#define MAX_HEMI_LIGHTS \" + c.maxHemiLights, \"#define MAX_SHADOWS \" + c.maxShadows, \"#define MAX_BONES \" + c.maxBones, c.map ? \"#define USE_MAP\" : \"\", c.envMap ? \"#define USE_ENVMAP\" : \"\", c.lightMap ? \"#define USE_LIGHTMAP\" : \"\", c.bumpMap ? \"#define USE_BUMPMAP\" : \"\", c.normalMap ? \"#define USE_NORMALMAP\" : \"\", c.specularMap ? \"#define USE_SPECULARMAP\" : \"\", c.vertexColors ? \"#define USE_COLOR\" : \"\", c.skinning ? \"#define USE_SKINNING\" : \"\", c.useVertexTexture ? \"#define BONE_TEXTURE\" : \"\", c.boneTextureWidth ? \"#define N_BONE_PIXEL_X \" + c.boneTextureWidth.toFixed(1) : \"\", c.boneTextureHeight ? \"#define N_BONE_PIXEL_Y \" + c.boneTextureHeight.toFixed(1) : \"\", c.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\", c.morphNormals ? \"#define USE_MORPHNORMALS\" : \"\", c.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\", c.wrapAround ? \"#define WRAP_AROUND\" : \"\", c.doubleSided ? \"#define DOUBLE_SIDED\" : \"\", c.flipSided ? \"#define FLIP_SIDED\" : \"\", c.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\", c.shadowMapEnabled ? \"#define \" + t : \"\", c.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\", c.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\", c.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\", \"uniform mat4 modelMatrix;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\nuniform vec3 cameraPosition;\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec2 uv;\\nattribute vec2 uv2;\\n#ifdef USE_COLOR\\nattribute vec3 color;\\n#endif\\n#ifdef USE_MORPHTARGETS\\nattribute vec3 morphTarget0;\\nattribute vec3 morphTarget1;\\nattribute vec3 morphTarget2;\\nattribute vec3 morphTarget3;\\n#ifdef USE_MORPHNORMALS\\nattribute vec3 morphNormal0;\\nattribute vec3 morphNormal1;\\nattribute vec3 morphNormal2;\\nattribute vec3 morphNormal3;\\n#else\\nattribute vec3 morphTarget4;\\nattribute vec3 morphTarget5;\\nattribute vec3 morphTarget6;\\nattribute vec3 morphTarget7;\\n#endif\\n#endif\\n#ifdef USE_SKINNING\\nattribute vec4 skinIndex;\\nattribute vec4 skinWeight;\\n#endif\\n\"].join(\"\\n\");\n      t = [\"precision \" + fa + \" float;\", c.bumpMap || c.normalMap ? \"#extension GL_OES_standard_derivatives : enable\" : \"\", d, \"#define MAX_DIR_LIGHTS \" + c.maxDirLights, \"#define MAX_POINT_LIGHTS \" + c.maxPointLights, \"#define MAX_SPOT_LIGHTS \" + c.maxSpotLights, \"#define MAX_HEMI_LIGHTS \" + c.maxHemiLights, \"#define MAX_SHADOWS \" + c.maxShadows, c.alphaTest ? \"#define ALPHATEST \" + c.alphaTest : \"\", N.gammaInput ? \"#define GAMMA_INPUT\" : \"\", N.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\", N.physicallyBasedShading ? \"#define PHYSICALLY_BASED_SHADING\" : \"\", c.useFog && c.fog ? \"#define USE_FOG\" : \"\", c.useFog && c.fogExp ? \"#define FOG_EXP2\" : \"\", c.map ? \"#define USE_MAP\" : \"\", c.envMap ? \"#define USE_ENVMAP\" : \"\", c.lightMap ? \"#define USE_LIGHTMAP\" : \"\", c.bumpMap ? \"#define USE_BUMPMAP\" : \"\", c.normalMap ? \"#define USE_NORMALMAP\" : \"\", c.specularMap ? \"#define USE_SPECULARMAP\" : \"\", c.vertexColors ? \"#define USE_COLOR\" : \"\", c.metal ? \"#define METAL\" : \"\", c.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\", c.wrapAround ? \"#define WRAP_AROUND\" : \"\", c.doubleSided ? \"#define DOUBLE_SIDED\" : \"\", c.flipSided ? \"#define FLIP_SIDED\" : \"\", c.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\", c.shadowMapEnabled ? \"#define \" + t : \"\", c.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\", c.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\", \"uniform mat4 viewMatrix;\\nuniform vec3 cameraPosition;\\n\"].join(\"\\n\");\n      t = B(\"fragment\", t + s);\n      v = B(\"vertex\", v + r);\n      j.attachShader(y, v);\n      j.attachShader(y, t);\n      j.linkProgram(y);\n      j.getProgramParameter(y, j.LINK_STATUS) || console.error(\"Could not initialise shader\\nVALIDATE_STATUS: \" + j.getProgramParameter(y, j.VALIDATE_STATUS) + \", gl error [\" + j.getError() + \"]\");\n      j.deleteShader(t);\n      j.deleteShader(v);\n      y.uniforms = {};\n      y.attributes = {};\n      var x;\n      t = \"viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences\".split(\" \");\n      c.useVertexTexture ? t.push(\"boneTexture\") : t.push(\"boneGlobalMatrices\");\n      for (x in p) t.push(x);\n      x = t;\n      t = 0;\n      for (v = x.length; t < v; t++) p = x[t], y.uniforms[p] = j.getUniformLocation(y, p);\n      t = \"position normal uv uv2 tangent color skinIndex skinWeight lineDistance\".split(\" \");\n      for (x = 0; x < c.maxMorphTargets; x++) t.push(\"morphTarget\" + x);\n      for (x = 0; x < c.maxMorphNormals; x++) t.push(\"morphNormal\" + x);\n      for (k in b) t.push(k);\n      k = t;\n      x = 0;\n      for (b = k.length; x < b; x++) t = k[x], y.attributes[t] = j.getAttribLocation(y, t);\n      y.id = Na++;\n      Ma.push({\n        program: y,\n        code: l,\n        usedTimes: 1\n      });\n      N.info.memory.programs = Ma.length;\n      k = y;\n    }\n    a.program = k;\n    x = a.program.attributes;\n    if (a.morphTargets) {\n      a.numSupportedMorphTargets = 0;\n      b = \"morphTarget\";\n      for (k = 0; k < this.maxMorphTargets; k++) y = b + k, 0 <= x[y] && a.numSupportedMorphTargets++;\n    }\n    if (a.morphNormals) {\n      a.numSupportedMorphNormals = 0;\n      b = \"morphNormal\";\n      for (k = 0; k < this.maxMorphNormals; k++) y = b + k, 0 <= x[y] && a.numSupportedMorphNormals++;\n    }\n    a.uniformsList = [];\n    for (h in a.uniforms) a.uniformsList.push([a.uniforms[h], h]);\n  };\n  this.setFaceCulling = function (a, b) {\n    a === THREE.CullFaceNone ? j.disable(j.CULL_FACE) : (b === THREE.FrontFaceDirectionCW ? j.frontFace(j.CW) : j.frontFace(j.CCW), a === THREE.CullFaceBack ? j.cullFace(j.BACK) : a === THREE.CullFaceFront ? j.cullFace(j.FRONT) : j.cullFace(j.FRONT_AND_BACK), j.enable(j.CULL_FACE));\n  };\n  this.setMaterialFaces = function (a) {\n    var b = a.side === THREE.DoubleSide,\n      a = a.side === THREE.BackSide;\n    da !== b && (b ? j.disable(j.CULL_FACE) : j.enable(j.CULL_FACE), da = b);\n    la !== a && (a ? j.frontFace(j.CW) : j.frontFace(j.CCW), la = a);\n  };\n  this.setDepthTest = function (a) {\n    ia !== a && (a ? j.enable(j.DEPTH_TEST) : j.disable(j.DEPTH_TEST), ia = a);\n  };\n  this.setDepthWrite = function (a) {\n    Wa !== a && (j.depthMask(a), Wa = a);\n  };\n  this.setBlending = function (a, b, c, d) {\n    a !== Z && (a === THREE.NoBlending ? j.disable(j.BLEND) : a === THREE.AdditiveBlending ? (j.enable(j.BLEND), j.blendEquation(j.FUNC_ADD), j.blendFunc(j.SRC_ALPHA, j.ONE)) : a === THREE.SubtractiveBlending ? (j.enable(j.BLEND), j.blendEquation(j.FUNC_ADD), j.blendFunc(j.ZERO, j.ONE_MINUS_SRC_COLOR)) : a === THREE.MultiplyBlending ? (j.enable(j.BLEND), j.blendEquation(j.FUNC_ADD), j.blendFunc(j.ZERO, j.SRC_COLOR)) : a === THREE.CustomBlending ? j.enable(j.BLEND) : (j.enable(j.BLEND), j.blendEquationSeparate(j.FUNC_ADD, j.FUNC_ADD), j.blendFuncSeparate(j.SRC_ALPHA, j.ONE_MINUS_SRC_ALPHA, j.ONE, j.ONE_MINUS_SRC_ALPHA)), Z = a);\n    if (a === THREE.CustomBlending) {\n      if (b !== oa && (j.blendEquation(L(b)), oa = b), c !== gb || d !== nb) j.blendFunc(L(c), L(d)), gb = c, nb = d;\n    } else nb = gb = oa = null;\n  };\n  this.setTexture = function (a, b) {\n    if (a.needsUpdate) {\n      a.__webglInit || (a.__webglInit = !0, a.addEventListener(\"dispose\", Oc), a.__webglTexture = j.createTexture(), N.info.memory.textures++);\n      j.activeTexture(j.TEXTURE0 + b);\n      j.bindTexture(j.TEXTURE_2D, a.__webglTexture);\n      j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL, a.flipY);\n      j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha);\n      j.pixelStorei(j.UNPACK_ALIGNMENT, a.unpackAlignment);\n      var c = a.image,\n        d = 0 === (c.width & c.width - 1) && 0 === (c.height & c.height - 1),\n        e = L(a.format),\n        f = L(a.type);\n      W(j.TEXTURE_2D, a, d);\n      var g = a.mipmaps;\n      if (a instanceof THREE.DataTexture) {\n        if (0 < g.length && d) {\n          for (var i = 0, h = g.length; i < h; i++) c = g[i], j.texImage2D(j.TEXTURE_2D, i, e, c.width, c.height, 0, e, f, c.data);\n          a.generateMipmaps = !1;\n        } else j.texImage2D(j.TEXTURE_2D, 0, e, c.width, c.height, 0, e, f, c.data);\n      } else if (a instanceof THREE.CompressedTexture) {\n        i = 0;\n        for (h = g.length; i < h; i++) c = g[i], j.compressedTexImage2D(j.TEXTURE_2D, i, e, c.width, c.height, 0, c.data);\n      } else if (0 < g.length && d) {\n        i = 0;\n        for (h = g.length; i < h; i++) c = g[i], j.texImage2D(j.TEXTURE_2D, i, e, e, f, c);\n        a.generateMipmaps = !1;\n      } else j.texImage2D(j.TEXTURE_2D, 0, e, e, f, a.image);\n      a.generateMipmaps && d && j.generateMipmap(j.TEXTURE_2D);\n      a.needsUpdate = !1;\n      if (a.onUpdate) a.onUpdate();\n    } else j.activeTexture(j.TEXTURE0 + b), j.bindTexture(j.TEXTURE_2D, a.__webglTexture);\n  };\n  this.setRenderTarget = function (a) {\n    var b = a instanceof THREE.WebGLRenderTargetCube;\n    if (a && !a.__webglFramebuffer) {\n      void 0 === a.depthBuffer && (a.depthBuffer = !0);\n      void 0 === a.stencilBuffer && (a.stencilBuffer = !0);\n      a.addEventListener(\"dispose\", P);\n      a.__webglTexture = j.createTexture();\n      N.info.memory.textures++;\n      var c = 0 === (a.width & a.width - 1) && 0 === (a.height & a.height - 1),\n        d = L(a.format),\n        e = L(a.type);\n      if (b) {\n        a.__webglFramebuffer = [];\n        a.__webglRenderbuffer = [];\n        j.bindTexture(j.TEXTURE_CUBE_MAP, a.__webglTexture);\n        W(j.TEXTURE_CUBE_MAP, a, c);\n        for (var f = 0; 6 > f; f++) {\n          a.__webglFramebuffer[f] = j.createFramebuffer();\n          a.__webglRenderbuffer[f] = j.createRenderbuffer();\n          j.texImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, d, a.width, a.height, 0, d, e, null);\n          var g = a,\n            i = j.TEXTURE_CUBE_MAP_POSITIVE_X + f;\n          j.bindFramebuffer(j.FRAMEBUFFER, a.__webglFramebuffer[f]);\n          j.framebufferTexture2D(j.FRAMEBUFFER, j.COLOR_ATTACHMENT0, i, g.__webglTexture, 0);\n          F(a.__webglRenderbuffer[f], a);\n        }\n        c && j.generateMipmap(j.TEXTURE_CUBE_MAP);\n      } else a.__webglFramebuffer = j.createFramebuffer(), a.__webglRenderbuffer = a.shareDepthFrom ? a.shareDepthFrom.__webglRenderbuffer : j.createRenderbuffer(), j.bindTexture(j.TEXTURE_2D, a.__webglTexture), W(j.TEXTURE_2D, a, c), j.texImage2D(j.TEXTURE_2D, 0, d, a.width, a.height, 0, d, e, null), d = j.TEXTURE_2D, j.bindFramebuffer(j.FRAMEBUFFER, a.__webglFramebuffer), j.framebufferTexture2D(j.FRAMEBUFFER, j.COLOR_ATTACHMENT0, d, a.__webglTexture, 0), a.shareDepthFrom ? a.depthBuffer && !a.stencilBuffer ? j.framebufferRenderbuffer(j.FRAMEBUFFER, j.DEPTH_ATTACHMENT, j.RENDERBUFFER, a.__webglRenderbuffer) : a.depthBuffer && a.stencilBuffer && j.framebufferRenderbuffer(j.FRAMEBUFFER, j.DEPTH_STENCIL_ATTACHMENT, j.RENDERBUFFER, a.__webglRenderbuffer) : F(a.__webglRenderbuffer, a), c && j.generateMipmap(j.TEXTURE_2D);\n      b ? j.bindTexture(j.TEXTURE_CUBE_MAP, null) : j.bindTexture(j.TEXTURE_2D, null);\n      j.bindRenderbuffer(j.RENDERBUFFER, null);\n      j.bindFramebuffer(j.FRAMEBUFFER, null);\n    }\n    a ? (b = b ? a.__webglFramebuffer[a.activeCubeFace] : a.__webglFramebuffer, c = a.width, a = a.height, e = d = 0) : (b = null, c = fc, a = Ab, d = Ib, e = Jb);\n    b !== Pa && (j.bindFramebuffer(j.FRAMEBUFFER, b), j.viewport(d, e, c, a), Pa = b);\n    mc = c;\n    pb = a;\n  };\n  this.shadowMapPlugin = new THREE.ShadowMapPlugin();\n  this.addPrePlugin(this.shadowMapPlugin);\n  this.addPostPlugin(new THREE.SpritePlugin());\n  this.addPostPlugin(new THREE.LensFlarePlugin());\n};\nTHREE.WebGLRenderTarget = function (a, b, c) {\n  THREE.EventDispatcher.call(this);\n  this.width = a;\n  this.height = b;\n  c = c || {};\n  this.wrapS = void 0 !== c.wrapS ? c.wrapS : THREE.ClampToEdgeWrapping;\n  this.wrapT = void 0 !== c.wrapT ? c.wrapT : THREE.ClampToEdgeWrapping;\n  this.magFilter = void 0 !== c.magFilter ? c.magFilter : THREE.LinearFilter;\n  this.minFilter = void 0 !== c.minFilter ? c.minFilter : THREE.LinearMipMapLinearFilter;\n  this.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1;\n  this.offset = new THREE.Vector2(0, 0);\n  this.repeat = new THREE.Vector2(1, 1);\n  this.format = void 0 !== c.format ? c.format : THREE.RGBAFormat;\n  this.type = void 0 !== c.type ? c.type : THREE.UnsignedByteType;\n  this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;\n  this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;\n  this.generateMipmaps = !0;\n  this.shareDepthFrom = null;\n};\nTHREE.WebGLRenderTarget.prototype.clone = function () {\n  var a = new THREE.WebGLRenderTarget(this.width, this.height);\n  a.wrapS = this.wrapS;\n  a.wrapT = this.wrapT;\n  a.magFilter = this.magFilter;\n  a.minFilter = this.minFilter;\n  a.anisotropy = this.anisotropy;\n  a.offset.copy(this.offset);\n  a.repeat.copy(this.repeat);\n  a.format = this.format;\n  a.type = this.type;\n  a.depthBuffer = this.depthBuffer;\n  a.stencilBuffer = this.stencilBuffer;\n  a.generateMipmaps = this.generateMipmaps;\n  a.shareDepthFrom = this.shareDepthFrom;\n  return a;\n};\nTHREE.WebGLRenderTarget.prototype.dispose = function () {\n  this.dispatchEvent({\n    type: \"dispose\"\n  });\n};\nTHREE.WebGLRenderTargetCube = function (a, b, c) {\n  THREE.WebGLRenderTarget.call(this, a, b, c);\n  this.activeCubeFace = 0;\n};\nTHREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);\nTHREE.RenderableVertex = function () {\n  this.positionWorld = new THREE.Vector3();\n  this.positionScreen = new THREE.Vector4();\n  this.visible = !0;\n};\nTHREE.RenderableVertex.prototype.copy = function (a) {\n  this.positionWorld.copy(a.positionWorld);\n  this.positionScreen.copy(a.positionScreen);\n};\nTHREE.RenderableFace3 = function () {\n  this.v1 = new THREE.RenderableVertex();\n  this.v2 = new THREE.RenderableVertex();\n  this.v3 = new THREE.RenderableVertex();\n  this.centroidModel = new THREE.Vector3();\n  this.normalModel = new THREE.Vector3();\n  this.normalModelView = new THREE.Vector3();\n  this.vertexNormalsLength = 0;\n  this.vertexNormalsModel = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];\n  this.vertexNormalsModelView = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];\n  this.material = this.color = null;\n  this.uvs = [[]];\n  this.z = null;\n};\nTHREE.RenderableFace4 = function () {\n  this.v1 = new THREE.RenderableVertex();\n  this.v2 = new THREE.RenderableVertex();\n  this.v3 = new THREE.RenderableVertex();\n  this.v4 = new THREE.RenderableVertex();\n  this.centroidModel = new THREE.Vector3();\n  this.normalModel = new THREE.Vector3();\n  this.normalModelView = new THREE.Vector3();\n  this.vertexNormalsLength = 0;\n  this.vertexNormalsModel = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];\n  this.vertexNormalsModelView = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];\n  this.material = this.color = null;\n  this.uvs = [[]];\n  this.z = null;\n};\nTHREE.RenderableObject = function () {\n  this.z = this.object = null;\n};\nTHREE.RenderableParticle = function () {\n  this.rotation = this.z = this.y = this.x = this.object = null;\n  this.scale = new THREE.Vector2();\n  this.material = null;\n};\nTHREE.RenderableLine = function () {\n  this.z = null;\n  this.v1 = new THREE.RenderableVertex();\n  this.v2 = new THREE.RenderableVertex();\n  this.material = null;\n};\nTHREE.GeometryUtils = {\n  merge: function merge(a, b) {\n    var c,\n      d,\n      e = a.vertices.length,\n      f = b instanceof THREE.Mesh ? b.geometry : b,\n      g = a.vertices,\n      h = f.vertices,\n      i = a.faces,\n      k = f.faces,\n      l = a.faceVertexUvs[0],\n      f = f.faceVertexUvs[0];\n    b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), c = b.matrix, d = new THREE.Matrix3(), d.getInverse(c), d.transpose());\n    for (var m = 0, n = h.length; m < n; m++) {\n      var s = h[m].clone();\n      c && s.applyMatrix4(c);\n      g.push(s);\n    }\n    m = 0;\n    for (n = k.length; m < n; m++) {\n      var s = k[m],\n        r,\n        p,\n        q = s.vertexNormals,\n        y = s.vertexColors;\n      s instanceof THREE.Face3 ? r = new THREE.Face3(s.a + e, s.b + e, s.c + e) : s instanceof THREE.Face4 && (r = new THREE.Face4(s.a + e, s.b + e, s.c + e, s.d + e));\n      r.normal.copy(s.normal);\n      d && r.normal.applyMatrix3(d).normalize();\n      g = 0;\n      for (h = q.length; g < h; g++) p = q[g].clone(), d && p.applyMatrix3(d).normalize(), r.vertexNormals.push(p);\n      r.color.copy(s.color);\n      g = 0;\n      for (h = y.length; g < h; g++) p = y[g], r.vertexColors.push(p.clone());\n      r.materialIndex = s.materialIndex;\n      r.centroid.copy(s.centroid);\n      c && r.centroid.applyMatrix4(c);\n      i.push(r);\n    }\n    m = 0;\n    for (n = f.length; m < n; m++) {\n      c = f[m];\n      d = [];\n      g = 0;\n      for (h = c.length; g < h; g++) d.push(new THREE.Vector2(c[g].x, c[g].y));\n      l.push(d);\n    }\n  },\n  removeMaterials: function removeMaterials(a, b) {\n    for (var c = {}, d = 0, e = b.length; d < e; d++) c[b[d]] = !0;\n    for (var f, g = [], d = 0, e = a.faces.length; d < e; d++) f = a.faces[d], f.materialIndex in c || g.push(f);\n    a.faces = g;\n  },\n  randomPointInTriangle: function randomPointInTriangle(a, b, c) {\n    var d,\n      e,\n      f,\n      g = new THREE.Vector3(),\n      h = THREE.GeometryUtils.__v1;\n    d = THREE.GeometryUtils.random();\n    e = THREE.GeometryUtils.random();\n    1 < d + e && (d = 1 - d, e = 1 - e);\n    f = 1 - d - e;\n    g.copy(a);\n    g.multiplyScalar(d);\n    h.copy(b);\n    h.multiplyScalar(e);\n    g.add(h);\n    h.copy(c);\n    h.multiplyScalar(f);\n    g.add(h);\n    return g;\n  },\n  randomPointInFace: function randomPointInFace(a, b, c) {\n    var d, e, f;\n    if (a instanceof THREE.Face3) return d = b.vertices[a.a], e = b.vertices[a.b], f = b.vertices[a.c], THREE.GeometryUtils.randomPointInTriangle(d, e, f);\n    if (a instanceof THREE.Face4) {\n      d = b.vertices[a.a];\n      e = b.vertices[a.b];\n      f = b.vertices[a.c];\n      var b = b.vertices[a.d],\n        g;\n      c ? a._area1 && a._area2 ? (c = a._area1, g = a._area2) : (c = THREE.GeometryUtils.triangleArea(d, e, b), g = THREE.GeometryUtils.triangleArea(e, f, b), a._area1 = c, a._area2 = g) : (c = THREE.GeometryUtils.triangleArea(d, e, b), g = THREE.GeometryUtils.triangleArea(e, f, b));\n      return THREE.GeometryUtils.random() * (c + g) < c ? THREE.GeometryUtils.randomPointInTriangle(d, e, b) : THREE.GeometryUtils.randomPointInTriangle(e, f, b);\n    }\n  },\n  randomPointsInGeometry: function randomPointsInGeometry(a, b) {\n    function c(a) {\n      function b(c, d) {\n        if (d < c) return c;\n        var e = c + Math.floor((d - c) / 2);\n        return k[e] > a ? b(c, e - 1) : k[e] < a ? b(e + 1, d) : e;\n      }\n      return b(0, k.length - 1);\n    }\n    var d,\n      e,\n      f = a.faces,\n      g = a.vertices,\n      h = f.length,\n      i = 0,\n      k = [],\n      l,\n      m,\n      n,\n      s;\n    for (e = 0; e < h; e++) d = f[e], d instanceof THREE.Face3 ? (l = g[d.a], m = g[d.b], n = g[d.c], d._area = THREE.GeometryUtils.triangleArea(l, m, n)) : d instanceof THREE.Face4 && (l = g[d.a], m = g[d.b], n = g[d.c], s = g[d.d], d._area1 = THREE.GeometryUtils.triangleArea(l, m, s), d._area2 = THREE.GeometryUtils.triangleArea(m, n, s), d._area = d._area1 + d._area2), i += d._area, k[e] = i;\n    d = [];\n    for (e = 0; e < b; e++) g = THREE.GeometryUtils.random() * i, g = c(g), d[e] = THREE.GeometryUtils.randomPointInFace(f[g], a, !0);\n    return d;\n  },\n  triangleArea: function triangleArea(a, b, c) {\n    var d = THREE.GeometryUtils.__v1,\n      e = THREE.GeometryUtils.__v2;\n    d.subVectors(b, a);\n    e.subVectors(c, a);\n    d.cross(e);\n    return 0.5 * d.length();\n  },\n  center: function center(a) {\n    a.computeBoundingBox();\n    var b = a.boundingBox,\n      c = new THREE.Vector3();\n    c.addVectors(b.min, b.max);\n    c.multiplyScalar(-0.5);\n    a.applyMatrix(new THREE.Matrix4().makeTranslation(c.x, c.y, c.z));\n    a.computeBoundingBox();\n    return c;\n  },\n  normalizeUVs: function normalizeUVs(a) {\n    for (var a = a.faceVertexUvs[0], b = 0, c = a.length; b < c; b++) for (var d = a[b], e = 0, f = d.length; e < f; e++) 1 !== d[e].x && (d[e].x -= Math.floor(d[e].x)), 1 !== d[e].y && (d[e].y -= Math.floor(d[e].y));\n  },\n  triangulateQuads: function triangulateQuads(a) {\n    var b,\n      c,\n      d,\n      e,\n      f = [],\n      g = [],\n      h = [];\n    b = 0;\n    for (c = a.faceUvs.length; b < c; b++) g[b] = [];\n    b = 0;\n    for (c = a.faceVertexUvs.length; b < c; b++) h[b] = [];\n    b = 0;\n    for (c = a.faces.length; b < c; b++) if (d = a.faces[b], d instanceof THREE.Face4) {\n      e = d.a;\n      var i = d.b,\n        k = d.c,\n        l = d.d,\n        m = new THREE.Face3(),\n        n = new THREE.Face3();\n      m.color.copy(d.color);\n      n.color.copy(d.color);\n      m.materialIndex = d.materialIndex;\n      n.materialIndex = d.materialIndex;\n      m.a = e;\n      m.b = i;\n      m.c = l;\n      n.a = i;\n      n.b = k;\n      n.c = l;\n      4 === d.vertexColors.length && (m.vertexColors[0] = d.vertexColors[0].clone(), m.vertexColors[1] = d.vertexColors[1].clone(), m.vertexColors[2] = d.vertexColors[3].clone(), n.vertexColors[0] = d.vertexColors[1].clone(), n.vertexColors[1] = d.vertexColors[2].clone(), n.vertexColors[2] = d.vertexColors[3].clone());\n      f.push(m, n);\n      d = 0;\n      for (e = a.faceVertexUvs.length; d < e; d++) a.faceVertexUvs[d].length && (m = a.faceVertexUvs[d][b], i = m[1], k = m[2], l = m[3], m = [m[0].clone(), i.clone(), l.clone()], i = [i.clone(), k.clone(), l.clone()], h[d].push(m, i));\n      d = 0;\n      for (e = a.faceUvs.length; d < e; d++) a.faceUvs[d].length && (i = a.faceUvs[d][b], g[d].push(i, i));\n    } else {\n      f.push(d);\n      d = 0;\n      for (e = a.faceUvs.length; d < e; d++) g[d].push(a.faceUvs[d][b]);\n      d = 0;\n      for (e = a.faceVertexUvs.length; d < e; d++) h[d].push(a.faceVertexUvs[d][b]);\n    }\n    a.faces = f;\n    a.faceUvs = g;\n    a.faceVertexUvs = h;\n    a.computeCentroids();\n    a.computeFaceNormals();\n    a.computeVertexNormals();\n    a.hasTangents && a.computeTangents();\n  },\n  setMaterialIndex: function setMaterialIndex(a, b, c, d) {\n    a = a.faces;\n    d = d || a.length - 1;\n    for (c = c || 0; c <= d; c++) a[c].materialIndex = b;\n  }\n};\nTHREE.GeometryUtils.random = THREE.Math.random16;\nTHREE.GeometryUtils.__v1 = new THREE.Vector3();\nTHREE.GeometryUtils.__v2 = new THREE.Vector3();\nTHREE.ImageUtils = {\n  crossOrigin: \"anonymous\",\n  loadTexture: function loadTexture(a, b, c, d) {\n    var e = new Image(),\n      f = new THREE.Texture(e, b),\n      b = new THREE.ImageLoader();\n    b.addEventListener(\"load\", function (a) {\n      f.image = a.content;\n      f.needsUpdate = !0;\n      c && c(f);\n    });\n    b.addEventListener(\"error\", function (a) {\n      d && d(a.message);\n    });\n    b.crossOrigin = this.crossOrigin;\n    b.load(a, e);\n    f.sourceFile = a;\n    return f;\n  },\n  loadCompressedTexture: function loadCompressedTexture(a, b, c, d) {\n    var e = new THREE.CompressedTexture();\n    e.mapping = b;\n    var f = new XMLHttpRequest();\n    f.onload = function () {\n      var a = THREE.ImageUtils.parseDDS(f.response, !0);\n      e.format = a.format;\n      e.mipmaps = a.mipmaps;\n      e.image.width = a.width;\n      e.image.height = a.height;\n      e.generateMipmaps = !1;\n      e.needsUpdate = !0;\n      c && c(e);\n    };\n    f.onerror = d;\n    f.open(\"GET\", a, !0);\n    f.responseType = \"arraybuffer\";\n    f.send(null);\n    return e;\n  },\n  loadTextureCube: function loadTextureCube(a, b, c, d) {\n    var e = [];\n    e.loadCount = 0;\n    var f = new THREE.Texture();\n    f.image = e;\n    void 0 !== b && (f.mapping = b);\n    f.flipY = !1;\n    for (var b = 0, g = a.length; b < g; ++b) {\n      var h = new Image();\n      e[b] = h;\n      h.onload = function () {\n        e.loadCount += 1;\n        6 === e.loadCount && (f.needsUpdate = !0, c && c(f));\n      };\n      h.onerror = d;\n      h.crossOrigin = this.crossOrigin;\n      h.src = a[b];\n    }\n    return f;\n  },\n  loadCompressedTextureCube: function loadCompressedTextureCube(a, b, c, d) {\n    var e = [];\n    e.loadCount = 0;\n    var f = new THREE.CompressedTexture();\n    f.image = e;\n    void 0 !== b && (f.mapping = b);\n    f.flipY = !1;\n    f.generateMipmaps = !1;\n    b = function b(a, _b) {\n      return function () {\n        var d = THREE.ImageUtils.parseDDS(a.response, !0);\n        _b.format = d.format;\n        _b.mipmaps = d.mipmaps;\n        _b.width = d.width;\n        _b.height = d.height;\n        e.loadCount += 1;\n        6 === e.loadCount && (f.format = d.format, f.needsUpdate = !0, c && c(f));\n      };\n    };\n    if (a instanceof Array) for (var g = 0, h = a.length; g < h; ++g) {\n      var i = {};\n      e[g] = i;\n      var k = new XMLHttpRequest();\n      k.onload = b(k, i);\n      k.onerror = d;\n      i = a[g];\n      k.open(\"GET\", i, !0);\n      k.responseType = \"arraybuffer\";\n      k.send(null);\n    } else k = new XMLHttpRequest(), k.onload = function () {\n      var a = THREE.ImageUtils.parseDDS(k.response, !0);\n      if (a.isCubemap) {\n        for (var b = a.mipmaps.length / a.mipmapCount, d = 0; d < b; d++) {\n          e[d] = {\n            mipmaps: []\n          };\n          for (var g = 0; g < a.mipmapCount; g++) e[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + g]), e[d].format = a.format, e[d].width = a.width, e[d].height = a.height;\n        }\n        f.format = a.format;\n        f.needsUpdate = !0;\n        c && c(f);\n      }\n    }, k.onerror = d, k.open(\"GET\", a, !0), k.responseType = \"arraybuffer\", k.send(null);\n    return f;\n  },\n  parseDDS: function parseDDS(a, b) {\n    function c(a) {\n      return a.charCodeAt(0) + (a.charCodeAt(1) << 8) + (a.charCodeAt(2) << 16) + (a.charCodeAt(3) << 24);\n    }\n    var d = {\n        mipmaps: [],\n        width: 0,\n        height: 0,\n        format: null,\n        mipmapCount: 1\n      },\n      e = c(\"DXT1\"),\n      f = c(\"DXT3\"),\n      g = c(\"DXT5\"),\n      h = new Int32Array(a, 0, 31);\n    if (542327876 !== h[0]) return console.error(\"ImageUtils.parseDDS(): Invalid magic number in DDS header\"), d;\n    if (!h[20] & 4) return console.error(\"ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code\"), d;\n    var i = h[21];\n    switch (i) {\n      case e:\n        e = 8;\n        d.format = THREE.RGB_S3TC_DXT1_Format;\n        break;\n      case f:\n        e = 16;\n        d.format = THREE.RGBA_S3TC_DXT3_Format;\n        break;\n      case g:\n        e = 16;\n        d.format = THREE.RGBA_S3TC_DXT5_Format;\n        break;\n      default:\n        return console.error(\"ImageUtils.parseDDS(): Unsupported FourCC code: \", String.fromCharCode(i & 255, i >> 8 & 255, i >> 16 & 255, i >> 24 & 255)), d;\n    }\n    d.mipmapCount = 1;\n    h[2] & 131072 && !1 !== b && (d.mipmapCount = Math.max(1, h[7]));\n    d.isCubemap = h[28] & 512 ? !0 : !1;\n    d.width = h[4];\n    d.height = h[3];\n    for (var h = h[1] + 4, f = d.width, g = d.height, i = d.isCubemap ? 6 : 1, k = 0; k < i; k++) {\n      for (var l = 0; l < d.mipmapCount; l++) {\n        var m = Math.max(4, f) / 4 * Math.max(4, g) / 4 * e,\n          n = {\n            data: new Uint8Array(a, h, m),\n            width: f,\n            height: g\n          };\n        d.mipmaps.push(n);\n        h += m;\n        f = Math.max(0.5 * f, 1);\n        g = Math.max(0.5 * g, 1);\n      }\n      f = d.width;\n      g = d.height;\n    }\n    return d;\n  },\n  getNormalMap: function getNormalMap(a, b) {\n    var c = function c(a) {\n        var b = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);\n        return [a[0] / b, a[1] / b, a[2] / b];\n      },\n      b = b | 1,\n      d = a.width,\n      e = a.height,\n      f = document.createElement(\"canvas\");\n    f.width = d;\n    f.height = e;\n    var g = f.getContext(\"2d\");\n    g.drawImage(a, 0, 0);\n    for (var h = g.getImageData(0, 0, d, e).data, i = g.createImageData(d, e), k = i.data, l = 0; l < d; l++) for (var m = 0; m < e; m++) {\n      var n = 0 > m - 1 ? 0 : m - 1,\n        s = m + 1 > e - 1 ? e - 1 : m + 1,\n        r = 0 > l - 1 ? 0 : l - 1,\n        p = l + 1 > d - 1 ? d - 1 : l + 1,\n        q = [],\n        y = [0, 0, h[4 * (m * d + l)] / 255 * b];\n      q.push([-1, 0, h[4 * (m * d + r)] / 255 * b]);\n      q.push([-1, -1, h[4 * (n * d + r)] / 255 * b]);\n      q.push([0, -1, h[4 * (n * d + l)] / 255 * b]);\n      q.push([1, -1, h[4 * (n * d + p)] / 255 * b]);\n      q.push([1, 0, h[4 * (m * d + p)] / 255 * b]);\n      q.push([1, 1, h[4 * (s * d + p)] / 255 * b]);\n      q.push([0, 1, h[4 * (s * d + l)] / 255 * b]);\n      q.push([-1, 1, h[4 * (s * d + r)] / 255 * b]);\n      n = [];\n      r = q.length;\n      for (s = 0; s < r; s++) {\n        var p = q[s],\n          v = q[(s + 1) % r],\n          p = [p[0] - y[0], p[1] - y[1], p[2] - y[2]],\n          v = [v[0] - y[0], v[1] - y[1], v[2] - y[2]];\n        n.push(c([p[1] * v[2] - p[2] * v[1], p[2] * v[0] - p[0] * v[2], p[0] * v[1] - p[1] * v[0]]));\n      }\n      q = [0, 0, 0];\n      for (s = 0; s < n.length; s++) q[0] += n[s][0], q[1] += n[s][1], q[2] += n[s][2];\n      q[0] /= n.length;\n      q[1] /= n.length;\n      q[2] /= n.length;\n      y = 4 * (m * d + l);\n      k[y] = 255 * ((q[0] + 1) / 2) | 0;\n      k[y + 1] = 255 * ((q[1] + 1) / 2) | 0;\n      k[y + 2] = 255 * q[2] | 0;\n      k[y + 3] = 255;\n    }\n    g.putImageData(i, 0, 0);\n    return f;\n  },\n  generateDataTexture: function generateDataTexture(a, b, c) {\n    for (var d = a * b, e = new Uint8Array(3 * d), f = Math.floor(255 * c.r), g = Math.floor(255 * c.g), c = Math.floor(255 * c.b), h = 0; h < d; h++) e[3 * h] = f, e[3 * h + 1] = g, e[3 * h + 2] = c;\n    a = new THREE.DataTexture(e, a, b, THREE.RGBFormat);\n    a.needsUpdate = !0;\n    return a;\n  }\n};\nTHREE.SceneUtils = {\n  createMultiMaterialObject: function createMultiMaterialObject(a, b) {\n    for (var c = new THREE.Object3D(), d = 0, e = b.length; d < e; d++) c.add(new THREE.Mesh(a, b[d]));\n    return c;\n  },\n  detach: function detach(a, b, c) {\n    a.applyMatrix(b.matrixWorld);\n    b.remove(a);\n    c.add(a);\n  },\n  attach: function attach(a, b, c) {\n    var d = new THREE.Matrix4();\n    d.getInverse(c.matrixWorld);\n    a.applyMatrix(d);\n    b.remove(a);\n    c.add(a);\n  }\n};\nTHREE.FontUtils = {\n  faces: {},\n  face: \"helvetiker\",\n  weight: \"normal\",\n  style: \"normal\",\n  size: 150,\n  divisions: 10,\n  getFace: function getFace() {\n    return this.faces[this.face][this.weight][this.style];\n  },\n  loadFace: function loadFace(a) {\n    var b = a.familyName.toLowerCase();\n    this.faces[b] = this.faces[b] || {};\n    this.faces[b][a.cssFontWeight] = this.faces[b][a.cssFontWeight] || {};\n    this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;\n    return this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;\n  },\n  drawText: function drawText(a) {\n    for (var b = this.getFace(), c = this.size / b.resolution, d = 0, e = String(a).split(\"\"), f = e.length, g = [], a = 0; a < f; a++) {\n      var h = new THREE.Path(),\n        h = this.extractGlyphPoints(e[a], b, c, d, h),\n        d = d + h.offset;\n      g.push(h.path);\n    }\n    return {\n      paths: g,\n      offset: d / 2\n    };\n  },\n  extractGlyphPoints: function extractGlyphPoints(a, b, c, d, e) {\n    var f = [],\n      g,\n      h,\n      i,\n      k,\n      l,\n      m,\n      n,\n      s,\n      r,\n      p,\n      q,\n      y = b.glyphs[a] || b.glyphs[\"?\"];\n    if (y) {\n      if (y.o) {\n        b = y._cachedOutline || (y._cachedOutline = y.o.split(\" \"));\n        k = b.length;\n        for (a = 0; a < k;) switch (i = b[a++], i) {\n          case \"m\":\n            i = b[a++] * c + d;\n            l = b[a++] * c;\n            e.moveTo(i, l);\n            break;\n          case \"l\":\n            i = b[a++] * c + d;\n            l = b[a++] * c;\n            e.lineTo(i, l);\n            break;\n          case \"q\":\n            i = b[a++] * c + d;\n            l = b[a++] * c;\n            s = b[a++] * c + d;\n            r = b[a++] * c;\n            e.quadraticCurveTo(s, r, i, l);\n            if (g = f[f.length - 1]) {\n              m = g.x;\n              n = g.y;\n              g = 1;\n              for (h = this.divisions; g <= h; g++) {\n                var v = g / h;\n                THREE.Shape.Utils.b2(v, m, s, i);\n                THREE.Shape.Utils.b2(v, n, r, l);\n              }\n            }\n            break;\n          case \"b\":\n            if (i = b[a++] * c + d, l = b[a++] * c, s = b[a++] * c + d, r = b[a++] * -c, p = b[a++] * c + d, q = b[a++] * -c, e.bezierCurveTo(i, l, s, r, p, q), g = f[f.length - 1]) {\n              m = g.x;\n              n = g.y;\n              g = 1;\n              for (h = this.divisions; g <= h; g++) v = g / h, THREE.Shape.Utils.b3(v, m, s, p, i), THREE.Shape.Utils.b3(v, n, r, q, l);\n            }\n        }\n      }\n      return {\n        offset: y.ha * c,\n        path: e\n      };\n    }\n  }\n};\nTHREE.FontUtils.generateShapes = function (a, b) {\n  var b = b || {},\n    c = void 0 !== b.curveSegments ? b.curveSegments : 4,\n    d = void 0 !== b.font ? b.font : \"helvetiker\",\n    e = void 0 !== b.weight ? b.weight : \"normal\",\n    f = void 0 !== b.style ? b.style : \"normal\";\n  THREE.FontUtils.size = void 0 !== b.size ? b.size : 100;\n  THREE.FontUtils.divisions = c;\n  THREE.FontUtils.face = d;\n  THREE.FontUtils.weight = e;\n  THREE.FontUtils.style = f;\n  c = THREE.FontUtils.drawText(a).paths;\n  d = [];\n  e = 0;\n  for (f = c.length; e < f; e++) Array.prototype.push.apply(d, c[e].toShapes());\n  return d;\n};\n(function (a) {\n  var b = function b(a) {\n    for (var b = a.length, e = 0, f = b - 1, g = 0; g < b; f = g++) e += a[f].x * a[g].y - a[g].x * a[f].y;\n    return 0.5 * e;\n  };\n  a.Triangulate = function (a, d) {\n    var e = a.length;\n    if (3 > e) return null;\n    var f = [],\n      g = [],\n      h = [],\n      i,\n      k,\n      l;\n    if (0 < b(a)) for (k = 0; k < e; k++) g[k] = k;else for (k = 0; k < e; k++) g[k] = e - 1 - k;\n    var m = 2 * e;\n    for (k = e - 1; 2 < e;) {\n      if (0 >= m--) {\n        console.log(\"Warning, unable to triangulate polygon!\");\n        break;\n      }\n      i = k;\n      e <= i && (i = 0);\n      k = i + 1;\n      e <= k && (k = 0);\n      l = k + 1;\n      e <= l && (l = 0);\n      var n;\n      a: {\n        var s = n = void 0,\n          r = void 0,\n          p = void 0,\n          q = void 0,\n          y = void 0,\n          v = void 0,\n          z = void 0,\n          t = void 0,\n          s = a[g[i]].x,\n          r = a[g[i]].y,\n          p = a[g[k]].x,\n          q = a[g[k]].y,\n          y = a[g[l]].x,\n          v = a[g[l]].y;\n        if (1E-10 > (p - s) * (v - r) - (q - r) * (y - s)) n = !1;else {\n          var A = void 0,\n            I = void 0,\n            C = void 0,\n            x = void 0,\n            G = void 0,\n            J = void 0,\n            E = void 0,\n            H = void 0,\n            B = void 0,\n            W = void 0,\n            B = H = E = t = z = void 0,\n            A = y - p,\n            I = v - q,\n            C = s - y,\n            x = r - v,\n            G = p - s,\n            J = q - r;\n          for (n = 0; n < e; n++) if (!(n === i || n === k || n === l)) if (z = a[g[n]].x, t = a[g[n]].y, E = z - s, H = t - r, B = z - p, W = t - q, z -= y, t -= v, B = A * W - I * B, E = G * H - J * E, H = C * t - x * z, 0 <= B && 0 <= H && 0 <= E) {\n            n = !1;\n            break a;\n          }\n          n = !0;\n        }\n      }\n      if (n) {\n        f.push([a[g[i]], a[g[k]], a[g[l]]]);\n        h.push([g[i], g[k], g[l]]);\n        i = k;\n        for (l = k + 1; l < e; i++, l++) g[i] = g[l];\n        e--;\n        m = 2 * e;\n      }\n    }\n    return d ? h : f;\n  };\n  a.Triangulate.area = b;\n  return a;\n})(THREE.FontUtils);\nself._typeface_js = {\n  faces: THREE.FontUtils.faces,\n  loadFace: THREE.FontUtils.loadFace\n};\nTHREE.Curve = function () {};\nTHREE.Curve.prototype.getPoint = function () {\n  console.log(\"Warning, getPoint() not implemented!\");\n  return null;\n};\nTHREE.Curve.prototype.getPointAt = function (a) {\n  a = this.getUtoTmapping(a);\n  return this.getPoint(a);\n};\nTHREE.Curve.prototype.getPoints = function (a) {\n  a || (a = 5);\n  var b,\n    c = [];\n  for (b = 0; b <= a; b++) c.push(this.getPoint(b / a));\n  return c;\n};\nTHREE.Curve.prototype.getSpacedPoints = function (a) {\n  a || (a = 5);\n  var b,\n    c = [];\n  for (b = 0; b <= a; b++) c.push(this.getPointAt(b / a));\n  return c;\n};\nTHREE.Curve.prototype.getLength = function () {\n  var a = this.getLengths();\n  return a[a.length - 1];\n};\nTHREE.Curve.prototype.getLengths = function (a) {\n  a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);\n  if (this.cacheArcLengths && this.cacheArcLengths.length == a + 1 && !this.needsUpdate) return this.cacheArcLengths;\n  this.needsUpdate = !1;\n  var b = [],\n    c,\n    d = this.getPoint(0),\n    e,\n    f = 0;\n  b.push(0);\n  for (e = 1; e <= a; e++) c = this.getPoint(e / a), f += c.distanceTo(d), b.push(f), d = c;\n  return this.cacheArcLengths = b;\n};\nTHREE.Curve.prototype.updateArcLengths = function () {\n  this.needsUpdate = !0;\n  this.getLengths();\n};\nTHREE.Curve.prototype.getUtoTmapping = function (a, b) {\n  var c = this.getLengths(),\n    d = 0,\n    e = c.length,\n    f;\n  f = b ? b : a * c[e - 1];\n  for (var g = 0, h = e - 1, i; g <= h;) if (d = Math.floor(g + (h - g) / 2), i = c[d] - f, 0 > i) g = d + 1;else if (0 < i) h = d - 1;else {\n    h = d;\n    break;\n  }\n  d = h;\n  if (c[d] == f) return d / (e - 1);\n  g = c[d];\n  return c = (d + (f - g) / (c[d + 1] - g)) / (e - 1);\n};\nTHREE.Curve.prototype.getTangent = function (a) {\n  var b = a - 1E-4,\n    a = a + 1E-4;\n  0 > b && (b = 0);\n  1 < a && (a = 1);\n  b = this.getPoint(b);\n  return this.getPoint(a).clone().sub(b).normalize();\n};\nTHREE.Curve.prototype.getTangentAt = function (a) {\n  a = this.getUtoTmapping(a);\n  return this.getTangent(a);\n};\nTHREE.LineCurve = function (a, b) {\n  this.v1 = a;\n  this.v2 = b;\n};\nTHREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.LineCurve.prototype.getPoint = function (a) {\n  var b = this.v2.clone().sub(this.v1);\n  b.multiplyScalar(a).add(this.v1);\n  return b;\n};\nTHREE.LineCurve.prototype.getPointAt = function (a) {\n  return this.getPoint(a);\n};\nTHREE.LineCurve.prototype.getTangent = function () {\n  return this.v2.clone().sub(this.v1).normalize();\n};\nTHREE.QuadraticBezierCurve = function (a, b, c) {\n  this.v0 = a;\n  this.v1 = b;\n  this.v2 = c;\n};\nTHREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.QuadraticBezierCurve.prototype.getPoint = function (a) {\n  var b;\n  b = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);\n  a = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);\n  return new THREE.Vector2(b, a);\n};\nTHREE.QuadraticBezierCurve.prototype.getTangent = function (a) {\n  var b;\n  b = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.x, this.v1.x, this.v2.x);\n  a = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.y, this.v1.y, this.v2.y);\n  b = new THREE.Vector2(b, a);\n  b.normalize();\n  return b;\n};\nTHREE.CubicBezierCurve = function (a, b, c, d) {\n  this.v0 = a;\n  this.v1 = b;\n  this.v2 = c;\n  this.v3 = d;\n};\nTHREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.CubicBezierCurve.prototype.getPoint = function (a) {\n  var b;\n  b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);\n  a = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);\n  return new THREE.Vector2(b, a);\n};\nTHREE.CubicBezierCurve.prototype.getTangent = function (a) {\n  var b;\n  b = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);\n  a = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);\n  b = new THREE.Vector2(b, a);\n  b.normalize();\n  return b;\n};\nTHREE.SplineCurve = function (a) {\n  this.points = void 0 == a ? [] : a;\n};\nTHREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.SplineCurve.prototype.getPoint = function (a) {\n  var b = new THREE.Vector2(),\n    c = [],\n    d = this.points,\n    e;\n  e = (d.length - 1) * a;\n  a = Math.floor(e);\n  e -= a;\n  c[0] = 0 == a ? a : a - 1;\n  c[1] = a;\n  c[2] = a > d.length - 2 ? d.length - 1 : a + 1;\n  c[3] = a > d.length - 3 ? d.length - 1 : a + 2;\n  b.x = THREE.Curve.Utils.interpolate(d[c[0]].x, d[c[1]].x, d[c[2]].x, d[c[3]].x, e);\n  b.y = THREE.Curve.Utils.interpolate(d[c[0]].y, d[c[1]].y, d[c[2]].y, d[c[3]].y, e);\n  return b;\n};\nTHREE.EllipseCurve = function (a, b, c, d, e, f, g) {\n  this.aX = a;\n  this.aY = b;\n  this.xRadius = c;\n  this.yRadius = d;\n  this.aStartAngle = e;\n  this.aEndAngle = f;\n  this.aClockwise = g;\n};\nTHREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);\nTHREE.EllipseCurve.prototype.getPoint = function (a) {\n  var b = this.aEndAngle - this.aStartAngle;\n  this.aClockwise || (a = 1 - a);\n  b = this.aStartAngle + a * b;\n  a = this.aX + this.xRadius * Math.cos(b);\n  b = this.aY + this.yRadius * Math.sin(b);\n  return new THREE.Vector2(a, b);\n};\nTHREE.ArcCurve = function (a, b, c, d, e, f) {\n  THREE.EllipseCurve.call(this, a, b, c, c, d, e, f);\n};\nTHREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);\nTHREE.Curve.Utils = {\n  tangentQuadraticBezier: function tangentQuadraticBezier(a, b, c, d) {\n    return 2 * (1 - a) * (c - b) + 2 * a * (d - c);\n  },\n  tangentCubicBezier: function tangentCubicBezier(a, b, c, d, e) {\n    return -3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e;\n  },\n  tangentSpline: function tangentSpline(a) {\n    return 6 * a * a - 6 * a + (3 * a * a - 4 * a + 1) + (-6 * a * a + 6 * a) + (3 * a * a - 2 * a);\n  },\n  interpolate: function interpolate(a, b, c, d, e) {\n    var a = 0.5 * (c - a),\n      d = 0.5 * (d - b),\n      f = e * e;\n    return (2 * b - 2 * c + a + d) * e * f + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b;\n  }\n};\nTHREE.Curve.create = function (a, b) {\n  a.prototype = Object.create(THREE.Curve.prototype);\n  a.prototype.getPoint = b;\n  return a;\n};\nTHREE.LineCurve3 = THREE.Curve.create(function (a, b) {\n  this.v1 = a;\n  this.v2 = b;\n}, function (a) {\n  var b = new THREE.Vector3();\n  b.subVectors(this.v2, this.v1);\n  b.multiplyScalar(a);\n  b.add(this.v1);\n  return b;\n});\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(function (a, b, c) {\n  this.v0 = a;\n  this.v1 = b;\n  this.v2 = c;\n}, function (a) {\n  var b, c;\n  b = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);\n  c = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);\n  a = THREE.Shape.Utils.b2(a, this.v0.z, this.v1.z, this.v2.z);\n  return new THREE.Vector3(b, c, a);\n});\nTHREE.CubicBezierCurve3 = THREE.Curve.create(function (a, b, c, d) {\n  this.v0 = a;\n  this.v1 = b;\n  this.v2 = c;\n  this.v3 = d;\n}, function (a) {\n  var b, c;\n  b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);\n  c = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);\n  a = THREE.Shape.Utils.b3(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z);\n  return new THREE.Vector3(b, c, a);\n});\nTHREE.SplineCurve3 = THREE.Curve.create(function (a) {\n  this.points = void 0 == a ? [] : a;\n}, function (a) {\n  var b = new THREE.Vector3(),\n    c = [],\n    d = this.points,\n    e,\n    a = (d.length - 1) * a;\n  e = Math.floor(a);\n  a -= e;\n  c[0] = 0 == e ? e : e - 1;\n  c[1] = e;\n  c[2] = e > d.length - 2 ? d.length - 1 : e + 1;\n  c[3] = e > d.length - 3 ? d.length - 1 : e + 2;\n  e = d[c[0]];\n  var f = d[c[1]],\n    g = d[c[2]],\n    c = d[c[3]];\n  b.x = THREE.Curve.Utils.interpolate(e.x, f.x, g.x, c.x, a);\n  b.y = THREE.Curve.Utils.interpolate(e.y, f.y, g.y, c.y, a);\n  b.z = THREE.Curve.Utils.interpolate(e.z, f.z, g.z, c.z, a);\n  return b;\n});\nTHREE.ClosedSplineCurve3 = THREE.Curve.create(function (a) {\n  this.points = void 0 == a ? [] : a;\n}, function (a) {\n  var b = new THREE.Vector3(),\n    c = [],\n    d = this.points,\n    e;\n  e = (d.length - 0) * a;\n  a = Math.floor(e);\n  e -= a;\n  a += 0 < a ? 0 : (Math.floor(Math.abs(a) / d.length) + 1) * d.length;\n  c[0] = (a - 1) % d.length;\n  c[1] = a % d.length;\n  c[2] = (a + 1) % d.length;\n  c[3] = (a + 2) % d.length;\n  b.x = THREE.Curve.Utils.interpolate(d[c[0]].x, d[c[1]].x, d[c[2]].x, d[c[3]].x, e);\n  b.y = THREE.Curve.Utils.interpolate(d[c[0]].y, d[c[1]].y, d[c[2]].y, d[c[3]].y, e);\n  b.z = THREE.Curve.Utils.interpolate(d[c[0]].z, d[c[1]].z, d[c[2]].z, d[c[3]].z, e);\n  return b;\n});\nTHREE.CurvePath = function () {\n  this.curves = [];\n  this.bends = [];\n  this.autoClose = !1;\n};\nTHREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);\nTHREE.CurvePath.prototype.add = function (a) {\n  this.curves.push(a);\n};\nTHREE.CurvePath.prototype.checkConnection = function () {};\nTHREE.CurvePath.prototype.closePath = function () {\n  var a = this.curves[0].getPoint(0),\n    b = this.curves[this.curves.length - 1].getPoint(1);\n  a.equals(b) || this.curves.push(new THREE.LineCurve(b, a));\n};\nTHREE.CurvePath.prototype.getPoint = function (a) {\n  for (var b = a * this.getLength(), c = this.getCurveLengths(), a = 0; a < c.length;) {\n    if (c[a] >= b) return b = c[a] - b, a = this.curves[a], b = 1 - b / a.getLength(), a.getPointAt(b);\n    a++;\n  }\n  return null;\n};\nTHREE.CurvePath.prototype.getLength = function () {\n  var a = this.getCurveLengths();\n  return a[a.length - 1];\n};\nTHREE.CurvePath.prototype.getCurveLengths = function () {\n  if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;\n  var a = [],\n    b = 0,\n    c,\n    d = this.curves.length;\n  for (c = 0; c < d; c++) b += this.curves[c].getLength(), a.push(b);\n  return this.cacheLengths = a;\n};\nTHREE.CurvePath.prototype.getBoundingBox = function () {\n  var a = this.getPoints(),\n    b,\n    c,\n    d,\n    e,\n    f,\n    g;\n  b = c = Number.NEGATIVE_INFINITY;\n  e = f = Number.POSITIVE_INFINITY;\n  var h,\n    i,\n    k,\n    l,\n    m = a[0] instanceof THREE.Vector3;\n  l = m ? new THREE.Vector3() : new THREE.Vector2();\n  i = 0;\n  for (k = a.length; i < k; i++) h = a[i], h.x > b ? b = h.x : h.x < e && (e = h.x), h.y > c ? c = h.y : h.y < f && (f = h.y), m && (h.z > d ? d = h.z : h.z < g && (g = h.z)), l.add(h);\n  a = {\n    minX: e,\n    minY: f,\n    maxX: b,\n    maxY: c,\n    centroid: l.divideScalar(k)\n  };\n  m && (a.maxZ = d, a.minZ = g);\n  return a;\n};\nTHREE.CurvePath.prototype.createPointsGeometry = function (a) {\n  a = this.getPoints(a, !0);\n  return this.createGeometry(a);\n};\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function (a) {\n  a = this.getSpacedPoints(a, !0);\n  return this.createGeometry(a);\n};\nTHREE.CurvePath.prototype.createGeometry = function (a) {\n  for (var b = new THREE.Geometry(), c = 0; c < a.length; c++) b.vertices.push(new THREE.Vector3(a[c].x, a[c].y, a[c].z || 0));\n  return b;\n};\nTHREE.CurvePath.prototype.addWrapPath = function (a) {\n  this.bends.push(a);\n};\nTHREE.CurvePath.prototype.getTransformedPoints = function (a, b) {\n  var c = this.getPoints(a),\n    d,\n    e;\n  b || (b = this.bends);\n  d = 0;\n  for (e = b.length; d < e; d++) c = this.getWrapPoints(c, b[d]);\n  return c;\n};\nTHREE.CurvePath.prototype.getTransformedSpacedPoints = function (a, b) {\n  var c = this.getSpacedPoints(a),\n    d,\n    e;\n  b || (b = this.bends);\n  d = 0;\n  for (e = b.length; d < e; d++) c = this.getWrapPoints(c, b[d]);\n  return c;\n};\nTHREE.CurvePath.prototype.getWrapPoints = function (a, b) {\n  var c = this.getBoundingBox(),\n    d,\n    e,\n    f,\n    g,\n    h,\n    i;\n  d = 0;\n  for (e = a.length; d < e; d++) f = a[d], g = f.x, h = f.y, i = g / c.maxX, i = b.getUtoTmapping(i, g), g = b.getPoint(i), h = b.getNormalVector(i).multiplyScalar(h), f.x = g.x + h.x, f.y = g.y + h.y;\n  return a;\n};\nTHREE.Gyroscope = function () {\n  THREE.Object3D.call(this);\n};\nTHREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Gyroscope.prototype.updateMatrixWorld = function (a) {\n  this.matrixAutoUpdate && this.updateMatrix();\n  if (this.matrixWorldNeedsUpdate || a) this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(this.translationWorld, this.rotationWorld, this.scaleWorld), this.matrix.decompose(this.translationObject, this.rotationObject, this.scaleObject), this.matrixWorld.compose(this.translationWorld, this.rotationObject, this.scaleWorld)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;\n  for (var b = 0, c = this.children.length; b < c; b++) this.children[b].updateMatrixWorld(a);\n};\nTHREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();\nTHREE.Gyroscope.prototype.translationObject = new THREE.Vector3();\nTHREE.Gyroscope.prototype.rotationWorld = new THREE.Quaternion();\nTHREE.Gyroscope.prototype.rotationObject = new THREE.Quaternion();\nTHREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();\nTHREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();\nTHREE.Path = function (a) {\n  THREE.CurvePath.call(this);\n  this.actions = [];\n  a && this.fromPoints(a);\n};\nTHREE.Path.prototype = Object.create(THREE.CurvePath.prototype);\nTHREE.PathActions = {\n  MOVE_TO: \"moveTo\",\n  LINE_TO: \"lineTo\",\n  QUADRATIC_CURVE_TO: \"quadraticCurveTo\",\n  BEZIER_CURVE_TO: \"bezierCurveTo\",\n  CSPLINE_THRU: \"splineThru\",\n  ARC: \"arc\",\n  ELLIPSE: \"ellipse\"\n};\nTHREE.Path.prototype.fromPoints = function (a) {\n  this.moveTo(a[0].x, a[0].y);\n  for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y);\n};\nTHREE.Path.prototype.moveTo = function (a, b) {\n  var c = Array.prototype.slice.call(arguments);\n  this.actions.push({\n    action: THREE.PathActions.MOVE_TO,\n    args: c\n  });\n};\nTHREE.Path.prototype.lineTo = function (a, b) {\n  var c = Array.prototype.slice.call(arguments),\n    d = this.actions[this.actions.length - 1].args,\n    d = new THREE.LineCurve(new THREE.Vector2(d[d.length - 2], d[d.length - 1]), new THREE.Vector2(a, b));\n  this.curves.push(d);\n  this.actions.push({\n    action: THREE.PathActions.LINE_TO,\n    args: c\n  });\n};\nTHREE.Path.prototype.quadraticCurveTo = function (a, b, c, d) {\n  var e = Array.prototype.slice.call(arguments),\n    f = this.actions[this.actions.length - 1].args,\n    f = new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length - 2], f[f.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d));\n  this.curves.push(f);\n  this.actions.push({\n    action: THREE.PathActions.QUADRATIC_CURVE_TO,\n    args: e\n  });\n};\nTHREE.Path.prototype.bezierCurveTo = function (a, b, c, d, e, f) {\n  var g = Array.prototype.slice.call(arguments),\n    h = this.actions[this.actions.length - 1].args,\n    h = new THREE.CubicBezierCurve(new THREE.Vector2(h[h.length - 2], h[h.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d), new THREE.Vector2(e, f));\n  this.curves.push(h);\n  this.actions.push({\n    action: THREE.PathActions.BEZIER_CURVE_TO,\n    args: g\n  });\n};\nTHREE.Path.prototype.splineThru = function (a) {\n  var b = Array.prototype.slice.call(arguments),\n    c = this.actions[this.actions.length - 1].args,\n    c = [new THREE.Vector2(c[c.length - 2], c[c.length - 1])];\n  Array.prototype.push.apply(c, a);\n  c = new THREE.SplineCurve(c);\n  this.curves.push(c);\n  this.actions.push({\n    action: THREE.PathActions.CSPLINE_THRU,\n    args: b\n  });\n};\nTHREE.Path.prototype.arc = function (a, b, c, d, e, f) {\n  var g = this.actions[this.actions.length - 1].args;\n  this.absarc(a + g[g.length - 2], b + g[g.length - 1], c, d, e, f);\n};\nTHREE.Path.prototype.absarc = function (a, b, c, d, e, f) {\n  this.absellipse(a, b, c, c, d, e, f);\n};\nTHREE.Path.prototype.ellipse = function (a, b, c, d, e, f, g) {\n  var h = this.actions[this.actions.length - 1].args;\n  this.absellipse(a + h[h.length - 2], b + h[h.length - 1], c, d, e, f, g);\n};\nTHREE.Path.prototype.absellipse = function (a, b, c, d, e, f, g) {\n  var h = Array.prototype.slice.call(arguments),\n    i = new THREE.EllipseCurve(a, b, c, d, e, f, g);\n  this.curves.push(i);\n  i = i.getPoint(g ? 1 : 0);\n  h.push(i.x);\n  h.push(i.y);\n  this.actions.push({\n    action: THREE.PathActions.ELLIPSE,\n    args: h\n  });\n};\nTHREE.Path.prototype.getSpacedPoints = function (a) {\n  a || (a = 40);\n  for (var b = [], c = 0; c < a; c++) b.push(this.getPoint(c / a));\n  return b;\n};\nTHREE.Path.prototype.getPoints = function (a, b) {\n  if (this.useSpacedPoints) return console.log(\"tata\"), this.getSpacedPoints(a, b);\n  var a = a || 12,\n    c = [],\n    d,\n    e,\n    f,\n    g,\n    h,\n    i,\n    k,\n    l,\n    m,\n    n,\n    s,\n    r,\n    p;\n  d = 0;\n  for (e = this.actions.length; d < e; d++) switch (f = this.actions[d], g = f.action, f = f.args, g) {\n    case THREE.PathActions.MOVE_TO:\n      c.push(new THREE.Vector2(f[0], f[1]));\n      break;\n    case THREE.PathActions.LINE_TO:\n      c.push(new THREE.Vector2(f[0], f[1]));\n      break;\n    case THREE.PathActions.QUADRATIC_CURVE_TO:\n      h = f[2];\n      i = f[3];\n      m = f[0];\n      n = f[1];\n      0 < c.length ? (g = c[c.length - 1], s = g.x, r = g.y) : (g = this.actions[d - 1].args, s = g[g.length - 2], r = g[g.length - 1]);\n      for (f = 1; f <= a; f++) p = f / a, g = THREE.Shape.Utils.b2(p, s, m, h), p = THREE.Shape.Utils.b2(p, r, n, i), c.push(new THREE.Vector2(g, p));\n      break;\n    case THREE.PathActions.BEZIER_CURVE_TO:\n      h = f[4];\n      i = f[5];\n      m = f[0];\n      n = f[1];\n      k = f[2];\n      l = f[3];\n      0 < c.length ? (g = c[c.length - 1], s = g.x, r = g.y) : (g = this.actions[d - 1].args, s = g[g.length - 2], r = g[g.length - 1]);\n      for (f = 1; f <= a; f++) p = f / a, g = THREE.Shape.Utils.b3(p, s, m, k, h), p = THREE.Shape.Utils.b3(p, r, n, l, i), c.push(new THREE.Vector2(g, p));\n      break;\n    case THREE.PathActions.CSPLINE_THRU:\n      g = this.actions[d - 1].args;\n      p = [new THREE.Vector2(g[g.length - 2], g[g.length - 1])];\n      g = a * f[0].length;\n      p = p.concat(f[0]);\n      p = new THREE.SplineCurve(p);\n      for (f = 1; f <= g; f++) c.push(p.getPointAt(f / g));\n      break;\n    case THREE.PathActions.ARC:\n      h = f[0];\n      i = f[1];\n      n = f[2];\n      k = f[3];\n      g = f[4];\n      m = !!f[5];\n      s = g - k;\n      r = 2 * a;\n      for (f = 1; f <= r; f++) p = f / r, m || (p = 1 - p), p = k + p * s, g = h + n * Math.cos(p), p = i + n * Math.sin(p), c.push(new THREE.Vector2(g, p));\n      break;\n    case THREE.PathActions.ELLIPSE:\n      h = f[0];\n      i = f[1];\n      n = f[2];\n      l = f[3];\n      k = f[4];\n      g = f[5];\n      m = !!f[6];\n      s = g - k;\n      r = 2 * a;\n      for (f = 1; f <= r; f++) p = f / r, m || (p = 1 - p), p = k + p * s, g = h + n * Math.cos(p), p = i + l * Math.sin(p), c.push(new THREE.Vector2(g, p));\n  }\n  d = c[c.length - 1];\n  1E-10 > Math.abs(d.x - c[0].x) && 1E-10 > Math.abs(d.y - c[0].y) && c.splice(c.length - 1, 1);\n  b && c.push(c[0]);\n  return c;\n};\nTHREE.Path.prototype.toShapes = function () {\n  var a,\n    b,\n    c,\n    d,\n    e = [],\n    f = new THREE.Path();\n  a = 0;\n  for (b = this.actions.length; a < b; a++) c = this.actions[a], d = c.args, c = c.action, c == THREE.PathActions.MOVE_TO && 0 != f.actions.length && (e.push(f), f = new THREE.Path()), f[c].apply(f, d);\n  0 != f.actions.length && e.push(f);\n  if (0 == e.length) return [];\n  var g;\n  d = [];\n  a = !THREE.Shape.Utils.isClockWise(e[0].getPoints());\n  if (1 == e.length) return f = e[0], g = new THREE.Shape(), g.actions = f.actions, g.curves = f.curves, d.push(g), d;\n  if (a) {\n    g = new THREE.Shape();\n    a = 0;\n    for (b = e.length; a < b; a++) f = e[a], THREE.Shape.Utils.isClockWise(f.getPoints()) ? (g.actions = f.actions, g.curves = f.curves, d.push(g), g = new THREE.Shape()) : g.holes.push(f);\n  } else {\n    a = 0;\n    for (b = e.length; a < b; a++) f = e[a], THREE.Shape.Utils.isClockWise(f.getPoints()) ? (g && d.push(g), g = new THREE.Shape(), g.actions = f.actions, g.curves = f.curves) : g.holes.push(f);\n    d.push(g);\n  }\n  return d;\n};\nTHREE.Shape = function () {\n  THREE.Path.apply(this, arguments);\n  this.holes = [];\n};\nTHREE.Shape.prototype = Object.create(THREE.Path.prototype);\nTHREE.Shape.prototype.extrude = function (a) {\n  return new THREE.ExtrudeGeometry(this, a);\n};\nTHREE.Shape.prototype.makeGeometry = function (a) {\n  return new THREE.ShapeGeometry(this, a);\n};\nTHREE.Shape.prototype.getPointsHoles = function (a) {\n  var b,\n    c = this.holes.length,\n    d = [];\n  for (b = 0; b < c; b++) d[b] = this.holes[b].getTransformedPoints(a, this.bends);\n  return d;\n};\nTHREE.Shape.prototype.getSpacedPointsHoles = function (a) {\n  var b,\n    c = this.holes.length,\n    d = [];\n  for (b = 0; b < c; b++) d[b] = this.holes[b].getTransformedSpacedPoints(a, this.bends);\n  return d;\n};\nTHREE.Shape.prototype.extractAllPoints = function (a) {\n  return {\n    shape: this.getTransformedPoints(a),\n    holes: this.getPointsHoles(a)\n  };\n};\nTHREE.Shape.prototype.extractPoints = function (a) {\n  return this.useSpacedPoints ? this.extractAllSpacedPoints(a) : this.extractAllPoints(a);\n};\nTHREE.Shape.prototype.extractAllSpacedPoints = function (a) {\n  return {\n    shape: this.getTransformedSpacedPoints(a),\n    holes: this.getSpacedPointsHoles(a)\n  };\n};\nTHREE.Shape.Utils = {\n  removeHoles: function removeHoles(a, b) {\n    var c = a.concat(),\n      d = c.concat(),\n      e,\n      f,\n      g,\n      h,\n      i,\n      k,\n      l,\n      m,\n      n,\n      s,\n      r = [];\n    for (i = 0; i < b.length; i++) {\n      k = b[i];\n      Array.prototype.push.apply(d, k);\n      f = Number.POSITIVE_INFINITY;\n      for (e = 0; e < k.length; e++) {\n        n = k[e];\n        s = [];\n        for (m = 0; m < c.length; m++) l = c[m], l = n.distanceToSquared(l), s.push(l), l < f && (f = l, g = e, h = m);\n      }\n      e = 0 <= h - 1 ? h - 1 : c.length - 1;\n      f = 0 <= g - 1 ? g - 1 : k.length - 1;\n      var p = [k[g], c[h], c[e]];\n      m = THREE.FontUtils.Triangulate.area(p);\n      var q = [k[g], k[f], c[h]];\n      n = THREE.FontUtils.Triangulate.area(q);\n      s = h;\n      l = g;\n      h += 1;\n      g += -1;\n      0 > h && (h += c.length);\n      h %= c.length;\n      0 > g && (g += k.length);\n      g %= k.length;\n      e = 0 <= h - 1 ? h - 1 : c.length - 1;\n      f = 0 <= g - 1 ? g - 1 : k.length - 1;\n      p = [k[g], c[h], c[e]];\n      p = THREE.FontUtils.Triangulate.area(p);\n      q = [k[g], k[f], c[h]];\n      q = THREE.FontUtils.Triangulate.area(q);\n      m + n > p + q && (h = s, g = l, 0 > h && (h += c.length), h %= c.length, 0 > g && (g += k.length), g %= k.length, e = 0 <= h - 1 ? h - 1 : c.length - 1, f = 0 <= g - 1 ? g - 1 : k.length - 1);\n      m = c.slice(0, h);\n      n = c.slice(h);\n      s = k.slice(g);\n      l = k.slice(0, g);\n      f = [k[g], k[f], c[h]];\n      r.push([k[g], c[h], c[e]]);\n      r.push(f);\n      c = m.concat(s).concat(l).concat(n);\n    }\n    return {\n      shape: c,\n      isolatedPts: r,\n      allpoints: d\n    };\n  },\n  triangulateShape: function triangulateShape(a, b) {\n    var c = THREE.Shape.Utils.removeHoles(a, b),\n      d = c.allpoints,\n      e = c.isolatedPts,\n      c = THREE.FontUtils.Triangulate(c.shape, !1),\n      f,\n      g,\n      h,\n      i,\n      k = {};\n    f = 0;\n    for (g = d.length; f < g; f++) i = d[f].x + \":\" + d[f].y, void 0 !== k[i] && console.log(\"Duplicate point\", i), k[i] = f;\n    f = 0;\n    for (g = c.length; f < g; f++) {\n      h = c[f];\n      for (d = 0; 3 > d; d++) i = h[d].x + \":\" + h[d].y, i = k[i], void 0 !== i && (h[d] = i);\n    }\n    f = 0;\n    for (g = e.length; f < g; f++) {\n      h = e[f];\n      for (d = 0; 3 > d; d++) i = h[d].x + \":\" + h[d].y, i = k[i], void 0 !== i && (h[d] = i);\n    }\n    return c.concat(e);\n  },\n  isClockWise: function isClockWise(a) {\n    return 0 > THREE.FontUtils.Triangulate.area(a);\n  },\n  b2p0: function b2p0(a, b) {\n    var c = 1 - a;\n    return c * c * b;\n  },\n  b2p1: function b2p1(a, b) {\n    return 2 * (1 - a) * a * b;\n  },\n  b2p2: function b2p2(a, b) {\n    return a * a * b;\n  },\n  b2: function b2(a, b, c, d) {\n    return this.b2p0(a, b) + this.b2p1(a, c) + this.b2p2(a, d);\n  },\n  b3p0: function b3p0(a, b) {\n    var c = 1 - a;\n    return c * c * c * b;\n  },\n  b3p1: function b3p1(a, b) {\n    var c = 1 - a;\n    return 3 * c * c * a * b;\n  },\n  b3p2: function b3p2(a, b) {\n    return 3 * (1 - a) * a * a * b;\n  },\n  b3p3: function b3p3(a, b) {\n    return a * a * a * b;\n  },\n  b3: function b3(a, b, c, d, e) {\n    return this.b3p0(a, b) + this.b3p1(a, c) + this.b3p2(a, d) + this.b3p3(a, e);\n  }\n};\nTHREE.AnimationHandler = function () {\n  var a = [],\n    b = {},\n    c = {\n      update: function update(b) {\n        for (var c = 0; c < a.length; c++) a[c].update(b);\n      },\n      addToUpdate: function addToUpdate(b) {\n        -1 === a.indexOf(b) && a.push(b);\n      },\n      removeFromUpdate: function removeFromUpdate(b) {\n        b = a.indexOf(b);\n        -1 !== b && a.splice(b, 1);\n      },\n      add: function add(a) {\n        void 0 !== b[a.name] && console.log(\"THREE.AnimationHandler.add: Warning! \" + a.name + \" already exists in library. Overwriting.\");\n        b[a.name] = a;\n        if (!0 !== a.initialized) {\n          for (var c = 0; c < a.hierarchy.length; c++) {\n            for (var d = 0; d < a.hierarchy[c].keys.length; d++) if (0 > a.hierarchy[c].keys[d].time && (a.hierarchy[c].keys[d].time = 0), void 0 !== a.hierarchy[c].keys[d].rot && !(a.hierarchy[c].keys[d].rot instanceof THREE.Quaternion)) {\n              var h = a.hierarchy[c].keys[d].rot;\n              a.hierarchy[c].keys[d].rot = new THREE.Quaternion(h[0], h[1], h[2], h[3]);\n            }\n            if (a.hierarchy[c].keys.length && void 0 !== a.hierarchy[c].keys[0].morphTargets) {\n              h = {};\n              for (d = 0; d < a.hierarchy[c].keys.length; d++) for (var i = 0; i < a.hierarchy[c].keys[d].morphTargets.length; i++) {\n                var k = a.hierarchy[c].keys[d].morphTargets[i];\n                h[k] = -1;\n              }\n              a.hierarchy[c].usedMorphTargets = h;\n              for (d = 0; d < a.hierarchy[c].keys.length; d++) {\n                var l = {};\n                for (k in h) {\n                  for (i = 0; i < a.hierarchy[c].keys[d].morphTargets.length; i++) if (a.hierarchy[c].keys[d].morphTargets[i] === k) {\n                    l[k] = a.hierarchy[c].keys[d].morphTargetsInfluences[i];\n                    break;\n                  }\n                  i === a.hierarchy[c].keys[d].morphTargets.length && (l[k] = 0);\n                }\n                a.hierarchy[c].keys[d].morphTargetsInfluences = l;\n              }\n            }\n            for (d = 1; d < a.hierarchy[c].keys.length; d++) a.hierarchy[c].keys[d].time === a.hierarchy[c].keys[d - 1].time && (a.hierarchy[c].keys.splice(d, 1), d--);\n            for (d = 0; d < a.hierarchy[c].keys.length; d++) a.hierarchy[c].keys[d].index = d;\n          }\n          d = parseInt(a.length * a.fps, 10);\n          a.JIT = {};\n          a.JIT.hierarchy = [];\n          for (c = 0; c < a.hierarchy.length; c++) a.JIT.hierarchy.push(Array(d));\n          a.initialized = !0;\n        }\n      },\n      get: function get(a) {\n        if (\"string\" === typeof a) {\n          if (b[a]) return b[a];\n          console.log(\"THREE.AnimationHandler.get: Couldn't find animation \" + a);\n          return null;\n        }\n      },\n      parse: function parse(a) {\n        var b = [];\n        if (a instanceof THREE.SkinnedMesh) for (var c = 0; c < a.bones.length; c++) b.push(a.bones[c]);else d(a, b);\n        return b;\n      }\n    },\n    d = function d(a, b) {\n      b.push(a);\n      for (var c = 0; c < a.children.length; c++) d(a.children[c], b);\n    };\n  c.LINEAR = 0;\n  c.CATMULLROM = 1;\n  c.CATMULLROM_FORWARD = 2;\n  return c;\n}();\nTHREE.Animation = function (a, b, c) {\n  this.root = a;\n  this.data = THREE.AnimationHandler.get(b);\n  this.hierarchy = THREE.AnimationHandler.parse(a);\n  this.currentTime = 0;\n  this.timeScale = 1;\n  this.isPlaying = !1;\n  this.loop = this.isPaused = !0;\n  this.interpolationType = void 0 !== c ? c : THREE.AnimationHandler.LINEAR;\n  this.points = [];\n  this.target = new THREE.Vector3();\n};\nTHREE.Animation.prototype.play = function (a, b) {\n  if (!1 === this.isPlaying) {\n    this.isPlaying = !0;\n    this.loop = void 0 !== a ? a : !0;\n    this.currentTime = void 0 !== b ? b : 0;\n    var c,\n      d = this.hierarchy.length,\n      e;\n    for (c = 0; c < d; c++) {\n      e = this.hierarchy[c];\n      this.interpolationType !== THREE.AnimationHandler.CATMULLROM_FORWARD && (e.useQuaternion = !0);\n      e.matrixAutoUpdate = !0;\n      void 0 === e.animationCache && (e.animationCache = {}, e.animationCache.prevKey = {\n        pos: 0,\n        rot: 0,\n        scl: 0\n      }, e.animationCache.nextKey = {\n        pos: 0,\n        rot: 0,\n        scl: 0\n      }, e.animationCache.originalMatrix = e instanceof THREE.Bone ? e.skinMatrix : e.matrix);\n      var f = e.animationCache.prevKey;\n      e = e.animationCache.nextKey;\n      f.pos = this.data.hierarchy[c].keys[0];\n      f.rot = this.data.hierarchy[c].keys[0];\n      f.scl = this.data.hierarchy[c].keys[0];\n      e.pos = this.getNextKeyWith(\"pos\", c, 1);\n      e.rot = this.getNextKeyWith(\"rot\", c, 1);\n      e.scl = this.getNextKeyWith(\"scl\", c, 1);\n    }\n    this.update(0);\n  }\n  this.isPaused = !1;\n  THREE.AnimationHandler.addToUpdate(this);\n};\nTHREE.Animation.prototype.pause = function () {\n  !0 === this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);\n  this.isPaused = !this.isPaused;\n};\nTHREE.Animation.prototype.stop = function () {\n  this.isPaused = this.isPlaying = !1;\n  THREE.AnimationHandler.removeFromUpdate(this);\n};\nTHREE.Animation.prototype.update = function (a) {\n  if (!1 !== this.isPlaying) {\n    var b = [\"pos\", \"rot\", \"scl\"],\n      c,\n      d,\n      e,\n      f,\n      g,\n      h,\n      i,\n      k,\n      l;\n    l = this.currentTime += a * this.timeScale;\n    k = this.currentTime %= this.data.length;\n    parseInt(Math.min(k * this.data.fps, this.data.length * this.data.fps), 10);\n    for (var m = 0, n = this.hierarchy.length; m < n; m++) {\n      a = this.hierarchy[m];\n      i = a.animationCache;\n      for (var s = 0; 3 > s; s++) {\n        c = b[s];\n        g = i.prevKey[c];\n        h = i.nextKey[c];\n        if (h.time <= l) {\n          if (k < l) {\n            if (this.loop) {\n              g = this.data.hierarchy[m].keys[0];\n              for (h = this.getNextKeyWith(c, m, 1); h.time < k;) g = h, h = this.getNextKeyWith(c, m, h.index + 1);\n            } else {\n              this.stop();\n              return;\n            }\n          } else {\n            do g = h, h = this.getNextKeyWith(c, m, h.index + 1); while (h.time < k);\n          }\n          i.prevKey[c] = g;\n          i.nextKey[c] = h;\n        }\n        a.matrixAutoUpdate = !0;\n        a.matrixWorldNeedsUpdate = !0;\n        d = (k - g.time) / (h.time - g.time);\n        e = g[c];\n        f = h[c];\n        if (0 > d || 1 < d) console.log(\"THREE.Animation.update: Warning! Scale out of bounds:\" + d + \" on bone \" + m), d = 0 > d ? 0 : 1;\n        if (\"pos\" === c) {\n          if (c = a.position, this.interpolationType === THREE.AnimationHandler.LINEAR) c.x = e[0] + (f[0] - e[0]) * d, c.y = e[1] + (f[1] - e[1]) * d, c.z = e[2] + (f[2] - e[2]) * d;else {\n            if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) this.points[0] = this.getPrevKeyWith(\"pos\", m, g.index - 1).pos, this.points[1] = e, this.points[2] = f, this.points[3] = this.getNextKeyWith(\"pos\", m, h.index + 1).pos, d = 0.33 * d + 0.33, e = this.interpolateCatmullRom(this.points, d), c.x = e[0], c.y = e[1], c.z = e[2], this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (d = this.interpolateCatmullRom(this.points, 1.01 * d), this.target.set(d[0], d[1], d[2]), this.target.sub(c), this.target.y = 0, this.target.normalize(), d = Math.atan2(this.target.x, this.target.z), a.rotation.set(0, d, 0));\n          }\n        } else \"rot\" === c ? THREE.Quaternion.slerp(e, f, a.quaternion, d) : \"scl\" === c && (c = a.scale, c.x = e[0] + (f[0] - e[0]) * d, c.y = e[1] + (f[1] - e[1]) * d, c.z = e[2] + (f[2] - e[2]) * d);\n      }\n    }\n  }\n};\nTHREE.Animation.prototype.interpolateCatmullRom = function (a, b) {\n  var c = [],\n    d = [],\n    e,\n    f,\n    g,\n    h,\n    i,\n    k;\n  e = (a.length - 1) * b;\n  f = Math.floor(e);\n  e -= f;\n  c[0] = 0 === f ? f : f - 1;\n  c[1] = f;\n  c[2] = f > a.length - 2 ? f : f + 1;\n  c[3] = f > a.length - 3 ? f : f + 2;\n  f = a[c[0]];\n  h = a[c[1]];\n  i = a[c[2]];\n  k = a[c[3]];\n  c = e * e;\n  g = e * c;\n  d[0] = this.interpolate(f[0], h[0], i[0], k[0], e, c, g);\n  d[1] = this.interpolate(f[1], h[1], i[1], k[1], e, c, g);\n  d[2] = this.interpolate(f[2], h[2], i[2], k[2], e, c, g);\n  return d;\n};\nTHREE.Animation.prototype.interpolate = function (a, b, c, d, e, f, g) {\n  a = 0.5 * (c - a);\n  d = 0.5 * (d - b);\n  return (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b;\n};\nTHREE.Animation.prototype.getNextKeyWith = function (a, b, c) {\n  for (var d = this.data.hierarchy[b].keys, c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c < d.length - 1 ? c : d.length - 1 : c % d.length; c < d.length; c++) if (void 0 !== d[c][a]) return d[c];\n  return this.data.hierarchy[b].keys[0];\n};\nTHREE.Animation.prototype.getPrevKeyWith = function (a, b, c) {\n  for (var d = this.data.hierarchy[b].keys, c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < c ? c : 0 : 0 <= c ? c : c + d.length; 0 <= c; c--) if (void 0 !== d[c][a]) return d[c];\n  return this.data.hierarchy[b].keys[d.length - 1];\n};\nTHREE.KeyFrameAnimation = function (a, b, c) {\n  this.root = a;\n  this.data = THREE.AnimationHandler.get(b);\n  this.hierarchy = THREE.AnimationHandler.parse(a);\n  this.currentTime = 0;\n  this.timeScale = 0.001;\n  this.isPlaying = !1;\n  this.loop = this.isPaused = !0;\n  this.JITCompile = void 0 !== c ? c : !0;\n  a = 0;\n  for (b = this.hierarchy.length; a < b; a++) {\n    var c = this.data.hierarchy[a].sids,\n      d = this.hierarchy[a];\n    if (this.data.hierarchy[a].keys.length && c) {\n      for (var e = 0; e < c.length; e++) {\n        var f = c[e],\n          g = this.getNextKeyWith(f, a, 0);\n        g && g.apply(f);\n      }\n      d.matrixAutoUpdate = !1;\n      this.data.hierarchy[a].node.updateMatrix();\n      d.matrixWorldNeedsUpdate = !0;\n    }\n  }\n};\nTHREE.KeyFrameAnimation.prototype.play = function (a, b) {\n  if (!this.isPlaying) {\n    this.isPlaying = !0;\n    this.loop = void 0 !== a ? a : !0;\n    this.currentTime = void 0 !== b ? b : 0;\n    this.startTimeMs = b;\n    this.startTime = 1E7;\n    this.endTime = -this.startTime;\n    var c,\n      d = this.hierarchy.length,\n      e,\n      f;\n    for (c = 0; c < d; c++) e = this.hierarchy[c], f = this.data.hierarchy[c], e.useQuaternion = !0, void 0 === f.animationCache && (f.animationCache = {}, f.animationCache.prevKey = null, f.animationCache.nextKey = null, f.animationCache.originalMatrix = e instanceof THREE.Bone ? e.skinMatrix : e.matrix), e = this.data.hierarchy[c].keys, e.length && (f.animationCache.prevKey = e[0], f.animationCache.nextKey = e[1], this.startTime = Math.min(e[0].time, this.startTime), this.endTime = Math.max(e[e.length - 1].time, this.endTime));\n    this.update(0);\n  }\n  this.isPaused = !1;\n  THREE.AnimationHandler.addToUpdate(this);\n};\nTHREE.KeyFrameAnimation.prototype.pause = function () {\n  this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);\n  this.isPaused = !this.isPaused;\n};\nTHREE.KeyFrameAnimation.prototype.stop = function () {\n  this.isPaused = this.isPlaying = !1;\n  THREE.AnimationHandler.removeFromUpdate(this);\n  for (var a = 0; a < this.data.hierarchy.length; a++) {\n    var b = this.hierarchy[a],\n      c = this.data.hierarchy[a];\n    if (void 0 !== c.animationCache) {\n      var d = c.animationCache.originalMatrix;\n      b instanceof THREE.Bone ? (d.copy(b.skinMatrix), b.skinMatrix = d) : (d.copy(b.matrix), b.matrix = d);\n      delete c.animationCache;\n    }\n  }\n};\nTHREE.KeyFrameAnimation.prototype.update = function (a) {\n  if (this.isPlaying) {\n    var b,\n      c,\n      d,\n      e,\n      f = this.data.JIT.hierarchy,\n      g,\n      h,\n      i;\n    h = this.currentTime += a * this.timeScale;\n    g = this.currentTime %= this.data.length;\n    g < this.startTimeMs && (g = this.currentTime = this.startTimeMs + g);\n    e = parseInt(Math.min(g * this.data.fps, this.data.length * this.data.fps), 10);\n    if ((i = g < h) && !this.loop) {\n      for (var a = 0, k = this.hierarchy.length; a < k; a++) {\n        var l = this.data.hierarchy[a].keys,\n          f = this.data.hierarchy[a].sids;\n        d = l.length - 1;\n        e = this.hierarchy[a];\n        if (l.length) {\n          for (l = 0; l < f.length; l++) g = f[l], (h = this.getPrevKeyWith(g, a, d)) && h.apply(g);\n          this.data.hierarchy[a].node.updateMatrix();\n          e.matrixWorldNeedsUpdate = !0;\n        }\n      }\n      this.stop();\n    } else if (!(g < this.startTime)) {\n      a = 0;\n      for (k = this.hierarchy.length; a < k; a++) {\n        d = this.hierarchy[a];\n        b = this.data.hierarchy[a];\n        var l = b.keys,\n          m = b.animationCache;\n        if (this.JITCompile && void 0 !== f[a][e]) d instanceof THREE.Bone ? (d.skinMatrix = f[a][e], d.matrixWorldNeedsUpdate = !1) : (d.matrix = f[a][e], d.matrixWorldNeedsUpdate = !0);else if (l.length) {\n          this.JITCompile && m && (d instanceof THREE.Bone ? d.skinMatrix = m.originalMatrix : d.matrix = m.originalMatrix);\n          b = m.prevKey;\n          c = m.nextKey;\n          if (b && c) {\n            if (c.time <= h) {\n              if (i && this.loop) {\n                b = l[0];\n                for (c = l[1]; c.time < g;) b = c, c = l[b.index + 1];\n              } else if (!i) for (var n = l.length - 1; c.time < g && c.index !== n;) b = c, c = l[b.index + 1];\n              m.prevKey = b;\n              m.nextKey = c;\n            }\n            c.time >= g ? b.interpolate(c, g) : b.interpolate(c, c.time);\n          }\n          this.data.hierarchy[a].node.updateMatrix();\n          d.matrixWorldNeedsUpdate = !0;\n        }\n      }\n      if (this.JITCompile && void 0 === f[0][e]) {\n        this.hierarchy[0].updateMatrixWorld(!0);\n        for (a = 0; a < this.hierarchy.length; a++) f[a][e] = this.hierarchy[a] instanceof THREE.Bone ? this.hierarchy[a].skinMatrix.clone() : this.hierarchy[a].matrix.clone();\n      }\n    }\n  }\n};\nTHREE.KeyFrameAnimation.prototype.getNextKeyWith = function (a, b, c) {\n  b = this.data.hierarchy[b].keys;\n  for (c %= b.length; c < b.length; c++) if (b[c].hasTarget(a)) return b[c];\n  return b[0];\n};\nTHREE.KeyFrameAnimation.prototype.getPrevKeyWith = function (a, b, c) {\n  b = this.data.hierarchy[b].keys;\n  for (c = 0 <= c ? c : c + b.length; 0 <= c; c--) if (b[c].hasTarget(a)) return b[c];\n  return b[b.length - 1];\n};\nTHREE.CubeCamera = function (a, b, c) {\n  THREE.Object3D.call(this);\n  var d = new THREE.PerspectiveCamera(90, 1, a, b);\n  d.up.set(0, -1, 0);\n  d.lookAt(new THREE.Vector3(1, 0, 0));\n  this.add(d);\n  var e = new THREE.PerspectiveCamera(90, 1, a, b);\n  e.up.set(0, -1, 0);\n  e.lookAt(new THREE.Vector3(-1, 0, 0));\n  this.add(e);\n  var f = new THREE.PerspectiveCamera(90, 1, a, b);\n  f.up.set(0, 0, 1);\n  f.lookAt(new THREE.Vector3(0, 1, 0));\n  this.add(f);\n  var g = new THREE.PerspectiveCamera(90, 1, a, b);\n  g.up.set(0, 0, -1);\n  g.lookAt(new THREE.Vector3(0, -1, 0));\n  this.add(g);\n  var h = new THREE.PerspectiveCamera(90, 1, a, b);\n  h.up.set(0, -1, 0);\n  h.lookAt(new THREE.Vector3(0, 0, 1));\n  this.add(h);\n  var i = new THREE.PerspectiveCamera(90, 1, a, b);\n  i.up.set(0, -1, 0);\n  i.lookAt(new THREE.Vector3(0, 0, -1));\n  this.add(i);\n  this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, {\n    format: THREE.RGBFormat,\n    magFilter: THREE.LinearFilter,\n    minFilter: THREE.LinearFilter\n  });\n  this.updateCubeMap = function (a, b) {\n    var c = this.renderTarget,\n      n = c.generateMipmaps;\n    c.generateMipmaps = !1;\n    c.activeCubeFace = 0;\n    a.render(b, d, c);\n    c.activeCubeFace = 1;\n    a.render(b, e, c);\n    c.activeCubeFace = 2;\n    a.render(b, f, c);\n    c.activeCubeFace = 3;\n    a.render(b, g, c);\n    c.activeCubeFace = 4;\n    a.render(b, h, c);\n    c.generateMipmaps = n;\n    c.activeCubeFace = 5;\n    a.render(b, i, c);\n  };\n};\nTHREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.CombinedCamera = function (a, b, c, d, e, f, g) {\n  THREE.Camera.call(this);\n  this.fov = c;\n  this.left = -a / 2;\n  this.right = a / 2;\n  this.top = b / 2;\n  this.bottom = -b / 2;\n  this.cameraO = new THREE.OrthographicCamera(a / -2, a / 2, b / 2, b / -2, f, g);\n  this.cameraP = new THREE.PerspectiveCamera(c, a / b, d, e);\n  this.zoom = 1;\n  this.toPerspective();\n};\nTHREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype);\nTHREE.CombinedCamera.prototype.toPerspective = function () {\n  this.near = this.cameraP.near;\n  this.far = this.cameraP.far;\n  this.cameraP.fov = this.fov / this.zoom;\n  this.cameraP.updateProjectionMatrix();\n  this.projectionMatrix = this.cameraP.projectionMatrix;\n  this.inPerspectiveMode = !0;\n  this.inOrthographicMode = !1;\n};\nTHREE.CombinedCamera.prototype.toOrthographic = function () {\n  var a = this.cameraP.aspect,\n    b = (this.cameraP.near + this.cameraP.far) / 2,\n    b = Math.tan(this.fov / 2) * b,\n    a = 2 * b * a / 2,\n    b = b / this.zoom,\n    a = a / this.zoom;\n  this.cameraO.left = -a;\n  this.cameraO.right = a;\n  this.cameraO.top = b;\n  this.cameraO.bottom = -b;\n  this.cameraO.updateProjectionMatrix();\n  this.near = this.cameraO.near;\n  this.far = this.cameraO.far;\n  this.projectionMatrix = this.cameraO.projectionMatrix;\n  this.inPerspectiveMode = !1;\n  this.inOrthographicMode = !0;\n};\nTHREE.CombinedCamera.prototype.setSize = function (a, b) {\n  this.cameraP.aspect = a / b;\n  this.left = -a / 2;\n  this.right = a / 2;\n  this.top = b / 2;\n  this.bottom = -b / 2;\n};\nTHREE.CombinedCamera.prototype.setFov = function (a) {\n  this.fov = a;\n  this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic();\n};\nTHREE.CombinedCamera.prototype.updateProjectionMatrix = function () {\n  this.inPerspectiveMode ? this.toPerspective() : (this.toPerspective(), this.toOrthographic());\n};\nTHREE.CombinedCamera.prototype.setLens = function (a, b) {\n  void 0 === b && (b = 24);\n  var c = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));\n  this.setFov(c);\n  return c;\n};\nTHREE.CombinedCamera.prototype.setZoom = function (a) {\n  this.zoom = a;\n  this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic();\n};\nTHREE.CombinedCamera.prototype.toFrontView = function () {\n  this.rotation.x = 0;\n  this.rotation.y = 0;\n  this.rotation.z = 0;\n  this.rotationAutoUpdate = !1;\n};\nTHREE.CombinedCamera.prototype.toBackView = function () {\n  this.rotation.x = 0;\n  this.rotation.y = Math.PI;\n  this.rotation.z = 0;\n  this.rotationAutoUpdate = !1;\n};\nTHREE.CombinedCamera.prototype.toLeftView = function () {\n  this.rotation.x = 0;\n  this.rotation.y = -Math.PI / 2;\n  this.rotation.z = 0;\n  this.rotationAutoUpdate = !1;\n};\nTHREE.CombinedCamera.prototype.toRightView = function () {\n  this.rotation.x = 0;\n  this.rotation.y = Math.PI / 2;\n  this.rotation.z = 0;\n  this.rotationAutoUpdate = !1;\n};\nTHREE.CombinedCamera.prototype.toTopView = function () {\n  this.rotation.x = -Math.PI / 2;\n  this.rotation.y = 0;\n  this.rotation.z = 0;\n  this.rotationAutoUpdate = !1;\n};\nTHREE.CombinedCamera.prototype.toBottomView = function () {\n  this.rotation.x = Math.PI / 2;\n  this.rotation.y = 0;\n  this.rotation.z = 0;\n  this.rotationAutoUpdate = !1;\n};\nTHREE.AsteriskGeometry = function (a, b) {\n  THREE.Geometry.call(this);\n  for (var c = 0.707 * a, d = 0.707 * b, c = [[a, 0, 0], [b, 0, 0], [-a, 0, 0], [-b, 0, 0], [0, a, 0], [0, b, 0], [0, -a, 0], [0, -b, 0], [0, 0, a], [0, 0, b], [0, 0, -a], [0, 0, -b], [c, c, 0], [d, d, 0], [-c, -c, 0], [-d, -d, 0], [c, -c, 0], [d, -d, 0], [-c, c, 0], [-d, d, 0], [c, 0, c], [d, 0, d], [-c, 0, -c], [-d, 0, -d], [c, 0, -c], [d, 0, -d], [-c, 0, c], [-d, 0, d], [0, c, c], [0, d, d], [0, -c, -c], [0, -d, -d], [0, c, -c], [0, d, -d], [0, -c, c], [0, -d, d]], d = 0, e = c.length; d < e; d++) this.vertices.push(new THREE.Vector3(c[d][0], c[d][1], c[d][2]));\n};\nTHREE.AsteriskGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.CircleGeometry = function (a, b, c, d) {\n  THREE.Geometry.call(this);\n  var a = a || 50,\n    c = void 0 !== c ? c : 0,\n    d = void 0 !== d ? d : 2 * Math.PI,\n    b = void 0 !== b ? Math.max(3, b) : 8,\n    e,\n    f = [];\n  e = new THREE.Vector3();\n  var g = new THREE.Vector2(0.5, 0.5);\n  this.vertices.push(e);\n  f.push(g);\n  for (e = 0; e <= b; e++) {\n    var h = new THREE.Vector3();\n    h.x = a * Math.cos(c + e / b * d);\n    h.y = a * Math.sin(c + e / b * d);\n    this.vertices.push(h);\n    f.push(new THREE.Vector2((h.x / a + 1) / 2, -(h.y / a + 1) / 2 + 1));\n  }\n  c = new THREE.Vector3(0, 0, -1);\n  for (e = 1; e <= b; e++) this.faces.push(new THREE.Face3(e, e + 1, 0, [c, c, c])), this.faceVertexUvs[0].push([f[e], f[e + 1], g]);\n  this.computeCentroids();\n  this.computeFaceNormals();\n  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);\n};\nTHREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.CubeGeometry = function (a, b, c, d, e, f) {\n  function g(a, b, c, d, e, f, g, p) {\n    var q,\n      y = h.widthSegments,\n      v = h.heightSegments,\n      z = e / 2,\n      t = f / 2,\n      A = h.vertices.length;\n    if (\"x\" === a && \"y\" === b || \"y\" === a && \"x\" === b) q = \"z\";else if (\"x\" === a && \"z\" === b || \"z\" === a && \"x\" === b) q = \"y\", v = h.depthSegments;else if (\"z\" === a && \"y\" === b || \"y\" === a && \"z\" === b) q = \"x\", y = h.depthSegments;\n    var I = y + 1,\n      C = v + 1,\n      x = e / y,\n      G = f / v,\n      J = new THREE.Vector3();\n    J[q] = 0 < g ? 1 : -1;\n    for (e = 0; e < C; e++) for (f = 0; f < I; f++) {\n      var E = new THREE.Vector3();\n      E[a] = (f * x - z) * c;\n      E[b] = (e * G - t) * d;\n      E[q] = g;\n      h.vertices.push(E);\n    }\n    for (e = 0; e < v; e++) for (f = 0; f < y; f++) a = new THREE.Face4(f + I * e + A, f + I * (e + 1) + A, f + 1 + I * (e + 1) + A, f + 1 + I * e + A), a.normal.copy(J), a.vertexNormals.push(J.clone(), J.clone(), J.clone(), J.clone()), a.materialIndex = p, h.faces.push(a), h.faceVertexUvs[0].push([new THREE.Vector2(f / y, 1 - e / v), new THREE.Vector2(f / y, 1 - (e + 1) / v), new THREE.Vector2((f + 1) / y, 1 - (e + 1) / v), new THREE.Vector2((f + 1) / y, 1 - e / v)]);\n  }\n  THREE.Geometry.call(this);\n  var h = this;\n  this.width = a;\n  this.height = b;\n  this.depth = c;\n  this.widthSegments = d || 1;\n  this.heightSegments = e || 1;\n  this.depthSegments = f || 1;\n  a = this.width / 2;\n  b = this.height / 2;\n  c = this.depth / 2;\n  g(\"z\", \"y\", -1, -1, this.depth, this.height, a, 0);\n  g(\"z\", \"y\", 1, -1, this.depth, this.height, -a, 1);\n  g(\"x\", \"z\", 1, 1, this.width, this.depth, b, 2);\n  g(\"x\", \"z\", 1, -1, this.width, this.depth, -b, 3);\n  g(\"x\", \"y\", 1, -1, this.width, this.height, c, 4);\n  g(\"x\", \"y\", -1, -1, this.width, this.height, -c, 5);\n  this.computeCentroids();\n  this.mergeVertices();\n};\nTHREE.CubeGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.CylinderGeometry = function (a, b, c, d, e, f) {\n  THREE.Geometry.call(this);\n  var a = void 0 !== a ? a : 20,\n    b = void 0 !== b ? b : 20,\n    c = void 0 !== c ? c : 100,\n    g = c / 2,\n    d = d || 8,\n    e = e || 1,\n    h,\n    i,\n    k = [],\n    l = [];\n  for (i = 0; i <= e; i++) {\n    var m = [],\n      n = [],\n      s = i / e,\n      r = s * (b - a) + a;\n    for (h = 0; h <= d; h++) {\n      var p = h / d,\n        q = new THREE.Vector3();\n      q.x = r * Math.sin(2 * p * Math.PI);\n      q.y = -s * c + g;\n      q.z = r * Math.cos(2 * p * Math.PI);\n      this.vertices.push(q);\n      m.push(this.vertices.length - 1);\n      n.push(new THREE.Vector2(p, 1 - s));\n    }\n    k.push(m);\n    l.push(n);\n  }\n  c = (b - a) / c;\n  for (h = 0; h < d; h++) {\n    0 !== a ? (m = this.vertices[k[0][h]].clone(), n = this.vertices[k[0][h + 1]].clone()) : (m = this.vertices[k[1][h]].clone(), n = this.vertices[k[1][h + 1]].clone());\n    m.setY(Math.sqrt(m.x * m.x + m.z * m.z) * c).normalize();\n    n.setY(Math.sqrt(n.x * n.x + n.z * n.z) * c).normalize();\n    for (i = 0; i < e; i++) {\n      var s = k[i][h],\n        r = k[i + 1][h],\n        p = k[i + 1][h + 1],\n        q = k[i][h + 1],\n        y = m.clone(),\n        v = m.clone(),\n        z = n.clone(),\n        t = n.clone(),\n        A = l[i][h].clone(),\n        I = l[i + 1][h].clone(),\n        C = l[i + 1][h + 1].clone(),\n        x = l[i][h + 1].clone();\n      this.faces.push(new THREE.Face4(s, r, p, q, [y, v, z, t]));\n      this.faceVertexUvs[0].push([A, I, C, x]);\n    }\n  }\n  if (!f && 0 < a) {\n    this.vertices.push(new THREE.Vector3(0, g, 0));\n    for (h = 0; h < d; h++) s = k[0][h], r = k[0][h + 1], p = this.vertices.length - 1, y = new THREE.Vector3(0, 1, 0), v = new THREE.Vector3(0, 1, 0), z = new THREE.Vector3(0, 1, 0), A = l[0][h].clone(), I = l[0][h + 1].clone(), C = new THREE.Vector2(I.u, 0), this.faces.push(new THREE.Face3(s, r, p, [y, v, z])), this.faceVertexUvs[0].push([A, I, C]);\n  }\n  if (!f && 0 < b) {\n    this.vertices.push(new THREE.Vector3(0, -g, 0));\n    for (h = 0; h < d; h++) s = k[i][h + 1], r = k[i][h], p = this.vertices.length - 1, y = new THREE.Vector3(0, -1, 0), v = new THREE.Vector3(0, -1, 0), z = new THREE.Vector3(0, -1, 0), A = l[i][h + 1].clone(), I = l[i][h].clone(), C = new THREE.Vector2(I.u, 1), this.faces.push(new THREE.Face3(s, r, p, [y, v, z])), this.faceVertexUvs[0].push([A, I, C]);\n  }\n  this.computeCentroids();\n  this.computeFaceNormals();\n};\nTHREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.ExtrudeGeometry = function (a, b) {\n  \"undefined\" !== typeof a && (THREE.Geometry.call(this), a = a instanceof Array ? a : [a], this.shapebb = a[a.length - 1].getBoundingBox(), this.addShapeList(a, b), this.computeCentroids(), this.computeFaceNormals());\n};\nTHREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.ExtrudeGeometry.prototype.addShapeList = function (a, b) {\n  for (var c = a.length, d = 0; d < c; d++) this.addShape(a[d], b);\n};\nTHREE.ExtrudeGeometry.prototype.addShape = function (a, b) {\n  function c(a, b, c) {\n    b || console.log(\"die\");\n    return b.clone().multiplyScalar(c).add(a);\n  }\n  function d(a, b, c) {\n    var d = THREE.ExtrudeGeometry.__v1,\n      e = THREE.ExtrudeGeometry.__v2,\n      f = THREE.ExtrudeGeometry.__v3,\n      g = THREE.ExtrudeGeometry.__v4,\n      i = THREE.ExtrudeGeometry.__v5,\n      h = THREE.ExtrudeGeometry.__v6;\n    d.set(a.x - b.x, a.y - b.y);\n    e.set(a.x - c.x, a.y - c.y);\n    d = d.normalize();\n    e = e.normalize();\n    f.set(-d.y, d.x);\n    g.set(e.y, -e.x);\n    i.copy(a).add(f);\n    h.copy(a).add(g);\n    if (i.equals(h)) return g.clone();\n    i.copy(b).add(f);\n    h.copy(c).add(g);\n    f = d.dot(g);\n    g = h.sub(i).dot(g);\n    0 === f && (console.log(\"Either infinite or no solutions!\"), 0 === g ? console.log(\"Its finite solutions.\") : console.log(\"Too bad, no solutions.\"));\n    g /= f;\n    return 0 > g ? (b = Math.atan2(b.y - a.y, b.x - a.x), a = Math.atan2(c.y - a.y, c.x - a.x), b > a && (a += 2 * Math.PI), c = (b + a) / 2, a = -Math.cos(c), c = -Math.sin(c), new THREE.Vector2(a, c)) : d.multiplyScalar(g).add(i).sub(a).clone();\n  }\n  function e(c, d) {\n    var e, f;\n    for (M = c.length; 0 <= --M;) {\n      e = M;\n      f = M - 1;\n      0 > f && (f = c.length - 1);\n      for (var g = 0, i = s + 2 * l, g = 0; g < i; g++) {\n        var h = fa * g,\n          k = fa * (g + 1),\n          m = d + e + h,\n          h = d + f + h,\n          n = d + f + k,\n          k = d + e + k,\n          p = c,\n          q = g,\n          r = i,\n          t = e,\n          y = f,\n          m = m + H,\n          h = h + H,\n          n = n + H,\n          k = k + H;\n        E.faces.push(new THREE.Face4(m, h, n, k, null, null, v));\n        m = z.generateSideWallUV(E, a, p, b, m, h, n, k, q, r, t, y);\n        E.faceVertexUvs[0].push(m);\n      }\n    }\n  }\n  function f(a, b, c) {\n    E.vertices.push(new THREE.Vector3(a, b, c));\n  }\n  function g(c, d, e, f) {\n    c += H;\n    d += H;\n    e += H;\n    E.faces.push(new THREE.Face3(c, d, e, null, null, y));\n    c = f ? z.generateBottomUV(E, a, b, c, d, e) : z.generateTopUV(E, a, b, c, d, e);\n    E.faceVertexUvs[0].push(c);\n  }\n  var h = void 0 !== b.amount ? b.amount : 100,\n    i = void 0 !== b.bevelThickness ? b.bevelThickness : 6,\n    k = void 0 !== b.bevelSize ? b.bevelSize : i - 2,\n    l = void 0 !== b.bevelSegments ? b.bevelSegments : 3,\n    m = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0,\n    n = void 0 !== b.curveSegments ? b.curveSegments : 12,\n    s = void 0 !== b.steps ? b.steps : 1,\n    r = b.extrudePath,\n    p,\n    q = !1,\n    y = b.material,\n    v = b.extrudeMaterial,\n    z = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator,\n    t,\n    A,\n    I,\n    C;\n  r && (p = r.getSpacedPoints(s), q = !0, m = !1, t = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(r, s, !1), A = new THREE.Vector3(), I = new THREE.Vector3(), C = new THREE.Vector3());\n  m || (k = i = l = 0);\n  var x,\n    G,\n    J,\n    E = this,\n    H = this.vertices.length,\n    n = a.extractPoints(n),\n    B = n.shape,\n    n = n.holes;\n  if (r = !THREE.Shape.Utils.isClockWise(B)) {\n    B = B.reverse();\n    G = 0;\n    for (J = n.length; G < J; G++) x = n[G], THREE.Shape.Utils.isClockWise(x) && (n[G] = x.reverse());\n    r = !1;\n  }\n  var W = THREE.Shape.Utils.triangulateShape(B, n),\n    r = B;\n  G = 0;\n  for (J = n.length; G < J; G++) x = n[G], B = B.concat(x);\n  var F,\n    K,\n    L,\n    U,\n    fa = B.length,\n    Ca = W.length,\n    $a = [],\n    M = 0,\n    ca = r.length;\n  F = ca - 1;\n  for (K = M + 1; M < ca; M++, F++, K++) F === ca && (F = 0), K === ca && (K = 0), $a[M] = d(r[M], r[F], r[K]);\n  var qa = [],\n    ha,\n    ra = $a.concat();\n  G = 0;\n  for (J = n.length; G < J; G++) {\n    x = n[G];\n    ha = [];\n    M = 0;\n    ca = x.length;\n    F = ca - 1;\n    for (K = M + 1; M < ca; M++, F++, K++) F === ca && (F = 0), K === ca && (K = 0), ha[M] = d(x[M], x[F], x[K]);\n    qa.push(ha);\n    ra = ra.concat(ha);\n  }\n  for (F = 0; F < l; F++) {\n    x = F / l;\n    L = i * (1 - x);\n    K = k * Math.sin(x * Math.PI / 2);\n    M = 0;\n    for (ca = r.length; M < ca; M++) U = c(r[M], $a[M], K), f(U.x, U.y, -L);\n    G = 0;\n    for (J = n.length; G < J; G++) {\n      x = n[G];\n      ha = qa[G];\n      M = 0;\n      for (ca = x.length; M < ca; M++) U = c(x[M], ha[M], K), f(U.x, U.y, -L);\n    }\n  }\n  K = k;\n  for (M = 0; M < fa; M++) U = m ? c(B[M], ra[M], K) : B[M], q ? (I.copy(t.normals[0]).multiplyScalar(U.x), A.copy(t.binormals[0]).multiplyScalar(U.y), C.copy(p[0]).add(I).add(A), f(C.x, C.y, C.z)) : f(U.x, U.y, 0);\n  for (x = 1; x <= s; x++) for (M = 0; M < fa; M++) U = m ? c(B[M], ra[M], K) : B[M], q ? (I.copy(t.normals[x]).multiplyScalar(U.x), A.copy(t.binormals[x]).multiplyScalar(U.y), C.copy(p[x]).add(I).add(A), f(C.x, C.y, C.z)) : f(U.x, U.y, h / s * x);\n  for (F = l - 1; 0 <= F; F--) {\n    x = F / l;\n    L = i * (1 - x);\n    K = k * Math.sin(x * Math.PI / 2);\n    M = 0;\n    for (ca = r.length; M < ca; M++) U = c(r[M], $a[M], K), f(U.x, U.y, h + L);\n    G = 0;\n    for (J = n.length; G < J; G++) {\n      x = n[G];\n      ha = qa[G];\n      M = 0;\n      for (ca = x.length; M < ca; M++) U = c(x[M], ha[M], K), q ? f(U.x, U.y + p[s - 1].y, p[s - 1].x + L) : f(U.x, U.y, h + L);\n    }\n  }\n  if (m) {\n    i = 0 * fa;\n    for (M = 0; M < Ca; M++) h = W[M], g(h[2] + i, h[1] + i, h[0] + i, !0);\n    i = fa * (s + 2 * l);\n    for (M = 0; M < Ca; M++) h = W[M], g(h[0] + i, h[1] + i, h[2] + i, !1);\n  } else {\n    for (M = 0; M < Ca; M++) h = W[M], g(h[2], h[1], h[0], !0);\n    for (M = 0; M < Ca; M++) h = W[M], g(h[0] + fa * s, h[1] + fa * s, h[2] + fa * s, !1);\n  }\n  h = 0;\n  e(r, h);\n  h += r.length;\n  G = 0;\n  for (J = n.length; G < J; G++) x = n[G], e(x, h), h += x.length;\n};\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\n  generateTopUV: function generateTopUV(a, b, c, d, e, f) {\n    b = a.vertices[e].x;\n    e = a.vertices[e].y;\n    c = a.vertices[f].x;\n    f = a.vertices[f].y;\n    return [new THREE.Vector2(a.vertices[d].x, a.vertices[d].y), new THREE.Vector2(b, e), new THREE.Vector2(c, f)];\n  },\n  generateBottomUV: function generateBottomUV(a, b, c, d, e, f) {\n    return this.generateTopUV(a, b, c, d, e, f);\n  },\n  generateSideWallUV: function generateSideWallUV(a, b, c, d, e, f, g, h) {\n    var b = a.vertices[e].x,\n      c = a.vertices[e].y,\n      e = a.vertices[e].z,\n      d = a.vertices[f].x,\n      i = a.vertices[f].y,\n      f = a.vertices[f].z,\n      k = a.vertices[g].x,\n      l = a.vertices[g].y,\n      g = a.vertices[g].z,\n      m = a.vertices[h].x,\n      n = a.vertices[h].y,\n      a = a.vertices[h].z;\n    return 0.01 > Math.abs(c - i) ? [new THREE.Vector2(b, 1 - e), new THREE.Vector2(d, 1 - f), new THREE.Vector2(k, 1 - g), new THREE.Vector2(m, 1 - a)] : [new THREE.Vector2(c, 1 - e), new THREE.Vector2(i, 1 - f), new THREE.Vector2(l, 1 - g), new THREE.Vector2(n, 1 - a)];\n  }\n};\nTHREE.ExtrudeGeometry.__v1 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v2 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v3 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v4 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v5 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v6 = new THREE.Vector2();\nTHREE.ShapeGeometry = function (a, b) {\n  THREE.Geometry.call(this);\n  !1 === a instanceof Array && (a = [a]);\n  this.shapebb = a[a.length - 1].getBoundingBox();\n  this.addShapeList(a, b);\n  this.computeCentroids();\n  this.computeFaceNormals();\n};\nTHREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.ShapeGeometry.prototype.addShapeList = function (a, b) {\n  for (var c = 0, d = a.length; c < d; c++) this.addShape(a[c], b);\n  return this;\n};\nTHREE.ShapeGeometry.prototype.addShape = function (a, b) {\n  void 0 === b && (b = {});\n  var c = b.material,\n    d = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator,\n    e,\n    f,\n    g,\n    h = this.vertices.length;\n  e = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);\n  var i = e.shape,\n    k = e.holes;\n  if (!THREE.Shape.Utils.isClockWise(i)) {\n    i = i.reverse();\n    e = 0;\n    for (f = k.length; e < f; e++) g = k[e], THREE.Shape.Utils.isClockWise(g) && (k[e] = g.reverse());\n  }\n  var l = THREE.Shape.Utils.triangulateShape(i, k);\n  e = 0;\n  for (f = k.length; e < f; e++) g = k[e], i = i.concat(g);\n  k = i.length;\n  f = l.length;\n  for (e = 0; e < k; e++) g = i[e], this.vertices.push(new THREE.Vector3(g.x, g.y, 0));\n  for (e = 0; e < f; e++) k = l[e], i = k[0] + h, g = k[1] + h, k = k[2] + h, this.faces.push(new THREE.Face3(i, g, k, null, null, c)), this.faceVertexUvs[0].push(d.generateBottomUV(this, a, b, i, g, k));\n};\nTHREE.LatheGeometry = function (a, b, c, d) {\n  THREE.Geometry.call(this);\n  for (var b = b || 12, c = c || 0, d = d || 2 * Math.PI, e = 1 / (a.length - 1), f = 1 / b, g = 0, h = b; g <= h; g++) for (var i = c + g * f * d, k = Math.cos(i), l = Math.sin(i), i = 0, m = a.length; i < m; i++) {\n    var n = a[i],\n      s = new THREE.Vector3();\n    s.x = k * n.x - l * n.y;\n    s.y = l * n.x + k * n.y;\n    s.z = n.z;\n    this.vertices.push(s);\n  }\n  c = a.length;\n  g = 0;\n  for (h = b; g < h; g++) {\n    i = 0;\n    for (m = a.length - 1; i < m; i++) d = b = i + c * g, l = b + c, k = b + 1 + c, this.faces.push(new THREE.Face4(d, l, k, b + 1)), k = g * f, b = i * e, d = k + f, l = b + e, this.faceVertexUvs[0].push([new THREE.Vector2(k, b), new THREE.Vector2(d, b), new THREE.Vector2(d, l), new THREE.Vector2(k, l)]);\n  }\n  this.mergeVertices();\n  this.computeCentroids();\n  this.computeFaceNormals();\n  this.computeVertexNormals();\n};\nTHREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.PlaneGeometry = function (a, b, c, d) {\n  THREE.Geometry.call(this);\n  this.width = a;\n  this.height = b;\n  this.widthSegments = c || 1;\n  this.heightSegments = d || 1;\n  for (var c = a / 2, e = b / 2, d = this.widthSegments, f = this.heightSegments, g = d + 1, h = f + 1, i = this.width / d, k = this.height / f, l = new THREE.Vector3(0, 0, 1), a = 0; a < h; a++) for (b = 0; b < g; b++) this.vertices.push(new THREE.Vector3(b * i - c, -(a * k - e), 0));\n  for (a = 0; a < f; a++) for (b = 0; b < d; b++) c = new THREE.Face4(b + g * a, b + g * (a + 1), b + 1 + g * (a + 1), b + 1 + g * a), c.normal.copy(l), c.vertexNormals.push(l.clone(), l.clone(), l.clone(), l.clone()), this.faces.push(c), this.faceVertexUvs[0].push([new THREE.Vector2(b / d, 1 - a / f), new THREE.Vector2(b / d, 1 - (a + 1) / f), new THREE.Vector2((b + 1) / d, 1 - (a + 1) / f), new THREE.Vector2((b + 1) / d, 1 - a / f)]);\n  this.computeCentroids();\n};\nTHREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.SphereGeometry = function (a, b, c, d, e, f, g) {\n  THREE.Geometry.call(this);\n  this.radius = a || 50;\n  this.widthSegments = Math.max(3, Math.floor(b) || 8);\n  this.heightSegments = Math.max(2, Math.floor(c) || 6);\n  for (var d = void 0 !== d ? d : 0, e = void 0 !== e ? e : 2 * Math.PI, f = void 0 !== f ? f : 0, g = void 0 !== g ? g : Math.PI, h = [], i = [], c = 0; c <= this.heightSegments; c++) {\n    for (var k = [], l = [], b = 0; b <= this.widthSegments; b++) {\n      var m = b / this.widthSegments,\n        n = c / this.heightSegments,\n        s = new THREE.Vector3();\n      s.x = -this.radius * Math.cos(d + m * e) * Math.sin(f + n * g);\n      s.y = this.radius * Math.cos(f + n * g);\n      s.z = this.radius * Math.sin(d + m * e) * Math.sin(f + n * g);\n      this.vertices.push(s);\n      k.push(this.vertices.length - 1);\n      l.push(new THREE.Vector2(m, 1 - n));\n    }\n    h.push(k);\n    i.push(l);\n  }\n  for (c = 0; c < this.heightSegments; c++) for (b = 0; b < this.widthSegments; b++) {\n    var d = h[c][b + 1],\n      e = h[c][b],\n      f = h[c + 1][b],\n      g = h[c + 1][b + 1],\n      k = this.vertices[d].clone().normalize(),\n      l = this.vertices[e].clone().normalize(),\n      m = this.vertices[f].clone().normalize(),\n      n = this.vertices[g].clone().normalize(),\n      s = i[c][b + 1].clone(),\n      r = i[c][b].clone(),\n      p = i[c + 1][b].clone(),\n      q = i[c + 1][b + 1].clone();\n    Math.abs(this.vertices[d].y) === this.radius ? (this.faces.push(new THREE.Face3(d, f, g, [k, m, n])), this.faceVertexUvs[0].push([s, p, q])) : Math.abs(this.vertices[f].y) === this.radius ? (this.faces.push(new THREE.Face3(d, e, f, [k, l, m])), this.faceVertexUvs[0].push([s, r, p])) : (this.faces.push(new THREE.Face4(d, e, f, g, [k, l, m, n])), this.faceVertexUvs[0].push([s, r, p, q]));\n  }\n  this.computeCentroids();\n  this.computeFaceNormals();\n  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);\n};\nTHREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.TextGeometry = function (a, b) {\n  var c = THREE.FontUtils.generateShapes(a, b);\n  b.amount = void 0 !== b.height ? b.height : 50;\n  void 0 === b.bevelThickness && (b.bevelThickness = 10);\n  void 0 === b.bevelSize && (b.bevelSize = 8);\n  void 0 === b.bevelEnabled && (b.bevelEnabled = !1);\n  THREE.ExtrudeGeometry.call(this, c, b);\n};\nTHREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);\nTHREE.TorusGeometry = function (a, b, c, d, e) {\n  THREE.Geometry.call(this);\n  this.radius = a || 100;\n  this.tube = b || 40;\n  this.radialSegments = c || 8;\n  this.tubularSegments = d || 6;\n  this.arc = e || 2 * Math.PI;\n  e = new THREE.Vector3();\n  a = [];\n  b = [];\n  for (c = 0; c <= this.radialSegments; c++) for (d = 0; d <= this.tubularSegments; d++) {\n    var f = d / this.tubularSegments * this.arc,\n      g = 2 * c / this.radialSegments * Math.PI;\n    e.x = this.radius * Math.cos(f);\n    e.y = this.radius * Math.sin(f);\n    var h = new THREE.Vector3();\n    h.x = (this.radius + this.tube * Math.cos(g)) * Math.cos(f);\n    h.y = (this.radius + this.tube * Math.cos(g)) * Math.sin(f);\n    h.z = this.tube * Math.sin(g);\n    this.vertices.push(h);\n    a.push(new THREE.Vector2(d / this.tubularSegments, c / this.radialSegments));\n    b.push(h.clone().sub(e).normalize());\n  }\n  for (c = 1; c <= this.radialSegments; c++) for (d = 1; d <= this.tubularSegments; d++) {\n    var e = (this.tubularSegments + 1) * c + d - 1,\n      f = (this.tubularSegments + 1) * (c - 1) + d - 1,\n      g = (this.tubularSegments + 1) * (c - 1) + d,\n      h = (this.tubularSegments + 1) * c + d,\n      i = new THREE.Face4(e, f, g, h, [b[e], b[f], b[g], b[h]]);\n    i.normal.add(b[e]);\n    i.normal.add(b[f]);\n    i.normal.add(b[g]);\n    i.normal.add(b[h]);\n    i.normal.normalize();\n    this.faces.push(i);\n    this.faceVertexUvs[0].push([a[e].clone(), a[f].clone(), a[g].clone(), a[h].clone()]);\n  }\n  this.computeCentroids();\n};\nTHREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.TorusKnotGeometry = function (a, b, c, d, e, f, g) {\n  function h(a, b, c, d, e, f) {\n    var g = Math.cos(a);\n    Math.cos(b);\n    b = Math.sin(a);\n    a *= c / d;\n    c = Math.cos(a);\n    g *= 0.5 * e * (2 + c);\n    b = 0.5 * e * (2 + c) * b;\n    e = 0.5 * f * e * Math.sin(a);\n    return new THREE.Vector3(g, b, e);\n  }\n  THREE.Geometry.call(this);\n  this.radius = a || 100;\n  this.tube = b || 40;\n  this.radialSegments = c || 64;\n  this.tubularSegments = d || 8;\n  this.p = e || 2;\n  this.q = f || 3;\n  this.heightScale = g || 1;\n  this.grid = Array(this.radialSegments);\n  c = new THREE.Vector3();\n  d = new THREE.Vector3();\n  e = new THREE.Vector3();\n  for (a = 0; a < this.radialSegments; ++a) {\n    this.grid[a] = Array(this.tubularSegments);\n    for (b = 0; b < this.tubularSegments; ++b) {\n      var i = 2 * (a / this.radialSegments) * this.p * Math.PI,\n        g = 2 * (b / this.tubularSegments) * Math.PI,\n        f = h(i, g, this.q, this.p, this.radius, this.heightScale),\n        i = h(i + 0.01, g, this.q, this.p, this.radius, this.heightScale);\n      c.subVectors(i, f);\n      d.addVectors(i, f);\n      e.crossVectors(c, d);\n      d.crossVectors(e, c);\n      e.normalize();\n      d.normalize();\n      i = -this.tube * Math.cos(g);\n      g = this.tube * Math.sin(g);\n      f.x += i * d.x + g * e.x;\n      f.y += i * d.y + g * e.y;\n      f.z += i * d.z + g * e.z;\n      this.grid[a][b] = this.vertices.push(new THREE.Vector3(f.x, f.y, f.z)) - 1;\n    }\n  }\n  for (a = 0; a < this.radialSegments; ++a) for (b = 0; b < this.tubularSegments; ++b) {\n    var e = (a + 1) % this.radialSegments,\n      f = (b + 1) % this.tubularSegments,\n      c = this.grid[a][b],\n      d = this.grid[e][b],\n      e = this.grid[e][f],\n      f = this.grid[a][f],\n      g = new THREE.Vector2(a / this.radialSegments, b / this.tubularSegments),\n      i = new THREE.Vector2((a + 1) / this.radialSegments, b / this.tubularSegments),\n      k = new THREE.Vector2((a + 1) / this.radialSegments, (b + 1) / this.tubularSegments),\n      l = new THREE.Vector2(a / this.radialSegments, (b + 1) / this.tubularSegments);\n    this.faces.push(new THREE.Face4(c, d, e, f));\n    this.faceVertexUvs[0].push([g, i, k, l]);\n  }\n  this.computeCentroids();\n  this.computeFaceNormals();\n  this.computeVertexNormals();\n};\nTHREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.TubeGeometry = function (a, b, c, d, e, f) {\n  THREE.Geometry.call(this);\n  this.path = a;\n  this.segments = b || 64;\n  this.radius = c || 1;\n  this.radiusSegments = d || 8;\n  this.closed = e || !1;\n  f && (this.debug = new THREE.Object3D());\n  this.grid = [];\n  var g,\n    h,\n    e = this.segments + 1,\n    i,\n    k,\n    l,\n    f = new THREE.Vector3(),\n    m,\n    n,\n    s,\n    b = new THREE.TubeGeometry.FrenetFrames(this.path, this.segments, this.closed);\n  m = b.tangents;\n  n = b.normals;\n  s = b.binormals;\n  this.tangents = m;\n  this.normals = n;\n  this.binormals = s;\n  for (b = 0; b < e; b++) {\n    this.grid[b] = [];\n    d = b / (e - 1);\n    l = a.getPointAt(d);\n    d = m[b];\n    g = n[b];\n    h = s[b];\n    this.debug && (this.debug.add(new THREE.ArrowHelper(d, l, c, 255)), this.debug.add(new THREE.ArrowHelper(g, l, c, 16711680)), this.debug.add(new THREE.ArrowHelper(h, l, c, 65280)));\n    for (d = 0; d < this.radiusSegments; d++) i = 2 * (d / this.radiusSegments) * Math.PI, k = -this.radius * Math.cos(i), i = this.radius * Math.sin(i), f.copy(l), f.x += k * g.x + i * h.x, f.y += k * g.y + i * h.y, f.z += k * g.z + i * h.z, this.grid[b][d] = this.vertices.push(new THREE.Vector3(f.x, f.y, f.z)) - 1;\n  }\n  for (b = 0; b < this.segments; b++) for (d = 0; d < this.radiusSegments; d++) e = this.closed ? (b + 1) % this.segments : b + 1, f = (d + 1) % this.radiusSegments, a = this.grid[b][d], c = this.grid[e][d], e = this.grid[e][f], f = this.grid[b][f], m = new THREE.Vector2(b / this.segments, d / this.radiusSegments), n = new THREE.Vector2((b + 1) / this.segments, d / this.radiusSegments), s = new THREE.Vector2((b + 1) / this.segments, (d + 1) / this.radiusSegments), g = new THREE.Vector2(b / this.segments, (d + 1) / this.radiusSegments), this.faces.push(new THREE.Face4(a, c, e, f)), this.faceVertexUvs[0].push([m, n, s, g]);\n  this.computeCentroids();\n  this.computeFaceNormals();\n  this.computeVertexNormals();\n};\nTHREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.TubeGeometry.FrenetFrames = function (a, b, c) {\n  new THREE.Vector3();\n  var d = new THREE.Vector3();\n  new THREE.Vector3();\n  var e = [],\n    f = [],\n    g = [],\n    h = new THREE.Vector3(),\n    i = new THREE.Matrix4(),\n    b = b + 1,\n    k,\n    l,\n    m;\n  this.tangents = e;\n  this.normals = f;\n  this.binormals = g;\n  for (k = 0; k < b; k++) l = k / (b - 1), e[k] = a.getTangentAt(l), e[k].normalize();\n  f[0] = new THREE.Vector3();\n  g[0] = new THREE.Vector3();\n  a = Number.MAX_VALUE;\n  k = Math.abs(e[0].x);\n  l = Math.abs(e[0].y);\n  m = Math.abs(e[0].z);\n  k <= a && (a = k, d.set(1, 0, 0));\n  l <= a && (a = l, d.set(0, 1, 0));\n  m <= a && d.set(0, 0, 1);\n  h.crossVectors(e[0], d).normalize();\n  f[0].crossVectors(e[0], h);\n  g[0].crossVectors(e[0], f[0]);\n  for (k = 1; k < b; k++) f[k] = f[k - 1].clone(), g[k] = g[k - 1].clone(), h.crossVectors(e[k - 1], e[k]), 1E-4 < h.length() && (h.normalize(), d = Math.acos(e[k - 1].dot(e[k])), f[k].applyMatrix4(i.makeRotationAxis(h, d))), g[k].crossVectors(e[k], f[k]);\n  if (c) {\n    d = Math.acos(f[0].dot(f[b - 1]));\n    d /= b - 1;\n    0 < e[0].dot(h.crossVectors(f[0], f[b - 1])) && (d = -d);\n    for (k = 1; k < b; k++) f[k].applyMatrix4(i.makeRotationAxis(e[k], d * k)), g[k].crossVectors(e[k], f[k]);\n  }\n};\nTHREE.PolyhedronGeometry = function (a, b, c, d) {\n  function e(a) {\n    var b = a.normalize().clone();\n    b.index = i.vertices.push(b) - 1;\n    var c = Math.atan2(a.z, -a.x) / 2 / Math.PI + 0.5,\n      a = Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + 0.5;\n    b.uv = new THREE.Vector2(c, 1 - a);\n    return b;\n  }\n  function f(a, b, c, d) {\n    1 > d ? (d = new THREE.Face3(a.index, b.index, c.index, [a.clone(), b.clone(), c.clone()]), d.centroid.add(a).add(b).add(c).divideScalar(3), d.normal = d.centroid.clone().normalize(), i.faces.push(d), d = Math.atan2(d.centroid.z, -d.centroid.x), i.faceVertexUvs[0].push([h(a.uv, a, d), h(b.uv, b, d), h(c.uv, c, d)])) : (d -= 1, f(a, g(a, b), g(a, c), d), f(g(a, b), b, g(b, c), d), f(g(a, c), g(b, c), c, d), f(g(a, b), g(b, c), g(a, c), d));\n  }\n  function g(a, b) {\n    m[a.index] || (m[a.index] = []);\n    m[b.index] || (m[b.index] = []);\n    var c = m[a.index][b.index];\n    void 0 === c && (m[a.index][b.index] = m[b.index][a.index] = c = e(new THREE.Vector3().addVectors(a, b).divideScalar(2)));\n    return c;\n  }\n  function h(a, b, c) {\n    0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y));\n    0 === b.x && 0 === b.z && (a = new THREE.Vector2(c / 2 / Math.PI + 0.5, a.y));\n    return a;\n  }\n  THREE.Geometry.call(this);\n  for (var c = c || 1, d = d || 0, i = this, k = 0, l = a.length; k < l; k++) e(new THREE.Vector3(a[k][0], a[k][1], a[k][2]));\n  for (var m = [], a = this.vertices, k = 0, l = b.length; k < l; k++) f(a[b[k][0]], a[b[k][1]], a[b[k][2]], d);\n  this.mergeVertices();\n  k = 0;\n  for (l = this.vertices.length; k < l; k++) this.vertices[k].multiplyScalar(c);\n  this.computeCentroids();\n  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), c);\n};\nTHREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.IcosahedronGeometry = function (a, b) {\n  var c = (1 + Math.sqrt(5)) / 2;\n  THREE.PolyhedronGeometry.call(this, [[-1, c, 0], [1, c, 0], [-1, -c, 0], [1, -c, 0], [0, -1, c], [0, 1, c], [0, -1, -c], [0, 1, -c], [c, 0, -1], [c, 0, 1], [-c, 0, -1], [-c, 0, 1]], [[0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11], [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8], [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9], [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]], a, b);\n};\nTHREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.OctahedronGeometry = function (a, b) {\n  THREE.PolyhedronGeometry.call(this, [[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]], [[0, 2, 4], [0, 4, 3], [0, 3, 5], [0, 5, 2], [1, 2, 5], [1, 5, 3], [1, 3, 4], [1, 4, 2]], a, b);\n};\nTHREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.TetrahedronGeometry = function (a, b) {\n  THREE.PolyhedronGeometry.call(this, [[1, 1, 1], [-1, -1, 1], [-1, 1, -1], [1, -1, -1]], [[2, 1, 0], [0, 3, 2], [1, 3, 0], [2, 3, 1]], a, b);\n};\nTHREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.ParametricGeometry = function (a, b, c, d) {\n  THREE.Geometry.call(this);\n  var e = this.vertices,\n    f = this.faces,\n    g = this.faceVertexUvs[0],\n    d = void 0 === d ? !1 : d,\n    h,\n    i,\n    k,\n    l,\n    m = b + 1;\n  for (h = 0; h <= c; h++) {\n    l = h / c;\n    for (i = 0; i <= b; i++) k = i / b, k = a(k, l), e.push(k);\n  }\n  var n, s, r, p;\n  for (h = 0; h < c; h++) for (i = 0; i < b; i++) a = h * m + i, e = h * m + i + 1, l = (h + 1) * m + i, k = (h + 1) * m + i + 1, n = new THREE.Vector2(i / b, h / c), s = new THREE.Vector2((i + 1) / b, h / c), r = new THREE.Vector2(i / b, (h + 1) / c), p = new THREE.Vector2((i + 1) / b, (h + 1) / c), d ? (f.push(new THREE.Face3(a, e, l)), f.push(new THREE.Face3(e, k, l)), g.push([n, s, r]), g.push([s, p, r])) : (f.push(new THREE.Face4(a, e, k, l)), g.push([n, s, p, r]));\n  this.computeCentroids();\n  this.computeFaceNormals();\n  this.computeVertexNormals();\n};\nTHREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.ConvexGeometry = function (a) {\n  function b(a) {\n    var b = a.length();\n    return new THREE.Vector2(a.x / b, a.y / b);\n  }\n  THREE.Geometry.call(this);\n  for (var c = [[0, 1, 2], [0, 2, 1]], d = 3; d < a.length; d++) {\n    var e = d,\n      f = a[e].clone(),\n      g = f.length();\n    f.x += g * 2E-6 * (Math.random() - 0.5);\n    f.y += g * 2E-6 * (Math.random() - 0.5);\n    f.z += g * 2E-6 * (Math.random() - 0.5);\n    for (var g = [], h = 0; h < c.length;) {\n      var i = c[h],\n        k = f,\n        l = a[i[0]],\n        m;\n      m = l;\n      var n = a[i[1]],\n        s = a[i[2]],\n        r = new THREE.Vector3(),\n        p = new THREE.Vector3();\n      r.subVectors(s, n);\n      p.subVectors(m, n);\n      r.cross(p);\n      r.normalize();\n      m = r;\n      l = m.dot(l);\n      if (m.dot(k) >= l) {\n        for (k = 0; 3 > k; k++) {\n          l = [i[k], i[(k + 1) % 3]];\n          m = !0;\n          for (n = 0; n < g.length; n++) if (g[n][0] === l[1] && g[n][1] === l[0]) {\n            g[n] = g[g.length - 1];\n            g.pop();\n            m = !1;\n            break;\n          }\n          m && g.push(l);\n        }\n        c[h] = c[c.length - 1];\n        c.pop();\n      } else h++;\n    }\n    for (n = 0; n < g.length; n++) c.push([g[n][0], g[n][1], e]);\n  }\n  e = 0;\n  f = Array(a.length);\n  for (d = 0; d < c.length; d++) {\n    g = c[d];\n    for (h = 0; 3 > h; h++) void 0 === f[g[h]] && (f[g[h]] = e++, this.vertices.push(a[g[h]])), g[h] = f[g[h]];\n  }\n  for (d = 0; d < c.length; d++) this.faces.push(new THREE.Face3(c[d][0], c[d][1], c[d][2]));\n  for (d = 0; d < this.faces.length; d++) g = this.faces[d], this.faceVertexUvs[0].push([b(this.vertices[g.a]), b(this.vertices[g.b]), b(this.vertices[g.c])]);\n  this.computeCentroids();\n  this.computeFaceNormals();\n  this.computeVertexNormals();\n};\nTHREE.ConvexGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.AxisHelper = function (a) {\n  var b = new THREE.Geometry();\n  b.vertices.push(new THREE.Vector3(), new THREE.Vector3(a || 1, 0, 0), new THREE.Vector3(), new THREE.Vector3(0, a || 1, 0), new THREE.Vector3(), new THREE.Vector3(0, 0, a || 1));\n  b.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775));\n  a = new THREE.LineBasicMaterial({\n    vertexColors: THREE.VertexColors\n  });\n  THREE.Line.call(this, b, a, THREE.LinePieces);\n};\nTHREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);\nTHREE.ArrowHelper = function (a, b, c, d) {\n  THREE.Object3D.call(this);\n  void 0 === c && (c = 20);\n  void 0 === d && (d = 16776960);\n  var e = new THREE.Geometry();\n  e.vertices.push(new THREE.Vector3(0, 0, 0));\n  e.vertices.push(new THREE.Vector3(0, 1, 0));\n  this.line = new THREE.Line(e, new THREE.LineBasicMaterial({\n    color: d\n  }));\n  this.add(this.line);\n  e = new THREE.CylinderGeometry(0, 0.05, 0.25, 5, 1);\n  this.cone = new THREE.Mesh(e, new THREE.MeshBasicMaterial({\n    color: d\n  }));\n  this.cone.position.set(0, 1, 0);\n  this.add(this.cone);\n  b instanceof THREE.Vector3 && (this.position = b);\n  this.setDirection(a);\n  this.setLength(c);\n};\nTHREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.ArrowHelper.prototype.setDirection = function (a) {\n  var b = THREE.ArrowHelper.__v1.copy(a).normalize();\n  0.999 < b.y ? this.rotation.set(0, 0, 0) : -0.999 > b.y ? this.rotation.set(Math.PI, 0, 0) : (a = THREE.ArrowHelper.__v2.set(b.z, 0, -b.x).normalize(), b = Math.acos(b.y), a = THREE.ArrowHelper.__q1.setFromAxisAngle(a, b), this.rotation.setEulerFromQuaternion(a, this.eulerOrder));\n};\nTHREE.ArrowHelper.prototype.setLength = function (a) {\n  this.scale.set(a, a, a);\n};\nTHREE.ArrowHelper.prototype.setColor = function (a) {\n  this.line.material.color.setHex(a);\n  this.cone.material.color.setHex(a);\n};\nTHREE.ArrowHelper.__v1 = new THREE.Vector3();\nTHREE.ArrowHelper.__v2 = new THREE.Vector3();\nTHREE.ArrowHelper.__q1 = new THREE.Quaternion();\nTHREE.CameraHelper = function (a) {\n  function b(a, b, d) {\n    c(a, d);\n    c(b, d);\n  }\n  function c(a, b) {\n    d.geometry.vertices.push(new THREE.Vector3());\n    d.geometry.colors.push(new THREE.Color(b));\n    void 0 === d.pointMap[a] && (d.pointMap[a] = []);\n    d.pointMap[a].push(d.geometry.vertices.length - 1);\n  }\n  THREE.Line.call(this);\n  var d = this;\n  this.geometry = new THREE.Geometry();\n  this.material = new THREE.LineBasicMaterial({\n    color: 16777215,\n    vertexColors: THREE.FaceColors\n  });\n  this.type = THREE.LinePieces;\n  this.matrixWorld = a.matrixWorld;\n  this.matrixAutoUpdate = !1;\n  this.pointMap = {};\n  b(\"n1\", \"n2\", 16755200);\n  b(\"n2\", \"n4\", 16755200);\n  b(\"n4\", \"n3\", 16755200);\n  b(\"n3\", \"n1\", 16755200);\n  b(\"f1\", \"f2\", 16755200);\n  b(\"f2\", \"f4\", 16755200);\n  b(\"f4\", \"f3\", 16755200);\n  b(\"f3\", \"f1\", 16755200);\n  b(\"n1\", \"f1\", 16755200);\n  b(\"n2\", \"f2\", 16755200);\n  b(\"n3\", \"f3\", 16755200);\n  b(\"n4\", \"f4\", 16755200);\n  b(\"p\", \"n1\", 16711680);\n  b(\"p\", \"n2\", 16711680);\n  b(\"p\", \"n3\", 16711680);\n  b(\"p\", \"n4\", 16711680);\n  b(\"u1\", \"u2\", 43775);\n  b(\"u2\", \"u3\", 43775);\n  b(\"u3\", \"u1\", 43775);\n  b(\"c\", \"t\", 16777215);\n  b(\"p\", \"c\", 3355443);\n  b(\"cn1\", \"cn2\", 3355443);\n  b(\"cn3\", \"cn4\", 3355443);\n  b(\"cf1\", \"cf2\", 3355443);\n  b(\"cf3\", \"cf4\", 3355443);\n  this.camera = a;\n  this.update(a);\n};\nTHREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);\nTHREE.CameraHelper.prototype.update = function () {\n  function a(a, d, e, f) {\n    THREE.CameraHelper.__v.set(d, e, f);\n    THREE.CameraHelper.__projector.unprojectVector(THREE.CameraHelper.__v, THREE.CameraHelper.__c);\n    a = b.pointMap[a];\n    if (void 0 !== a) {\n      d = 0;\n      for (e = a.length; d < e; d++) b.geometry.vertices[a[d]].copy(THREE.CameraHelper.__v);\n    }\n  }\n  var b = this;\n  THREE.CameraHelper.__c.projectionMatrix.copy(this.camera.projectionMatrix);\n  a(\"c\", 0, 0, -1);\n  a(\"t\", 0, 0, 1);\n  a(\"n1\", -1, -1, -1);\n  a(\"n2\", 1, -1, -1);\n  a(\"n3\", -1, 1, -1);\n  a(\"n4\", 1, 1, -1);\n  a(\"f1\", -1, -1, 1);\n  a(\"f2\", 1, -1, 1);\n  a(\"f3\", -1, 1, 1);\n  a(\"f4\", 1, 1, 1);\n  a(\"u1\", 0.7, 1.1, -1);\n  a(\"u2\", -0.7, 1.1, -1);\n  a(\"u3\", 0, 2, -1);\n  a(\"cf1\", -1, 0, 1);\n  a(\"cf2\", 1, 0, 1);\n  a(\"cf3\", 0, -1, 1);\n  a(\"cf4\", 0, 1, 1);\n  a(\"cn1\", -1, 0, -1);\n  a(\"cn2\", 1, 0, -1);\n  a(\"cn3\", 0, -1, -1);\n  a(\"cn4\", 0, 1, -1);\n  this.geometry.verticesNeedUpdate = !0;\n};\nTHREE.CameraHelper.__projector = new THREE.Projector();\nTHREE.CameraHelper.__v = new THREE.Vector3();\nTHREE.CameraHelper.__c = new THREE.Camera();\nTHREE.DirectionalLightHelper = function (a, b) {\n  THREE.Object3D.call(this);\n  this.light = a;\n  this.position = a.position;\n  this.direction = new THREE.Vector3();\n  this.direction.subVectors(a.target.position, a.position);\n  var c = THREE.Math.clamp(a.intensity, 0, 1);\n  this.color = a.color.clone();\n  this.color.multiplyScalar(c);\n  var c = this.color.getHex(),\n    d = new THREE.SphereGeometry(b, 16, 8),\n    e = new THREE.AsteriskGeometry(1.25 * b, 2.25 * b),\n    f = new THREE.MeshBasicMaterial({\n      color: c,\n      fog: !1\n    }),\n    g = new THREE.LineBasicMaterial({\n      color: c,\n      fog: !1\n    });\n  this.lightSphere = new THREE.Mesh(d, f);\n  this.lightRays = new THREE.Line(e, g, THREE.LinePieces);\n  this.add(this.lightSphere);\n  this.add(this.lightRays);\n  this.lightSphere.properties.isGizmo = !0;\n  this.lightSphere.properties.gizmoSubject = a;\n  this.lightSphere.properties.gizmoRoot = this;\n  this.targetSphere = null;\n  void 0 !== a.target.properties.targetInverse && (d = new THREE.SphereGeometry(b, 8, 4), e = new THREE.MeshBasicMaterial({\n    color: c,\n    wireframe: !0,\n    fog: !1\n  }), this.targetSphere = new THREE.Mesh(d, e), this.targetSphere.position = a.target.position, this.targetSphere.properties.isGizmo = !0, this.targetSphere.properties.gizmoSubject = a.target, this.targetSphere.properties.gizmoRoot = this.targetSphere, c = new THREE.LineDashedMaterial({\n    color: c,\n    dashSize: 4,\n    gapSize: 4,\n    opacity: 0.75,\n    transparent: !0,\n    fog: !1\n  }), d = new THREE.Geometry(), d.vertices.push(this.position.clone()), d.vertices.push(this.targetSphere.position.clone()), d.computeLineDistances(), this.targetLine = new THREE.Line(d, c), this.targetLine.properties.isGizmo = !0);\n  this.properties.isGizmo = !0;\n};\nTHREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.DirectionalLightHelper.prototype.update = function () {\n  this.direction.subVectors(this.light.target.position, this.light.position);\n  var a = THREE.Math.clamp(this.light.intensity, 0, 1);\n  this.color.copy(this.light.color);\n  this.color.multiplyScalar(a);\n  this.lightSphere.material.color.copy(this.color);\n  this.lightRays.material.color.copy(this.color);\n  null !== this.targetSphere && (this.targetSphere.material.color.copy(this.color), this.targetLine.material.color.copy(this.color), this.targetLine.geometry.vertices[0].copy(this.light.position), this.targetLine.geometry.vertices[1].copy(this.light.target.position), this.targetLine.geometry.computeLineDistances(), this.targetLine.geometry.verticesNeedUpdate = !0);\n};\nTHREE.HemisphereLightHelper = function (a, b, c) {\n  THREE.Object3D.call(this);\n  this.light = a;\n  this.position = a.position;\n  var d = THREE.Math.clamp(a.intensity, 0, 1);\n  this.color = a.color.clone();\n  this.color.multiplyScalar(d);\n  var e = this.color.getHex();\n  this.groundColor = a.groundColor.clone();\n  this.groundColor.multiplyScalar(d);\n  for (var d = this.groundColor.getHex(), f = new THREE.SphereGeometry(b, 16, 8, 0, 2 * Math.PI, 0, 0.5 * Math.PI), g = new THREE.SphereGeometry(b, 16, 8, 0, 2 * Math.PI, 0.5 * Math.PI, Math.PI), h = new THREE.MeshBasicMaterial({\n      color: e,\n      fog: !1\n    }), i = new THREE.MeshBasicMaterial({\n      color: d,\n      fog: !1\n    }), k = 0, l = f.faces.length; k < l; k++) f.faces[k].materialIndex = 0;\n  k = 0;\n  for (l = g.faces.length; k < l; k++) g.faces[k].materialIndex = 1;\n  THREE.GeometryUtils.merge(f, g);\n  this.lightSphere = new THREE.Mesh(f, new THREE.MeshFaceMaterial([h, i]));\n  this.lightArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1.1 * (b + c), 0), c, e);\n  this.lightArrow.rotation.x = Math.PI;\n  this.lightArrowGround = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1.1 * (b + c), 0), c, d);\n  b = new THREE.Object3D();\n  b.rotation.x = 0.5 * -Math.PI;\n  b.add(this.lightSphere);\n  b.add(this.lightArrow);\n  b.add(this.lightArrowGround);\n  this.add(b);\n  this.lightSphere.properties.isGizmo = !0;\n  this.lightSphere.properties.gizmoSubject = a;\n  this.lightSphere.properties.gizmoRoot = this;\n  this.properties.isGizmo = !0;\n  this.target = new THREE.Vector3();\n  this.lookAt(this.target);\n};\nTHREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.HemisphereLightHelper.prototype.update = function () {\n  var a = THREE.Math.clamp(this.light.intensity, 0, 1);\n  this.color.copy(this.light.color);\n  this.color.multiplyScalar(a);\n  this.groundColor.copy(this.light.groundColor);\n  this.groundColor.multiplyScalar(a);\n  this.lightSphere.material.materials[0].color.copy(this.color);\n  this.lightSphere.material.materials[1].color.copy(this.groundColor);\n  this.lightArrow.setColor(this.color.getHex());\n  this.lightArrowGround.setColor(this.groundColor.getHex());\n  this.lookAt(this.target);\n};\nTHREE.PointLightHelper = function (a, b) {\n  THREE.Object3D.call(this);\n  this.light = a;\n  this.position = a.position;\n  var c = THREE.Math.clamp(a.intensity, 0, 1);\n  this.color = a.color.clone();\n  this.color.multiplyScalar(c);\n  var d = this.color.getHex(),\n    c = new THREE.SphereGeometry(b, 16, 8),\n    e = new THREE.AsteriskGeometry(1.25 * b, 2.25 * b),\n    f = new THREE.IcosahedronGeometry(1, 2),\n    g = new THREE.MeshBasicMaterial({\n      color: d,\n      fog: !1\n    }),\n    h = new THREE.LineBasicMaterial({\n      color: d,\n      fog: !1\n    }),\n    d = new THREE.MeshBasicMaterial({\n      color: d,\n      fog: !1,\n      wireframe: !0,\n      opacity: 0.1,\n      transparent: !0\n    });\n  this.lightSphere = new THREE.Mesh(c, g);\n  this.lightRays = new THREE.Line(e, h, THREE.LinePieces);\n  this.lightDistance = new THREE.Mesh(f, d);\n  c = a.distance;\n  0 === c ? this.lightDistance.visible = !1 : this.lightDistance.scale.set(c, c, c);\n  this.add(this.lightSphere);\n  this.add(this.lightRays);\n  this.add(this.lightDistance);\n  this.lightSphere.properties.isGizmo = !0;\n  this.lightSphere.properties.gizmoSubject = a;\n  this.lightSphere.properties.gizmoRoot = this;\n  this.properties.isGizmo = !0;\n};\nTHREE.PointLightHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.PointLightHelper.prototype.update = function () {\n  var a = THREE.Math.clamp(this.light.intensity, 0, 1);\n  this.color.copy(this.light.color);\n  this.color.multiplyScalar(a);\n  this.lightSphere.material.color.copy(this.color);\n  this.lightRays.material.color.copy(this.color);\n  this.lightDistance.material.color.copy(this.color);\n  a = this.light.distance;\n  0 === a ? this.lightDistance.visible = !1 : (this.lightDistance.visible = !0, this.lightDistance.scale.set(a, a, a));\n};\nTHREE.SpotLightHelper = function (a, b) {\n  THREE.Object3D.call(this);\n  this.light = a;\n  this.position = a.position;\n  this.direction = new THREE.Vector3();\n  this.direction.subVectors(a.target.position, a.position);\n  var c = THREE.Math.clamp(a.intensity, 0, 1);\n  this.color = a.color.clone();\n  this.color.multiplyScalar(c);\n  var c = this.color.getHex(),\n    d = new THREE.SphereGeometry(b, 16, 8),\n    e = new THREE.AsteriskGeometry(1.25 * b, 2.25 * b),\n    f = new THREE.CylinderGeometry(1E-4, 1, 1, 8, 1, !0),\n    g = new THREE.Matrix4();\n  g.rotateX(-Math.PI / 2);\n  g.translate(new THREE.Vector3(0, -0.5, 0));\n  f.applyMatrix(g);\n  var h = new THREE.MeshBasicMaterial({\n      color: c,\n      fog: !1\n    }),\n    g = new THREE.LineBasicMaterial({\n      color: c,\n      fog: !1\n    }),\n    i = new THREE.MeshBasicMaterial({\n      color: c,\n      fog: !1,\n      wireframe: !0,\n      opacity: 0.3,\n      transparent: !0\n    });\n  this.lightSphere = new THREE.Mesh(d, h);\n  this.lightCone = new THREE.Mesh(f, i);\n  d = a.distance ? a.distance : 1E4;\n  f = 2 * d * Math.tan(0.5 * a.angle);\n  this.lightCone.scale.set(f, f, d);\n  this.lightRays = new THREE.Line(e, g, THREE.LinePieces);\n  this.gyroscope = new THREE.Gyroscope();\n  this.gyroscope.add(this.lightSphere);\n  this.gyroscope.add(this.lightRays);\n  this.add(this.gyroscope);\n  this.add(this.lightCone);\n  this.lookAt(a.target.position);\n  this.lightSphere.properties.isGizmo = !0;\n  this.lightSphere.properties.gizmoSubject = a;\n  this.lightSphere.properties.gizmoRoot = this;\n  this.targetSphere = null;\n  void 0 !== a.target.properties.targetInverse && (e = new THREE.SphereGeometry(b, 8, 4), g = new THREE.MeshBasicMaterial({\n    color: c,\n    wireframe: !0,\n    fog: !1\n  }), this.targetSphere = new THREE.Mesh(e, g), this.targetSphere.position = a.target.position, this.targetSphere.properties.isGizmo = !0, this.targetSphere.properties.gizmoSubject = a.target, this.targetSphere.properties.gizmoRoot = this.targetSphere, c = new THREE.LineDashedMaterial({\n    color: c,\n    dashSize: 4,\n    gapSize: 4,\n    opacity: 0.75,\n    transparent: !0,\n    fog: !1\n  }), e = new THREE.Geometry(), e.vertices.push(this.position.clone()), e.vertices.push(this.targetSphere.position.clone()), e.computeLineDistances(), this.targetLine = new THREE.Line(e, c), this.targetLine.properties.isGizmo = !0);\n  this.properties.isGizmo = !0;\n};\nTHREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.SpotLightHelper.prototype.update = function () {\n  this.direction.subVectors(this.light.target.position, this.light.position);\n  this.lookAt(this.light.target.position);\n  var a = this.light.distance ? this.light.distance : 1E4,\n    b = 2 * a * Math.tan(0.5 * this.light.angle);\n  this.lightCone.scale.set(b, b, a);\n  a = THREE.Math.clamp(this.light.intensity, 0, 1);\n  this.color.copy(this.light.color);\n  this.color.multiplyScalar(a);\n  this.lightSphere.material.color.copy(this.color);\n  this.lightRays.material.color.copy(this.color);\n  this.lightCone.material.color.copy(this.color);\n  null !== this.targetSphere && (this.targetSphere.material.color.copy(this.color), this.targetLine.material.color.copy(this.color), this.targetLine.geometry.vertices[0].copy(this.light.position), this.targetLine.geometry.vertices[1].copy(this.light.target.position), this.targetLine.geometry.computeLineDistances(), this.targetLine.geometry.verticesNeedUpdate = !0);\n};\nTHREE.ImmediateRenderObject = function () {\n  THREE.Object3D.call(this);\n  this.render = function () {};\n};\nTHREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.LensFlare = function (a, b, c, d, e) {\n  THREE.Object3D.call(this);\n  this.lensFlares = [];\n  this.positionScreen = new THREE.Vector3();\n  this.customUpdateCallback = void 0;\n  void 0 !== a && this.add(a, b, c, d, e);\n};\nTHREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.LensFlare.prototype.add = function (a, b, c, d, e, f) {\n  void 0 === b && (b = -1);\n  void 0 === c && (c = 0);\n  void 0 === f && (f = 1);\n  void 0 === e && (e = new THREE.Color(16777215));\n  void 0 === d && (d = THREE.NormalBlending);\n  c = Math.min(c, Math.max(0, c));\n  this.lensFlares.push({\n    texture: a,\n    size: b,\n    distance: c,\n    x: 0,\n    y: 0,\n    z: 0,\n    scale: 1,\n    rotation: 1,\n    opacity: f,\n    color: e,\n    blending: d\n  });\n};\nTHREE.LensFlare.prototype.updateLensFlares = function () {\n  var a,\n    b = this.lensFlares.length,\n    c,\n    d = 2 * -this.positionScreen.x,\n    e = 2 * -this.positionScreen.y;\n  for (a = 0; a < b; a++) c = this.lensFlares[a], c.x = this.positionScreen.x + d * c.distance, c.y = this.positionScreen.y + e * c.distance, c.wantedRotation = 0.25 * c.x * Math.PI, c.rotation += 0.25 * (c.wantedRotation - c.rotation);\n};\nTHREE.MorphBlendMesh = function (a, b) {\n  THREE.Mesh.call(this, a, b);\n  this.animationsMap = {};\n  this.animationsList = [];\n  var c = this.geometry.morphTargets.length;\n  this.createAnimation(\"__default\", 0, c - 1, c / 1);\n  this.setAnimationWeight(\"__default\", 1);\n};\nTHREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.MorphBlendMesh.prototype.createAnimation = function (a, b, c, d) {\n  b = {\n    startFrame: b,\n    endFrame: c,\n    length: c - b + 1,\n    fps: d,\n    duration: (c - b) / d,\n    lastFrame: 0,\n    currentFrame: 0,\n    active: !1,\n    time: 0,\n    direction: 1,\n    weight: 1,\n    directionBackwards: !1,\n    mirroredLoop: !1\n  };\n  this.animationsMap[a] = b;\n  this.animationsList.push(b);\n};\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function (a) {\n  for (var b = /([a-z]+)(\\d+)/, c, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; f < g; f++) {\n    var h = e.morphTargets[f].name.match(b);\n    if (h && 1 < h.length) {\n      var i = h[1];\n      d[i] || (d[i] = {\n        start: Infinity,\n        end: -Infinity\n      });\n      h = d[i];\n      f < h.start && (h.start = f);\n      f > h.end && (h.end = f);\n      c || (c = i);\n    }\n  }\n  for (i in d) h = d[i], this.createAnimation(i, h.start, h.end, a);\n  this.firstAnimation = c;\n};\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (a) {\n  if (a = this.animationsMap[a]) a.direction = 1, a.directionBackwards = !1;\n};\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (a) {\n  if (a = this.animationsMap[a]) a.direction = -1, a.directionBackwards = !0;\n};\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function (a, b) {\n  var c = this.animationsMap[a];\n  c && (c.fps = b, c.duration = (c.end - c.start) / c.fps);\n};\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function (a, b) {\n  var c = this.animationsMap[a];\n  c && (c.duration = b, c.fps = (c.end - c.start) / c.duration);\n};\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function (a, b) {\n  var c = this.animationsMap[a];\n  c && (c.weight = b);\n};\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function (a, b) {\n  var c = this.animationsMap[a];\n  c && (c.time = b);\n};\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function (a) {\n  var b = 0;\n  if (a = this.animationsMap[a]) b = a.time;\n  return b;\n};\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function (a) {\n  var b = -1;\n  if (a = this.animationsMap[a]) b = a.duration;\n  return b;\n};\nTHREE.MorphBlendMesh.prototype.playAnimation = function (a) {\n  var b = this.animationsMap[a];\n  b ? (b.time = 0, b.active = !0) : console.warn(\"animation[\" + a + \"] undefined\");\n};\nTHREE.MorphBlendMesh.prototype.stopAnimation = function (a) {\n  if (a = this.animationsMap[a]) a.active = !1;\n};\nTHREE.MorphBlendMesh.prototype.update = function (a) {\n  for (var b = 0, c = this.animationsList.length; b < c; b++) {\n    var d = this.animationsList[b];\n    if (d.active) {\n      var e = d.duration / d.length;\n      d.time += d.direction * a;\n      if (d.mirroredLoop) {\n        if (d.time > d.duration || 0 > d.time) d.direction *= -1, d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, d.directionBackwards = !1);\n      } else d.time %= d.duration, 0 > d.time && (d.time += d.duration);\n      var f = d.startFrame + THREE.Math.clamp(Math.floor(d.time / e), 0, d.length - 1),\n        g = d.weight;\n      f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f);\n      e = d.time % e / e;\n      d.directionBackwards && (e = 1 - e);\n      this.morphTargetInfluences[d.currentFrame] = e * g;\n      this.morphTargetInfluences[d.lastFrame] = (1 - e) * g;\n    }\n  }\n};\nTHREE.LensFlarePlugin = function () {\n  function a(a, c) {\n    var d = b.createProgram(),\n      e = b.createShader(b.FRAGMENT_SHADER),\n      f = b.createShader(b.VERTEX_SHADER),\n      g = \"precision \" + c + \" float;\\n\";\n    b.shaderSource(e, g + a.fragmentShader);\n    b.shaderSource(f, g + a.vertexShader);\n    b.compileShader(e);\n    b.compileShader(f);\n    b.attachShader(d, e);\n    b.attachShader(d, f);\n    b.linkProgram(d);\n    return d;\n  }\n  var b, c, d, e, f, g, h, i, k, l, m, n, s;\n  this.init = function (r) {\n    b = r.context;\n    c = r;\n    d = r.getPrecision();\n    e = new Float32Array(16);\n    f = new Uint16Array(6);\n    r = 0;\n    e[r++] = -1;\n    e[r++] = -1;\n    e[r++] = 0;\n    e[r++] = 0;\n    e[r++] = 1;\n    e[r++] = -1;\n    e[r++] = 1;\n    e[r++] = 0;\n    e[r++] = 1;\n    e[r++] = 1;\n    e[r++] = 1;\n    e[r++] = 1;\n    e[r++] = -1;\n    e[r++] = 1;\n    e[r++] = 0;\n    e[r++] = 1;\n    r = 0;\n    f[r++] = 0;\n    f[r++] = 1;\n    f[r++] = 2;\n    f[r++] = 0;\n    f[r++] = 2;\n    f[r++] = 3;\n    g = b.createBuffer();\n    h = b.createBuffer();\n    b.bindBuffer(b.ARRAY_BUFFER, g);\n    b.bufferData(b.ARRAY_BUFFER, e, b.STATIC_DRAW);\n    b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, h);\n    b.bufferData(b.ELEMENT_ARRAY_BUFFER, f, b.STATIC_DRAW);\n    i = b.createTexture();\n    k = b.createTexture();\n    b.bindTexture(b.TEXTURE_2D, i);\n    b.texImage2D(b.TEXTURE_2D, 0, b.RGB, 16, 16, 0, b.RGB, b.UNSIGNED_BYTE, null);\n    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);\n    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);\n    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);\n    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);\n    b.bindTexture(b.TEXTURE_2D, k);\n    b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, 16, 16, 0, b.RGBA, b.UNSIGNED_BYTE, null);\n    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);\n    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);\n    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);\n    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);\n    0 >= b.getParameter(b.MAX_VERTEX_TEXTURE_IMAGE_UNITS) ? (l = !1, m = a(THREE.ShaderFlares.lensFlare, d)) : (l = !0, m = a(THREE.ShaderFlares.lensFlareVertexTexture, d));\n    n = {};\n    s = {};\n    n.vertex = b.getAttribLocation(m, \"position\");\n    n.uv = b.getAttribLocation(m, \"uv\");\n    s.renderType = b.getUniformLocation(m, \"renderType\");\n    s.map = b.getUniformLocation(m, \"map\");\n    s.occlusionMap = b.getUniformLocation(m, \"occlusionMap\");\n    s.opacity = b.getUniformLocation(m, \"opacity\");\n    s.color = b.getUniformLocation(m, \"color\");\n    s.scale = b.getUniformLocation(m, \"scale\");\n    s.rotation = b.getUniformLocation(m, \"rotation\");\n    s.screenPosition = b.getUniformLocation(m, \"screenPosition\");\n  };\n  this.render = function (a, d, e, f) {\n    var a = a.__webglFlares,\n      v = a.length;\n    if (v) {\n      var z = new THREE.Vector3(),\n        t = f / e,\n        A = 0.5 * e,\n        I = 0.5 * f,\n        C = 16 / f,\n        x = new THREE.Vector2(C * t, C),\n        G = new THREE.Vector3(1, 1, 0),\n        J = new THREE.Vector2(1, 1),\n        E = s,\n        C = n;\n      b.useProgram(m);\n      b.enableVertexAttribArray(n.vertex);\n      b.enableVertexAttribArray(n.uv);\n      b.uniform1i(E.occlusionMap, 0);\n      b.uniform1i(E.map, 1);\n      b.bindBuffer(b.ARRAY_BUFFER, g);\n      b.vertexAttribPointer(C.vertex, 2, b.FLOAT, !1, 16, 0);\n      b.vertexAttribPointer(C.uv, 2, b.FLOAT, !1, 16, 8);\n      b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, h);\n      b.disable(b.CULL_FACE);\n      b.depthMask(!1);\n      var H, B, W, F, K;\n      for (H = 0; H < v; H++) if (C = 16 / f, x.set(C * t, C), F = a[H], z.set(F.matrixWorld.elements[12], F.matrixWorld.elements[13], F.matrixWorld.elements[14]), z.applyMatrix4(d.matrixWorldInverse), z.applyProjection(d.projectionMatrix), G.copy(z), J.x = G.x * A + A, J.y = G.y * I + I, l || 0 < J.x && J.x < e && 0 < J.y && J.y < f) {\n        b.activeTexture(b.TEXTURE1);\n        b.bindTexture(b.TEXTURE_2D, i);\n        b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGB, J.x - 8, J.y - 8, 16, 16, 0);\n        b.uniform1i(E.renderType, 0);\n        b.uniform2f(E.scale, x.x, x.y);\n        b.uniform3f(E.screenPosition, G.x, G.y, G.z);\n        b.disable(b.BLEND);\n        b.enable(b.DEPTH_TEST);\n        b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0);\n        b.activeTexture(b.TEXTURE0);\n        b.bindTexture(b.TEXTURE_2D, k);\n        b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGBA, J.x - 8, J.y - 8, 16, 16, 0);\n        b.uniform1i(E.renderType, 1);\n        b.disable(b.DEPTH_TEST);\n        b.activeTexture(b.TEXTURE1);\n        b.bindTexture(b.TEXTURE_2D, i);\n        b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0);\n        F.positionScreen.copy(G);\n        F.customUpdateCallback ? F.customUpdateCallback(F) : F.updateLensFlares();\n        b.uniform1i(E.renderType, 2);\n        b.enable(b.BLEND);\n        B = 0;\n        for (W = F.lensFlares.length; B < W; B++) K = F.lensFlares[B], 0.001 < K.opacity && 0.001 < K.scale && (G.x = K.x, G.y = K.y, G.z = K.z, C = K.size * K.scale / f, x.x = C * t, x.y = C, b.uniform3f(E.screenPosition, G.x, G.y, G.z), b.uniform2f(E.scale, x.x, x.y), b.uniform1f(E.rotation, K.rotation), b.uniform1f(E.opacity, K.opacity), b.uniform3f(E.color, K.color.r, K.color.g, K.color.b), c.setBlending(K.blending, K.blendEquation, K.blendSrc, K.blendDst), c.setTexture(K.texture, 1), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0));\n      }\n      b.enable(b.CULL_FACE);\n      b.enable(b.DEPTH_TEST);\n      b.depthMask(!0);\n    }\n  };\n};\nTHREE.ShadowMapPlugin = function () {\n  var a,\n    b,\n    c,\n    d,\n    e,\n    f,\n    g = new THREE.Frustum(),\n    h = new THREE.Matrix4(),\n    i = new THREE.Vector3(),\n    k = new THREE.Vector3(),\n    l = new THREE.Vector3();\n  this.init = function (g) {\n    a = g.context;\n    b = g;\n    var g = THREE.ShaderLib.depthRGBA,\n      i = THREE.UniformsUtils.clone(g.uniforms);\n    c = new THREE.ShaderMaterial({\n      fragmentShader: g.fragmentShader,\n      vertexShader: g.vertexShader,\n      uniforms: i\n    });\n    d = new THREE.ShaderMaterial({\n      fragmentShader: g.fragmentShader,\n      vertexShader: g.vertexShader,\n      uniforms: i,\n      morphTargets: !0\n    });\n    e = new THREE.ShaderMaterial({\n      fragmentShader: g.fragmentShader,\n      vertexShader: g.vertexShader,\n      uniforms: i,\n      skinning: !0\n    });\n    f = new THREE.ShaderMaterial({\n      fragmentShader: g.fragmentShader,\n      vertexShader: g.vertexShader,\n      uniforms: i,\n      morphTargets: !0,\n      skinning: !0\n    });\n    c._shadowPass = !0;\n    d._shadowPass = !0;\n    e._shadowPass = !0;\n    f._shadowPass = !0;\n  };\n  this.render = function (a, c) {\n    b.shadowMapEnabled && b.shadowMapAutoUpdate && this.update(a, c);\n  };\n  this.update = function (m, n) {\n    var s,\n      r,\n      p,\n      q,\n      y,\n      v,\n      z,\n      t,\n      A,\n      I = [];\n    q = 0;\n    a.clearColor(1, 1, 1, 1);\n    a.disable(a.BLEND);\n    a.enable(a.CULL_FACE);\n    a.frontFace(a.CCW);\n    b.shadowMapCullFace === THREE.CullFaceFront ? a.cullFace(a.FRONT) : a.cullFace(a.BACK);\n    b.setDepthTest(!0);\n    s = 0;\n    for (r = m.__lights.length; s < r; s++) if (p = m.__lights[s], p.castShadow) if (p instanceof THREE.DirectionalLight && p.shadowCascade) for (y = 0; y < p.shadowCascadeCount; y++) {\n      var C;\n      if (p.shadowCascadeArray[y]) C = p.shadowCascadeArray[y];else {\n        A = p;\n        z = y;\n        C = new THREE.DirectionalLight();\n        C.isVirtual = !0;\n        C.onlyShadow = !0;\n        C.castShadow = !0;\n        C.shadowCameraNear = A.shadowCameraNear;\n        C.shadowCameraFar = A.shadowCameraFar;\n        C.shadowCameraLeft = A.shadowCameraLeft;\n        C.shadowCameraRight = A.shadowCameraRight;\n        C.shadowCameraBottom = A.shadowCameraBottom;\n        C.shadowCameraTop = A.shadowCameraTop;\n        C.shadowCameraVisible = A.shadowCameraVisible;\n        C.shadowDarkness = A.shadowDarkness;\n        C.shadowBias = A.shadowCascadeBias[z];\n        C.shadowMapWidth = A.shadowCascadeWidth[z];\n        C.shadowMapHeight = A.shadowCascadeHeight[z];\n        C.pointsWorld = [];\n        C.pointsFrustum = [];\n        t = C.pointsWorld;\n        v = C.pointsFrustum;\n        for (var x = 0; 8 > x; x++) t[x] = new THREE.Vector3(), v[x] = new THREE.Vector3();\n        t = A.shadowCascadeNearZ[z];\n        A = A.shadowCascadeFarZ[z];\n        v[0].set(-1, -1, t);\n        v[1].set(1, -1, t);\n        v[2].set(-1, 1, t);\n        v[3].set(1, 1, t);\n        v[4].set(-1, -1, A);\n        v[5].set(1, -1, A);\n        v[6].set(-1, 1, A);\n        v[7].set(1, 1, A);\n        C.originalCamera = n;\n        v = new THREE.Gyroscope();\n        v.position = p.shadowCascadeOffset;\n        v.add(C);\n        v.add(C.target);\n        n.add(v);\n        p.shadowCascadeArray[y] = C;\n        console.log(\"Created virtualLight\", C);\n      }\n      z = p;\n      t = y;\n      A = z.shadowCascadeArray[t];\n      A.position.copy(z.position);\n      A.target.position.copy(z.target.position);\n      A.lookAt(A.target);\n      A.shadowCameraVisible = z.shadowCameraVisible;\n      A.shadowDarkness = z.shadowDarkness;\n      A.shadowBias = z.shadowCascadeBias[t];\n      v = z.shadowCascadeNearZ[t];\n      z = z.shadowCascadeFarZ[t];\n      A = A.pointsFrustum;\n      A[0].z = v;\n      A[1].z = v;\n      A[2].z = v;\n      A[3].z = v;\n      A[4].z = z;\n      A[5].z = z;\n      A[6].z = z;\n      A[7].z = z;\n      I[q] = C;\n      q++;\n    } else I[q] = p, q++;\n    s = 0;\n    for (r = I.length; s < r; s++) {\n      p = I[s];\n      p.shadowMap || (y = THREE.LinearFilter, b.shadowMapType === THREE.PCFSoftShadowMap && (y = THREE.NearestFilter), p.shadowMap = new THREE.WebGLRenderTarget(p.shadowMapWidth, p.shadowMapHeight, {\n        minFilter: y,\n        magFilter: y,\n        format: THREE.RGBAFormat\n      }), p.shadowMapSize = new THREE.Vector2(p.shadowMapWidth, p.shadowMapHeight), p.shadowMatrix = new THREE.Matrix4());\n      if (!p.shadowCamera) {\n        if (p instanceof THREE.SpotLight) p.shadowCamera = new THREE.PerspectiveCamera(p.shadowCameraFov, p.shadowMapWidth / p.shadowMapHeight, p.shadowCameraNear, p.shadowCameraFar);else if (p instanceof THREE.DirectionalLight) p.shadowCamera = new THREE.OrthographicCamera(p.shadowCameraLeft, p.shadowCameraRight, p.shadowCameraTop, p.shadowCameraBottom, p.shadowCameraNear, p.shadowCameraFar);else {\n          console.error(\"Unsupported light type for shadow\");\n          continue;\n        }\n        m.add(p.shadowCamera);\n        b.autoUpdateScene && m.updateMatrixWorld();\n      }\n      p.shadowCameraVisible && !p.cameraHelper && (p.cameraHelper = new THREE.CameraHelper(p.shadowCamera), p.shadowCamera.add(p.cameraHelper));\n      if (p.isVirtual && C.originalCamera == n) {\n        y = n;\n        q = p.shadowCamera;\n        v = p.pointsFrustum;\n        A = p.pointsWorld;\n        i.set(Infinity, Infinity, Infinity);\n        k.set(-Infinity, -Infinity, -Infinity);\n        for (z = 0; 8 > z; z++) t = A[z], t.copy(v[z]), THREE.ShadowMapPlugin.__projector.unprojectVector(t, y), t.applyMatrix4(q.matrixWorldInverse), t.x < i.x && (i.x = t.x), t.x > k.x && (k.x = t.x), t.y < i.y && (i.y = t.y), t.y > k.y && (k.y = t.y), t.z < i.z && (i.z = t.z), t.z > k.z && (k.z = t.z);\n        q.left = i.x;\n        q.right = k.x;\n        q.top = k.y;\n        q.bottom = i.y;\n        q.updateProjectionMatrix();\n      }\n      q = p.shadowMap;\n      v = p.shadowMatrix;\n      y = p.shadowCamera;\n      y.position.getPositionFromMatrix(p.matrixWorld);\n      l.getPositionFromMatrix(p.target.matrixWorld);\n      y.lookAt(l);\n      y.updateMatrixWorld();\n      y.matrixWorldInverse.getInverse(y.matrixWorld);\n      p.cameraHelper && (p.cameraHelper.visible = p.shadowCameraVisible);\n      p.shadowCameraVisible && p.cameraHelper.update();\n      v.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      v.multiply(y.projectionMatrix);\n      v.multiply(y.matrixWorldInverse);\n      h.multiplyMatrices(y.projectionMatrix, y.matrixWorldInverse);\n      g.setFromMatrix(h);\n      b.setRenderTarget(q);\n      b.clear();\n      A = m.__webglObjects;\n      p = 0;\n      for (q = A.length; p < q; p++) if (z = A[p], v = z.object, z.render = !1, v.visible && v.castShadow && (!(v instanceof THREE.Mesh || v instanceof THREE.ParticleSystem) || !v.frustumCulled || g.intersectsObject(v))) v._modelViewMatrix.multiplyMatrices(y.matrixWorldInverse, v.matrixWorld), z.render = !0;\n      p = 0;\n      for (q = A.length; p < q; p++) z = A[p], z.render && (v = z.object, z = z.buffer, x = v.material instanceof THREE.MeshFaceMaterial ? v.material.materials[0] : v.material, t = 0 < v.geometry.morphTargets.length && x.morphTargets, x = v instanceof THREE.SkinnedMesh && x.skinning, t = v.customDepthMaterial ? v.customDepthMaterial : x ? t ? f : e : t ? d : c, z instanceof THREE.BufferGeometry ? b.renderBufferDirect(y, m.__lights, null, t, z, v) : b.renderBuffer(y, m.__lights, null, t, z, v));\n      A = m.__webglObjectsImmediate;\n      p = 0;\n      for (q = A.length; p < q; p++) z = A[p], v = z.object, v.visible && v.castShadow && (v._modelViewMatrix.multiplyMatrices(y.matrixWorldInverse, v.matrixWorld), b.renderImmediateObject(y, m.__lights, null, c, v));\n    }\n    s = b.getClearColor();\n    r = b.getClearAlpha();\n    a.clearColor(s.r, s.g, s.b, r);\n    a.enable(a.BLEND);\n    b.shadowMapCullFace === THREE.CullFaceFront && a.cullFace(a.BACK);\n  };\n};\nTHREE.ShadowMapPlugin.__projector = new THREE.Projector();\nTHREE.SpritePlugin = function () {\n  function a(a, b) {\n    return a.z !== b.z ? b.z - a.z : b.id - a.id;\n  }\n  var b, c, d, e, f, g, h, i, k, l;\n  this.init = function (a) {\n    b = a.context;\n    c = a;\n    d = a.getPrecision();\n    e = new Float32Array(16);\n    f = new Uint16Array(6);\n    a = 0;\n    e[a++] = -1;\n    e[a++] = -1;\n    e[a++] = 0;\n    e[a++] = 0;\n    e[a++] = 1;\n    e[a++] = -1;\n    e[a++] = 1;\n    e[a++] = 0;\n    e[a++] = 1;\n    e[a++] = 1;\n    e[a++] = 1;\n    e[a++] = 1;\n    e[a++] = -1;\n    e[a++] = 1;\n    e[a++] = 0;\n    e[a++] = 1;\n    a = 0;\n    f[a++] = 0;\n    f[a++] = 1;\n    f[a++] = 2;\n    f[a++] = 0;\n    f[a++] = 2;\n    f[a++] = 3;\n    g = b.createBuffer();\n    h = b.createBuffer();\n    b.bindBuffer(b.ARRAY_BUFFER, g);\n    b.bufferData(b.ARRAY_BUFFER, e, b.STATIC_DRAW);\n    b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, h);\n    b.bufferData(b.ELEMENT_ARRAY_BUFFER, f, b.STATIC_DRAW);\n    var a = THREE.ShaderSprite.sprite,\n      n = b.createProgram(),\n      s = b.createShader(b.FRAGMENT_SHADER),\n      r = b.createShader(b.VERTEX_SHADER),\n      p = \"precision \" + d + \" float;\\n\";\n    b.shaderSource(s, p + a.fragmentShader);\n    b.shaderSource(r, p + a.vertexShader);\n    b.compileShader(s);\n    b.compileShader(r);\n    b.attachShader(n, s);\n    b.attachShader(n, r);\n    b.linkProgram(n);\n    i = n;\n    k = {};\n    l = {};\n    k.position = b.getAttribLocation(i, \"position\");\n    k.uv = b.getAttribLocation(i, \"uv\");\n    l.uvOffset = b.getUniformLocation(i, \"uvOffset\");\n    l.uvScale = b.getUniformLocation(i, \"uvScale\");\n    l.rotation = b.getUniformLocation(i, \"rotation\");\n    l.scale = b.getUniformLocation(i, \"scale\");\n    l.alignment = b.getUniformLocation(i, \"alignment\");\n    l.color = b.getUniformLocation(i, \"color\");\n    l.map = b.getUniformLocation(i, \"map\");\n    l.opacity = b.getUniformLocation(i, \"opacity\");\n    l.useScreenCoordinates = b.getUniformLocation(i, \"useScreenCoordinates\");\n    l.sizeAttenuation = b.getUniformLocation(i, \"sizeAttenuation\");\n    l.screenPosition = b.getUniformLocation(i, \"screenPosition\");\n    l.modelViewMatrix = b.getUniformLocation(i, \"modelViewMatrix\");\n    l.projectionMatrix = b.getUniformLocation(i, \"projectionMatrix\");\n    l.fogType = b.getUniformLocation(i, \"fogType\");\n    l.fogDensity = b.getUniformLocation(i, \"fogDensity\");\n    l.fogNear = b.getUniformLocation(i, \"fogNear\");\n    l.fogFar = b.getUniformLocation(i, \"fogFar\");\n    l.fogColor = b.getUniformLocation(i, \"fogColor\");\n    l.alphaTest = b.getUniformLocation(i, \"alphaTest\");\n  };\n  this.render = function (d, e, f, r) {\n    var p = d.__webglSprites,\n      q = p.length;\n    if (q) {\n      var y = k,\n        v = l,\n        z = r / f,\n        f = 0.5 * f,\n        t = 0.5 * r;\n      b.useProgram(i);\n      b.enableVertexAttribArray(y.position);\n      b.enableVertexAttribArray(y.uv);\n      b.disable(b.CULL_FACE);\n      b.enable(b.BLEND);\n      b.bindBuffer(b.ARRAY_BUFFER, g);\n      b.vertexAttribPointer(y.position, 2, b.FLOAT, !1, 16, 0);\n      b.vertexAttribPointer(y.uv, 2, b.FLOAT, !1, 16, 8);\n      b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, h);\n      b.uniformMatrix4fv(v.projectionMatrix, !1, e.projectionMatrix.elements);\n      b.activeTexture(b.TEXTURE0);\n      b.uniform1i(v.map, 0);\n      var A = y = 0,\n        I = d.fog;\n      I ? (b.uniform3f(v.fogColor, I.color.r, I.color.g, I.color.b), I instanceof THREE.Fog ? (b.uniform1f(v.fogNear, I.near), b.uniform1f(v.fogFar, I.far), b.uniform1i(v.fogType, 1), A = y = 1) : I instanceof THREE.FogExp2 && (b.uniform1f(v.fogDensity, I.density), b.uniform1i(v.fogType, 2), A = y = 2)) : (b.uniform1i(v.fogType, 0), A = y = 0);\n      for (var C, x, G = [], I = 0; I < q; I++) C = p[I], x = C.material, C.visible && 0 !== x.opacity && (x.useScreenCoordinates ? C.z = -C.position.z : (C._modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, C.matrixWorld), C.z = -C._modelViewMatrix.elements[14]));\n      p.sort(a);\n      for (I = 0; I < q; I++) C = p[I], x = C.material, C.visible && 0 !== x.opacity && x.map && x.map.image && x.map.image.width && (b.uniform1f(v.alphaTest, x.alphaTest), !0 === x.useScreenCoordinates ? (b.uniform1i(v.useScreenCoordinates, 1), b.uniform3f(v.screenPosition, (C.position.x * c.devicePixelRatio - f) / f, (t - C.position.y * c.devicePixelRatio) / t, Math.max(0, Math.min(1, C.position.z))), G[0] = c.devicePixelRatio, G[1] = c.devicePixelRatio) : (b.uniform1i(v.useScreenCoordinates, 0), b.uniform1i(v.sizeAttenuation, x.sizeAttenuation ? 1 : 0), b.uniformMatrix4fv(v.modelViewMatrix, !1, C._modelViewMatrix.elements), G[0] = 1, G[1] = 1), e = d.fog && x.fog ? A : 0, y !== e && (b.uniform1i(v.fogType, e), y = e), e = 1 / (x.scaleByViewport ? r : 1), G[0] *= e * z * C.scale.x, G[1] *= e * C.scale.y, b.uniform2f(v.uvScale, x.uvScale.x, x.uvScale.y), b.uniform2f(v.uvOffset, x.uvOffset.x, x.uvOffset.y), b.uniform2f(v.alignment, x.alignment.x, x.alignment.y), b.uniform1f(v.opacity, x.opacity), b.uniform3f(v.color, x.color.r, x.color.g, x.color.b), b.uniform1f(v.rotation, C.rotation), b.uniform2fv(v.scale, G), c.setBlending(x.blending, x.blendEquation, x.blendSrc, x.blendDst), c.setDepthTest(x.depthTest), c.setDepthWrite(x.depthWrite), c.setTexture(x.map, 0), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0));\n      b.enable(b.CULL_FACE);\n    }\n  };\n};\nTHREE.DepthPassPlugin = function () {\n  this.enabled = !1;\n  this.renderTarget = null;\n  var a,\n    b,\n    c,\n    d,\n    e,\n    f,\n    g = new THREE.Frustum(),\n    h = new THREE.Matrix4();\n  this.init = function (g) {\n    a = g.context;\n    b = g;\n    var g = THREE.ShaderLib.depthRGBA,\n      h = THREE.UniformsUtils.clone(g.uniforms);\n    c = new THREE.ShaderMaterial({\n      fragmentShader: g.fragmentShader,\n      vertexShader: g.vertexShader,\n      uniforms: h\n    });\n    d = new THREE.ShaderMaterial({\n      fragmentShader: g.fragmentShader,\n      vertexShader: g.vertexShader,\n      uniforms: h,\n      morphTargets: !0\n    });\n    e = new THREE.ShaderMaterial({\n      fragmentShader: g.fragmentShader,\n      vertexShader: g.vertexShader,\n      uniforms: h,\n      skinning: !0\n    });\n    f = new THREE.ShaderMaterial({\n      fragmentShader: g.fragmentShader,\n      vertexShader: g.vertexShader,\n      uniforms: h,\n      morphTargets: !0,\n      skinning: !0\n    });\n    c._shadowPass = !0;\n    d._shadowPass = !0;\n    e._shadowPass = !0;\n    f._shadowPass = !0;\n  };\n  this.render = function (a, b) {\n    this.enabled && this.update(a, b);\n  };\n  this.update = function (i, k) {\n    var l, m, n, s, r, p;\n    a.clearColor(1, 1, 1, 1);\n    a.disable(a.BLEND);\n    b.setDepthTest(!0);\n    b.autoUpdateScene && i.updateMatrixWorld();\n    k.matrixWorldInverse.getInverse(k.matrixWorld);\n    h.multiplyMatrices(k.projectionMatrix, k.matrixWorldInverse);\n    g.setFromMatrix(h);\n    b.setRenderTarget(this.renderTarget);\n    b.clear();\n    p = i.__webglObjects;\n    l = 0;\n    for (m = p.length; l < m; l++) if (n = p[l], r = n.object, n.render = !1, r.visible && (!(r instanceof THREE.Mesh || r instanceof THREE.ParticleSystem) || !r.frustumCulled || g.intersectsObject(r))) r._modelViewMatrix.multiplyMatrices(k.matrixWorldInverse, r.matrixWorld), n.render = !0;\n    var q;\n    l = 0;\n    for (m = p.length; l < m; l++) if (n = p[l], n.render && (r = n.object, n = n.buffer, !(r instanceof THREE.ParticleSystem) || r.customDepthMaterial)) (q = r.material instanceof THREE.MeshFaceMaterial ? r.material.materials[0] : r.material) && b.setMaterialFaces(r.material), s = 0 < r.geometry.morphTargets.length && q.morphTargets, q = r instanceof THREE.SkinnedMesh && q.skinning, s = r.customDepthMaterial ? r.customDepthMaterial : q ? s ? f : e : s ? d : c, n instanceof THREE.BufferGeometry ? b.renderBufferDirect(k, i.__lights, null, s, n, r) : b.renderBuffer(k, i.__lights, null, s, n, r);\n    p = i.__webglObjectsImmediate;\n    l = 0;\n    for (m = p.length; l < m; l++) n = p[l], r = n.object, r.visible && (r._modelViewMatrix.multiplyMatrices(k.matrixWorldInverse, r.matrixWorld), b.renderImmediateObject(k, i.__lights, null, c, r));\n    l = b.getClearColor();\n    m = b.getClearAlpha();\n    a.clearColor(l.r, l.g, l.b, m);\n    a.enable(a.BLEND);\n  };\n};\nTHREE.ShaderFlares = {\n  lensFlareVertexTexture: {\n    vertexShader: \"uniform lowp int renderType;\\nuniform vec3 screenPosition;\\nuniform vec2 scale;\\nuniform float rotation;\\nuniform sampler2D occlusionMap;\\nattribute vec2 position;\\nattribute vec2 uv;\\nvarying vec2 vUV;\\nvarying float vVisibility;\\nvoid main() {\\nvUV = uv;\\nvec2 pos = position;\\nif( renderType == 2 ) {\\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) ) +\\ntexture2D( occlusionMap, vec2( 0.5, 0.1 ) ) +\\ntexture2D( occlusionMap, vec2( 0.9, 0.1 ) ) +\\ntexture2D( occlusionMap, vec2( 0.9, 0.5 ) ) +\\ntexture2D( occlusionMap, vec2( 0.9, 0.9 ) ) +\\ntexture2D( occlusionMap, vec2( 0.5, 0.9 ) ) +\\ntexture2D( occlusionMap, vec2( 0.1, 0.9 ) ) +\\ntexture2D( occlusionMap, vec2( 0.1, 0.5 ) ) +\\ntexture2D( occlusionMap, vec2( 0.5, 0.5 ) );\\nvVisibility = (       visibility.r / 9.0 ) *\\n( 1.0 - visibility.g / 9.0 ) *\\n(       visibility.b / 9.0 ) *\\n( 1.0 - visibility.a / 9.0 );\\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\\n}\\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\\n}\",\n    fragmentShader: \"uniform lowp int renderType;\\nuniform sampler2D map;\\nuniform float opacity;\\nuniform vec3 color;\\nvarying vec2 vUV;\\nvarying float vVisibility;\\nvoid main() {\\nif( renderType == 0 ) {\\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\\n} else if( renderType == 1 ) {\\ngl_FragColor = texture2D( map, vUV );\\n} else {\\nvec4 texture = texture2D( map, vUV );\\ntexture.a *= opacity * vVisibility;\\ngl_FragColor = texture;\\ngl_FragColor.rgb *= color;\\n}\\n}\"\n  },\n  lensFlare: {\n    vertexShader: \"uniform lowp int renderType;\\nuniform vec3 screenPosition;\\nuniform vec2 scale;\\nuniform float rotation;\\nattribute vec2 position;\\nattribute vec2 uv;\\nvarying vec2 vUV;\\nvoid main() {\\nvUV = uv;\\nvec2 pos = position;\\nif( renderType == 2 ) {\\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\\n}\\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\\n}\",\n    fragmentShader: \"precision mediump float;\\nuniform lowp int renderType;\\nuniform sampler2D map;\\nuniform sampler2D occlusionMap;\\nuniform float opacity;\\nuniform vec3 color;\\nvarying vec2 vUV;\\nvoid main() {\\nif( renderType == 0 ) {\\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\\n} else if( renderType == 1 ) {\\ngl_FragColor = texture2D( map, vUV );\\n} else {\\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a +\\ntexture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a +\\ntexture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a +\\ntexture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\\nvisibility = ( 1.0 - visibility / 4.0 );\\nvec4 texture = texture2D( map, vUV );\\ntexture.a *= opacity * visibility;\\ngl_FragColor = texture;\\ngl_FragColor.rgb *= color;\\n}\\n}\"\n  }\n};\nTHREE.ShaderSprite = {\n  sprite: {\n    vertexShader: \"uniform int useScreenCoordinates;\\nuniform int sizeAttenuation;\\nuniform vec3 screenPosition;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform float rotation;\\nuniform vec2 scale;\\nuniform vec2 alignment;\\nuniform vec2 uvOffset;\\nuniform vec2 uvScale;\\nattribute vec2 position;\\nattribute vec2 uv;\\nvarying vec2 vUV;\\nvoid main() {\\nvUV = uvOffset + uv * uvScale;\\nvec2 alignedPosition = position + alignment;\\nvec2 rotatedPosition;\\nrotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;\\nrotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;\\nvec4 finalPosition;\\nif( useScreenCoordinates != 0 ) {\\nfinalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );\\n} else {\\nfinalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\nfinalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );\\n}\\ngl_Position = finalPosition;\\n}\",\n    fragmentShader: \"uniform vec3 color;\\nuniform sampler2D map;\\nuniform float opacity;\\nuniform int fogType;\\nuniform vec3 fogColor;\\nuniform float fogDensity;\\nuniform float fogNear;\\nuniform float fogFar;\\nuniform float alphaTest;\\nvarying vec2 vUV;\\nvoid main() {\\nvec4 texture = texture2D( map, vUV );\\nif ( texture.a < alphaTest ) discard;\\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\\nif ( fogType > 0 ) {\\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\nfloat fogFactor = 0.0;\\nif ( fogType == 1 ) {\\nfogFactor = smoothstep( fogNear, fogFar, depth );\\n} else {\\nconst float LOG2 = 1.442695;\\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\\n}\\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n}\\n}\"\n  }\n};\nvar SEPARATION = 100,\n  AMOUNTX = 100,\n  AMOUNTY = 70;\nvar container;\nvar camera, scene, renderer;\nvar particles,\n  particle,\n  count = 0;\nvar mouseX = 85,\n  mouseY = -342;\nvar windowHalfX = window.innerWidth / 2;\nvar windowHalfY = window.innerHeight / 2;\ninit();\nanimate();\nfunction init() {\n  container = document.createElement('div');\n  var home = document.getElementById(\"home\").appendChild(container);\n  var hTwoOne = document.createElement('h2');\n  var span = document.createElement('span');\n  var hTwoTwo = document.createElement('h2');\n  home.appendChild(hTwoOne);\n  hTwoOne.textContent = \"Hello I'm \";\n  hTwoOne.setAttribute('id', 'text');\n  var hTwoOneEl = document.getElementById('text');\n  var spanEl = hTwoOneEl.appendChild(span);\n  spanEl.textContent = \"Anthony Manzione.\";\n  var hTwoTwoEl = home.appendChild(hTwoTwo);\n  hTwoTwoEl.textContent = \"I'm a full-stack web developer.\";\n  hTwoTwoEl.setAttribute('id', 'textTwo');\n  hTwoOne.setAttribute('class', 'text-center');\n  hTwoTwo.setAttribute('class', 'text-center');\n  hTwoOne.style.lineHeight = \"100%\";\n  hTwoTwo.style.lineHeight = \"100%\";\n  camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 1, 10000);\n  camera.position.z = 1000;\n  scene = new THREE.Scene();\n  particles = new Array();\n  var PI2 = Math.PI * 2;\n  var material = new THREE.ParticleCanvasMaterial({\n    color: 0xe1e1e1,\n    program: function program(context) {\n      context.beginPath();\n      context.arc(0, 0, .6, 0, PI2, true);\n      context.fill();\n    }\n  });\n  var i = 0;\n  for (var ix = 0; ix < AMOUNTX; ix++) {\n    for (var iy = 0; iy < AMOUNTY; iy++) {\n      particle = particles[i++] = new THREE.Particle(material);\n      particle.position.x = ix * SEPARATION - AMOUNTX * SEPARATION / 2;\n      particle.position.z = iy * SEPARATION - AMOUNTY * SEPARATION / 2;\n      scene.add(particle);\n    }\n  }\n  renderer = new THREE.CanvasRenderer();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  container.appendChild(renderer.domElement);\n  document.addEventListener('mousemove', onDocumentMouseMove, false);\n  document.addEventListener('touchstart', onDocumentTouchStart, false);\n  document.addEventListener('touchmove', onDocumentTouchMove, false);\n\n  //\n\n  window.addEventListener('resize', onWindowResize, false);\n}\nfunction onWindowResize() {\n  windowHalfX = window.innerWidth / 2;\n  windowHalfY = window.innerHeight / 2;\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n}\n\n//\n\nfunction onDocumentMouseMove(event) {\n  mouseX = event.clientX - windowHalfX;\n  mouseY = event.clientY - windowHalfY;\n}\nfunction onDocumentTouchStart(event) {\n  if (event.touches.length === 1) {\n    event.preventDefault();\n    mouseX = event.touches[0].pageX - windowHalfX;\n    mouseY = event.touches[0].pageY - windowHalfY;\n  }\n}\nfunction onDocumentTouchMove(event) {\n  if (event.touches.length === 1) {\n    event.preventDefault();\n    mouseX = event.touches[0].pageX - windowHalfX;\n    mouseY = event.touches[0].pageY - windowHalfY;\n  }\n}\n\n//\n\nfunction animate() {\n  requestAnimationFrame(animate);\n  render();\n}\nfunction render() {\n  camera.position.x += (mouseX - camera.position.x) * .05;\n  camera.position.y += (-mouseY - camera.position.y) * .05;\n  camera.lookAt(scene.position);\n  var i = 0;\n  for (var ix = 0; ix < AMOUNTX; ix++) {\n    for (var iy = 0; iy < AMOUNTY; iy++) {\n      particle = particles[i++];\n      particle.position.y = Math.sin((ix + count) * 0.3) * 50 + Math.sin((iy + count) * 0.5) * 50;\n      particle.scale.x = particle.scale.y = (Math.sin((ix + count) * 0.3) + 1) * 2 + (Math.sin((iy + count) * 0.5) + 1) * 2;\n    }\n  }\n  renderer.render(scene, camera);\n  count += 0.1;\n}\n\n//# sourceURL=webpack://17-ins_caching-images-client/./src/js/three.js?");

/***/ }),

/***/ "./src/css/style.css":
/*!***************************!*\
  !*** ./src/css/style.css ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://17-ins_caching-images-client/./src/css/style.css?");

/***/ }),

/***/ "./src/images/Icons/Github-Logos/GitHub-Mark-Light-120px-plus.png":
/*!************************************************************************!*\
  !*** ./src/images/Icons/Github-Logos/GitHub-Mark-Light-120px-plus.png ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"5de0643bf1bbf77878ff.png\";\n\n//# sourceURL=webpack://17-ins_caching-images-client/./src/images/Icons/Github-Logos/GitHub-Mark-Light-120px-plus.png?");

/***/ }),

/***/ "./src/images/Icons/linkedin-logo.png":
/*!********************************************!*\
  !*** ./src/images/Icons/linkedin-logo.png ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"15c75f236ac4e3f74352.png\";\n\n//# sourceURL=webpack://17-ins_caching-images-client/./src/images/Icons/linkedin-logo.png?");

/***/ }),

/***/ "./src/images/anthony-portrait.jpg":
/*!*****************************************!*\
  !*** ./src/images/anthony-portrait.jpg ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"3459bc54e44ba1e8cad1.jpg\";\n\n//# sourceURL=webpack://17-ins_caching-images-client/./src/images/anthony-portrait.jpg?");

/***/ }),

/***/ "./src/images/blogs/blog-one.png":
/*!***************************************!*\
  !*** ./src/images/blogs/blog-one.png ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"b3e6f04e79fee463dcb4.png\";\n\n//# sourceURL=webpack://17-ins_caching-images-client/./src/images/blogs/blog-one.png?");

/***/ }),

/***/ "./src/images/blogs/blog-two.png":
/*!***************************************!*\
  !*** ./src/images/blogs/blog-two.png ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"8e11ddab72ed20393484.png\";\n\n//# sourceURL=webpack://17-ins_caching-images-client/./src/images/blogs/blog-two.png?");

/***/ }),

/***/ "./src/images/gifs/port-one.gif":
/*!**************************************!*\
  !*** ./src/images/gifs/port-one.gif ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"795efc1086c3b0bee87d.gif\";\n\n//# sourceURL=webpack://17-ins_caching-images-client/./src/images/gifs/port-one.gif?");

/***/ }),

/***/ "./src/images/gifs/port-three.gif":
/*!****************************************!*\
  !*** ./src/images/gifs/port-three.gif ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"ef6b6ef26da71ed32447.gif\";\n\n//# sourceURL=webpack://17-ins_caching-images-client/./src/images/gifs/port-three.gif?");

/***/ }),

/***/ "./src/images/gifs/port-two.gif":
/*!**************************************!*\
  !*** ./src/images/gifs/port-two.gif ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"682229bafc875df3e570.gif\";\n\n//# sourceURL=webpack://17-ins_caching-images-client/./src/images/gifs/port-two.gif?");

/***/ }),

/***/ "./src/images/gifs/readme-generator.gif":
/*!**********************************************!*\
  !*** ./src/images/gifs/readme-generator.gif ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"86c274426445d23dc9f6.gif\";\n\n//# sourceURL=webpack://17-ins_caching-images-client/./src/images/gifs/readme-generator.gif?");

/***/ }),

/***/ "./src/images/gifs/team-profile-generator.gif":
/*!****************************************************!*\
  !*** ./src/images/gifs/team-profile-generator.gif ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"b6247618e33bcdf2d5ad.gif\";\n\n//# sourceURL=webpack://17-ins_caching-images-client/./src/images/gifs/team-profile-generator.gif?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;